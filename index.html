<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="do better">
<meta property="og:type" content="website">
<meta property="og:title" content="稠鱼烧才好吃">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="稠鱼烧才好吃">
<meta property="og:description" content="do better">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="稠鱼烧才好吃">
<meta name="twitter:description" content="do better">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>稠鱼烧才好吃</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">稠鱼烧才好吃</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/02/Angular CLI底层 ---- 神秘的构建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/02/Angular CLI底层 ---- 神秘的构建/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-02T14:12:09+08:00">
                2020-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Angular-CLI底层-—-神秘的构建"><a href="#Angular-CLI底层-—-神秘的构建" class="headerlink" title="Angular CLI底层 —- 神秘的构建"></a>Angular CLI底层 —- 神秘的构建</h1><p>本文翻译自<a href="https://medium.com/dailyjs/angular-cli-6-under-the-hood-builders-demystified-f0690ebcf01" target="_blank" rel="noopener">Angular CLI under the hood — builders demystified</a>。</p>
<!-- readMore -->
<p>今天我们将探究底层并从头开始创建自定的构建器。</p>
<h2 id="Angular-CLI构建"><a href="#Angular-CLI构建" class="headerlink" title="Angular CLI构建"></a>Angular CLI构建</h2><p>Angular CLI从6+版本开始不再使用之前老版本的，而采用了新的结构，划分成更小的模块。</p>
<p>事实上，Angular CLI不会对<em>angular.json</em>中提供的配置做处理，它只是包装了<a href="https://github.com/angular/angular-cli/tree/7.2.x/packages/angular_devkit" target="_blank" rel="noopener">Angular Dev Kit</a>并触发构建目标，简单来说：</p>
<ul>
<li>Angular CLI包中有很多预定义命令，帮助和CLI相关的东西。</li>
<li>Archiet包会处理<em>angular.json</em>的配置。它需要将构建目标映射成相关的构建器，然后再创建并将<em>angular.json</em>对应参数传递给构建器。</li>
<li>构建器器是真正干活的。比如<a href="https://github.com/angular/angular-cli/tree/7.2.x/packages/angular_devkit/build_angular/src/browser" target="_blank" rel="noopener">BrowserBuilder</a>为浏览器运行webpack，<a href="https://github.com/angular/angular-cli/tree/7.2.x/packages/angular_devkit/build_angular/src/karma" target="_blank" rel="noopener">KarmaBuilder</a>会在测试的时候启动Karma和运行webpack等等。</li>
</ul>
<h2 id="Angular-CLI命令和结构目标"><a href="#Angular-CLI命令和结构目标" class="headerlink" title="Angular CLI命令和结构目标"></a>Angular CLI命令和结构目标</h2><p>当我们运行<code>ng serve</code>和<code>ng test</code>或者任何<a href="https://github.com/angular/angular-cli/wiki" target="_blank" rel="noopener">预定义</a>的命令时候，会发生以下事情：</p>
<ul>
<li>Angular CLI命令会转变成相关结构目标</li>
<li>构建器被创建</li>
<li>相关参数会被传递给构建器</li>
</ul>
<p>当你运行自定义的构建器时候，只会发生上述的二和三。</p>
<p>简而言之，有一个通用的命令：<code>ng run</code>，它接受结构目标作为参数（格式为<code>project: target</code>）。</p>
<p>而任何Angular CLI预定义命令都会映射成结构目标而可以用ng run运行。比如说：</p>
<ul>
<li><code>ng build</code>: <code>ng run my-cool-project:build</code></li>
<li><code>ng test</code>: <code>ng run my-cool-project:test</code></li>
</ul>
<p>更美好的是你可以创建自己的构建器，并起名任意的目标名称。</p>
<p>比如说你可以为自己的构建器起名为<code>my-target</code>，并执行<code>ng run</code>命令：<code>ng run my-cool-project:my-target</code></p>
<p>或者你可以直接替换任意已经存在的目标并执行Angular CLI预定义目标。因为如上所述，Angular CLI会被映射成相关的结构目标</p>
<h2 id="结构目标配置"><a href="#结构目标配置" class="headerlink" title="结构目标配置"></a>结构目标配置</h2><p>让我们进一步查看<em>angular.json</em>配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"$schema"</span>: <span class="string">"./node_modules/@angular/cli/lib/config/schema.json"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"newProjectRoot"</span>: <span class="string">"projects"</span>,</span><br><span class="line">  <span class="attr">"projects"</span>: &#123;</span><br><span class="line">    <span class="attr">"example"</span>: &#123;</span><br><span class="line">      <span class="attr">"root"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"sourceRoot"</span>: <span class="string">"src"</span>,</span><br><span class="line">      <span class="attr">"projectType"</span>: <span class="string">"application"</span>,</span><br><span class="line">      <span class="attr">"prefix"</span>: <span class="string">"app"</span>,</span><br><span class="line">      <span class="attr">"schematics"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"architect"</span>: &#123;</span><br><span class="line">        <span class="attr">"build"</span>: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        "serve": &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个项目都有个入口叫做结构，并且包含所有的配置。在上述的demo中，我们只有一个项目叫做<code>example</code>，并且有两个结构目标：<code>build</code>和<code>serve</code></p>
<p>如果你想要有一个新的机构目标叫做<code>format</code>，你可以像这样添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;$schema&quot;: &quot;./node_modules/@angular/cli/lib/config/schema.json&quot;,</span><br><span class="line">  &quot;version&quot;: 1,</span><br><span class="line">  &quot;newProjectRoot&quot;: &quot;projects&quot;,</span><br><span class="line">  &quot;projects&quot;: &#123;</span><br><span class="line">    &quot;example&quot;: &#123;</span><br><span class="line">      &quot;root&quot;: &quot;&quot;,</span><br><span class="line">      &quot;sourceRoot&quot;: &quot;src&quot;,</span><br><span class="line">      &quot;projectType&quot;: &quot;application&quot;,</span><br><span class="line">      &quot;prefix&quot;: &quot;app&quot;,</span><br><span class="line">      &quot;schematics&quot;: &#123;&#125;,</span><br><span class="line">      &quot;architect&quot;: &#123;</span><br><span class="line">        &quot;build&quot;: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;serve&quot;: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;format&quot;: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个结构目标又包含三个属性：</p>
<ul>
<li><p><code>builder</code>：构建器的路径。</p>
<p>路径格式为<code>[package-path]:[builder-name]</code>，其中<code>[package-path]</code>是在<em>package.json</em>文件中定义过的入口依赖，而<code>[builder-name]</code>是<em>builder.json</em>文件中入口之一（我们之后还会讨论）。</p>
</li>
<li><p><code>options</code> ：构建器的配置。必须和构建器模式匹配，否则命令将会失败。</p>
</li>
<li><p><code>configurations</code>：替代目标（比如prod，dev等）选项的集合。这是可选属性。</p>
</li>
</ul>
<p>我们说了足够的理论背景，下面进入实战吧。</p>
<h2 id="创建自己的构建器"><a href="#创建自己的构建器" class="headerlink" title="创建自己的构建器"></a>创建自己的构建器</h2><p>我不喜欢做徒劳的事，所以我想出了一个好点子，它可比<em>Hello World Builder</em>厉害多了，但是又是相当的简单。</p>
<p>让我们来想象一个场景，你想要展示你的应用上次构建的的时间日期，我们可以把它放在某个文件中，系统将会加载获取然后在页脚展示。</p>
<p>我们要做的就是实现一个创建时间日期文件的构建器。</p>
<h3 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h3><p>一个包可以创建多个构建者，但是在我们例子中只有一个。</p>
<p>首先你需要为构建者包创建文件夹，然后加入<em>package.json</em>文件（结构认定构建者包是npm包）。</p>
<p><em>package.json</em>会多出一个入口：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"builders": "builders.json"</span><br></pre></td></tr></table></figure>
<p>提示：文件名不一定必须是<code>builders.json</code>，可以是任意你想的。</p>
<h3 id="builder-json"><a href="#builder-json" class="headerlink" title="builder.json"></a>builder.json</h3><p><code>builder.json</code>将会描述你的构建器。它是一个遵循Angular构建器结构的JSON文件，它将有以下结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;$schema&quot;: &quot;@angular-devkit/architect/src/builders-schema.json&quot;,</span><br><span class="line">  &quot;builders&quot;: &#123;</span><br><span class="line">    &quot;builder-name&quot;: &#123;</span><br><span class="line">      &quot;class&quot;: &quot;path-to-builder-class&quot;,</span><br><span class="line">      &quot;schema&quot;: &quot;path-to-builder-schema&quot;,</span><br><span class="line">      &quot;description&quot;: &quot;builder-description&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    ... more builders definitions</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个<code>builders.json</code>文件可以有多个构建器定义。</p>
<h3 id="构建器定义"><a href="#构建器定义" class="headerlink" title="构建器定义"></a>构建器定义</h3><p>每个构建器都有两个属性：</p>
<ol>
<li><code>class</code>：实现了<code>Builders</code>接口的Javascript文件路径。结构将会解析配置和创建实例。你可以在这里找到该接口定义。</li>
<li><code>schema</code>：定义了构建器配置的json schema路径（在结构中就是property属性）。结构将会验证配置是否符合schema定义，如果出错将会构建失败。</li>
</ol>
<p>这里是我们的自定义的<em>builders.json</em>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;$schema&quot;: &quot;@angular-devkit/architect/src/builders-schema.json&quot;,</span><br><span class="line">  &quot;builders&quot;: &#123;</span><br><span class="line">    &quot;file&quot;: &#123;</span><br><span class="line">      &quot;class&quot;: &quot;./timestamp.builder.js&quot;,</span><br><span class="line">      &quot;schema&quot;: &quot;./schema.json&quot;,</span><br><span class="line">      &quot;description&quot;: &quot;Builder that creates timestamp&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="schema-json"><a href="#schema-json" class="headerlink" title="schema.json"></a>schema.json</h3><p>我们允许开发者修改时间戳的格式和其保存路径，所以<em>schema.json</em>可以这么定义：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"id"</span>: <span class="string">"TimestampBuilderSchema"</span>,</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"Timestamp builder"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"Timestamp builder options"</span>,</span><br><span class="line">  <span class="string">"properties"</span>: &#123;</span><br><span class="line">    <span class="string">"format"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">      <span class="string">"description"</span>: <span class="string">"Timestamp format"</span>,</span><br><span class="line">      <span class="string">"default"</span>: <span class="string">"dd/mm/yyyy"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"path"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">      <span class="string">"description"</span>: <span class="string">"Path to the timestamp file"</span>,</span><br><span class="line">      <span class="string">"default"</span>: <span class="string">"./timestamp"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果开发者没有在配置中没有指定，就会用default值替代。</p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>为了格式化日期，我们使用dateformat包。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i dateformat</span><br></pre></td></tr></table></figure>
<p>我们会使用Typescript（不是强制的）来开发构建器，所以我们也会安装。</p>
<p>同时，我们也会用到使用<code>@angular-devkit/core</code>的方法和<code>@angular-devkit/architect</code>的接口。</p>
<p>为了更好的支持Typescript静态类型，我们最好也安装<code>@types</code>的<code>node</code>和<code>dateformat</code>。</p>
<p>以下是开发时候需要的依赖（<code>@angular-devkit</code>会在运行时期用到）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @angular-devkit/core @angular-devkit/architect @types/node @types/dateformat typescript</span><br></pre></td></tr></table></figure>
<h3 id="构建器"><a href="#构建器" class="headerlink" title="构建器"></a>构建器</h3><p>现在我们准备实现构建器。</p>
<p>首先我们在<em>schema.d.ts</em>文件中定义接口作为构建器配置类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> TimestampBuilderSchema &#123;</span><br><span class="line">	format: <span class="built_in">string</span>;</span><br><span class="line">	path: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后我们继承<code>Builder</code>泛型接口：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;Builder, BuilderConfiguration, BuilderContext, BuildEvent&#125; <span class="keyword">from</span> <span class="string">'@angular-devkit/architect'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Observable&#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;TimestampBuilderSchema&#125; <span class="keyword">from</span> <span class="string">'./schema'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> TimestampBuilder <span class="keyword">implements</span> Builder&lt;TimestampBuilderSchema&gt; &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> context: BuilderContext</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run(builderConfig: BuilderConfiguration&lt;Partial&lt;TimestampBuilderSchema&gt;&gt;): Observable&lt;BuildEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>run</code>方法需要返回<code>BuildEvent</code>类型的Observable：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> BuildEvent &#123;</span><br><span class="line">    success: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BuildEvent</code>将会提示结构是否执行成功，随后结构再会去告诉CLI，CLI会以合适的值退出进程。</p>
<p>在我们的例子中如果时间的文件创建成功就会返回成功标志，否则失败：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Builder, BuilderConfiguration, BuilderContext, BuildEvent&#125; <span class="keyword">from</span> <span class="string">'@angular-devkit/architect'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;bindNodeCallback, Observable, of&#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;catchError, map, tap&#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;TimestampBuilderSchema&#125; <span class="keyword">from</span> <span class="string">'./schema'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;getSystemPath&#125; <span class="keyword">from</span> <span class="string">'@angular-devkit/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;writeFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> dateFormat <span class="keyword">from</span> <span class="string">'dateformat'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> TimestampBuilder <span class="keyword">implements</span> Builder&lt;TimestampBuilderSchema&gt; &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> context: BuilderContext</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run(builderConfig: BuilderConfiguration&lt;Partial&lt;TimestampBuilderSchema&gt;&gt;): Observable&lt;BuildEvent&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">this</span>.context.workspace.root;</span><br><span class="line">    <span class="keyword">const</span> &#123;path, format&#125; = builderConfig.options;</span><br><span class="line">    <span class="keyword">const</span> timestampFileName = <span class="string">`<span class="subst">$&#123;getSystemPath(root)&#125;</span>/<span class="subst">$&#123;path&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">const</span> writeFileObservable = bindNodeCallback(writeFile);</span><br><span class="line">    <span class="keyword">return</span> writeFileObservable(timestampFileName, dateFormat(<span class="keyword">new</span> <span class="built_in">Date</span>(), format)).pipe(</span><br><span class="line">      map(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;success: <span class="literal">true</span>&#125;)),</span><br><span class="line">      tap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.context.logger.info(<span class="string">"Timestamp created"</span>)),</span><br><span class="line">      catchError(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.context.logger.error(<span class="string">"Failed to create timestamp"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> of(&#123;success: <span class="literal">false</span>&#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们分解一哈：</p>
<ol>
<li>我们先获取应用的根目录</li>
<li>然后我们获取<code>path</code>和<code>format</code>参数。他们应该在应用的<em>angular.json</em>文件配置中指明，否则就会有默认值。</li>
<li><code>getSystemPath</code>方法是获取系统准确路径的，它将和<code>path</code>结合起来作为我们需要创建出的文件路径。</li>
<li>我们使用<code>fs</code>模块的<code>writeFile</code>方法，但最终需要返回Observable对象，但<code>writeFile</code>是回调函数，因此我们用<code>bindNodeCallback</code>方法将其转为成具有返回observable对象的函数。</li>
<li>我们将<code>format</code>参数传递给<code>formatDate</code>方法，并将返回的日期写入文件中。</li>
<li>以后如果文件创建成功，我们就返回成功，否则返回失败。</li>
</ol>
<p>顺利地将源代码编译成JavaScript。</p>
<h3 id="使用构建器"><a href="#使用构建器" class="headerlink" title="使用构建器"></a>使用构建器</h3><p>现在构建器已经准备就绪，你可以通过在<em>angular.json</em>文件指定<code>timestamp</code>包的相关路径使用它：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"architect"</span>: &#123;</span><br><span class="line">        <span class="string">"timestamp"</span>: &#123;</span><br><span class="line">          <span class="string">"builder"</span>: <span class="string">"[relative-path-to-timestamp-package]:file"</span>,</span><br><span class="line">          <span class="string">"options"</span>: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者将它打包成npm包，并在本地安装：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm pack</span><br><span class="line">cp angular-builders-timestamp<span class="number">-1.0</span><span class="number">.0</span>.tgz [host-application-root]</span><br><span class="line">cd [host-application-root]</span><br><span class="line">npm i -D angular-builders-timestamp<span class="number">-1.0</span><span class="number">.0</span>.tgz</span><br></pre></td></tr></table></figure>
<p><em>angular.json</em></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"architect": &#123;</span><br><span class="line">        "timestamp": &#123;</span><br><span class="line">          "builder": "@angular-builders/timestamp:file",</span><br><span class="line">          "options": &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>我希望你能享受这篇文章并能很好的理解构建器。</p>
<p>所有的<code>timestamp</code>构建器（上述demo）源代码都可以在<a href="https://github.com/just-jeb/angular-builders/tree/7.x.x/packages/timestamp" target="_blank" rel="noopener">这里</a>找到。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/02/动手写webpack：代码分离/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/02/动手写webpack：代码分离/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-02T14:12:08+08:00">
                2020-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="动手写webpack：代码分离"><a href="#动手写webpack：代码分离" class="headerlink" title="动手写webpack：代码分离"></a>动手写webpack：代码分离</h1><p>代码分离的意义在于将模块分到不同的chunk中，减小文件的大小，同时可以按需加载或者并行加载文件，加快响应时间。常用的代码分离有三种：</p>
<ol>
<li>入口起点：配置entry参数手动分离代码。</li>
<li>防止重复：配置optimization去重和分离chunk。</li>
<li>动态导入：调用import函数分离代码。</li>
</ol>
<!-- read more -->
<p>这里我们只实现第三种分离方式。</p>
<h2 id="chunk、module和bundle"><a href="#chunk、module和bundle" class="headerlink" title="chunk、module和bundle"></a>chunk、module和bundle</h2><p>在研究代码分离之前，我们先明白这三个名词，尤其是chunk的含义，因为分离主要建立在它的基础之上。</p>
<ul>
<li>module可以理解成一个文件，每个文件就是modu了，导入某个文件时就是导入了某个module。</li>
<li>chunk是多个module的集合，可以是一对一，也可以是一对多。如何结合module就是拆分的逻辑。</li>
<li>bundle可以看作是一对一的chunk，是chunk的最后输出，中间还经历了压缩等步骤。</li>
</ul>
<h2 id="分离点选择"><a href="#分离点选择" class="headerlink" title="分离点选择"></a>分离点选择</h2><p>在这里我们只实现第三步的代码分离，即识别<code>import</code>函数调用。当分离遇到导入相同的模块怎么办，有几点需要遵守：</p>
<ol>
<li>当主chunk也加载了模块，模块应该打包到主chunk中。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; z &#125; <span class="keyword">from</span> <span class="string">"./common"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">afn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; z &#125; <span class="keyword">from</span> <span class="string">"./common"</span>;</span><br><span class="line"><span class="keyword">import</span>(<span class="string">"./a"</span>).then(<span class="function">(<span class="params">a</span>) =&gt;</span> a.afn());		<span class="comment">// common.js会打包到mainchunk中</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>异步的chunk加载了相同的模块，主chunk并没有，模块打包到各自chunk中。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; z &#125; <span class="keyword">from</span> <span class="string">"./common"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">afn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; z &#125; <span class="keyword">from</span> <span class="string">"./common"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bfn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">"./a"</span>).then(<span class="function">(<span class="params">a</span>) =&gt;</span> a.afn());</span><br><span class="line"><span class="keyword">import</span>(<span class="string">"./b"</span>).then(<span class="function">(<span class="params">&#123; bfn &#125;</span>) =&gt;</span> bfn()); <span class="comment">// a.js和b.js的chunk都有common.js模块</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>和第一点类似，如果异步的chunk入口被主chunk导入，直接把整个异步chunk导入到主chunk中。</li>
</ol>
<p>import函数在AST表示成Import类型，第一个参数就是模块名。即：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  Import(path) &#123;</span><br><span class="line">  	asyncDeps.add(path.parent.arguments[<span class="number">0</span>].value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="构建chunk"><a href="#构建chunk" class="headerlink" title="构建chunk"></a>构建chunk</h2><p> 对于模块而言，需要区分同步模块和异步模块。同步模块作为chunk的一部分加入，但是如果加入的父chunk包含，则不用再加入。而异步模块作为chunk的入口，需要重新实例化chunk，同理如果父chunk也已经包含了这个模块，我们也不再需要新chunk了。伪代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildChunk</span>(<span class="params">entryModule, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parentIncludeModule(entryModule, parent)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> chunk = <span class="keyword">new</span> Chunk(entryModule, parent);</span><br><span class="line">  addModuleToChunk(entryModule, chunk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addModuleToChunk</span>(<span class="params">module, chunk</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parentIncludeModule(<span class="built_in">module</span>, chunk)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> childChunk = isParentChunk(<span class="built_in">module</span>, chunk);</span><br><span class="line">  <span class="keyword">if</span> (childChunk) &#123;</span><br><span class="line">    childChunk.modules = childChunk.modules.filter(</span><br><span class="line">      (m) =&gt; m === <span class="built_in">module</span> || <span class="built_in">module</span>.syncDeps.includes(m)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  chunk.modules.push(<span class="built_in">module</span>);</span><br><span class="line">  <span class="built_in">module</span>.chunks.push(chunk); <span class="comment">// 一个模块可能属于多个chunk</span></span><br><span class="line">  <span class="built_in">module</span>.syncDeps.forEach(<span class="function">(<span class="params">syncDep</span>) =&gt;</span> addModuleToChunk(syncDep.module, chunk));</span><br><span class="line">  <span class="built_in">module</span>.asyncDeps.forEach(<span class="function">(<span class="params">asyncDep</span>) =&gt;</span> buildChunk(asyncDep.module, chunk));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>parentIncludeModule函数表示模块是否已经在其加入的chunk的父chunk中。</p>
<p>buildChunk函数新建了chunk，其中的判断符合原则二。addModuleToChunk函数将模块加入chunk中，第一个判断符合原则三。而随后的过滤是什么意思呢，我们来假设一个场景：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">"./a"</span>).then(<span class="function">(<span class="params">&#123; afn &#125;</span>) =&gt;</span> afn());</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> c = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; c &#125; <span class="keyword">from</span> <span class="string">"./c"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">"./a"</span>;</span><br></pre></td></tr></table></figure>
<p>index入口文件先同步导入了c文件，c文件中动态导入了a文件，随后入口文件再次同步导入了a文件。此时策略为了遵从原则xx，从而打包到其父chunk，这里应该是主chunk。但是在addModuleToChunk函数中我们先去处理同步模块，就会先去处理c模块，导致a模块还是成为了新chunk的入口模块。所以我们需要修正这种情况，当导入a模块时候，查找子chunk中是否有该模块，有的话从子chunk中剔除其本身以及依赖模块。因为同步的导入会永远发生在动态的导入之前，所以只需要多处理这种情况就可以了。</p>
<p>对于chunk而言，我们要区分主chunk和其他chunk，因为主chunk比其他chunk多出了运行时代码。但两者又需要解析模块的运行代码，所以抽离出父类的chunk。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chunk</span> </span>&#123;</span><br><span class="line">	buildOutput() &#123;&#125;</span><br><span class="line">	buildModules() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainChunk</span> </span>&#123;</span><br><span class="line">  buildOutput(total) &#123;</span><br><span class="line">    <span class="keyword">let</span> buffers = [];</span><br><span class="line">    <span class="keyword">if</span> (total &gt; <span class="number">1</span>) &#123;	<span class="comment">// 根据chunks数量决定模板</span></span><br><span class="line">      buffers.push(dynamicTemplate);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      buffers.push(syncTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> buffers;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从前一章得到的depTree对象构建出的chunks对象如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  MainChunk &#123;</span><br><span class="line">    id: <span class="number">0</span>,</span><br><span class="line">    parent: <span class="literal">null</span>,</span><br><span class="line">    entry: [Module],</span><br><span class="line">    modules: [ [Module], [Module], [Module], [Module] ],</span><br><span class="line">    filename: <span class="string">'bundle'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  Chunk &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    parent: [MainChunk],</span><br><span class="line">    entry: [Module],</span><br><span class="line">    modules: [ [Module] ],</span><br><span class="line">    filename: <span class="string">'1-bundle'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="拼接output-js"><a href="#拼接output-js" class="headerlink" title="拼接output.js"></a>拼接output.js</h2><p> 拼接output.js的过程和上章是差不多的，逻辑都已经封住在了chunk类内部。注意的是，修正后内部的modules数量可能为空，此时不再创建文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chunks = sources.chunks;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; chunks.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> chunk = chunks[i];</span><br><span class="line">    <span class="keyword">if</span> (empty(chunk.modules)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> buffers = chunk.buildOutput(chunks.length);</span><br><span class="line">    writeFile(chunk.filename, buffers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源代码可以看<a href="https://github.com/ccanister/fake-webpack#fake-webpack" target="_blank" rel="noopener">这里</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/29/动态表单/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/29/动态表单/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-29T09:57:04+08:00">
                2020-09-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="动态表单"><a href="#动态表单" class="headerlink" title="动态表单"></a>动态表单</h1><p>后台项目中一般往往都是增删改查，增和改操作都是表单操作，查一般是列表页或者详情页。其实Angular的表单支持算是蛮好的，双向绑定的机制可以在视图数据改变的时候，验证或者和其他表单项联动等操作。但是业务逻辑大部分是相似的，往往代码都是重复的，造成了复制和粘贴。所以动态表单在后台地位还是很大的。</p>
<!-- readMore -->
<h2 id="简单版的动态表单"><a href="#简单版的动态表单" class="headerlink" title="简单版的动态表单"></a>简单版的动态表单</h2><p>动态表单无非就是根据业务对象的元数据创建动态表单，得益于Angular的双向绑定，数据的改变会影响ui，用户改变ui的同时也会反向影响数据，所以只需要根据模型的类型渲染组件即可。</p>
<p>最简单的方法是在模板中使用<code>ngSwitch</code>组件判断类型。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-container</span> *<span class="attr">ngSwitch</span>=<span class="string">"field.type"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> *<span class="attr">ngSwitchCase</span>=<span class="string">"string"</span> [<span class="attr">formControl</span>]=<span class="string">"field.control"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> *<span class="attr">ngSwitchCase</span>=<span class="string">"textarea"</span> [<span class="attr">formControl</span>]=<span class="string">"field.control"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngSwitchDefault</span> [<span class="attr">ngComponentOutletInjector</span>]=<span class="string">"injector [ngComponentOutlet]="</span><span class="attr">field.editor</span>"&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后一种情况是用户自定义的组件。</p>
<p>这种表单很简单，也可以用，但是有几个缺点：</p>
<ol>
<li>没有合适的DSL语言去描述模型</li>
<li>模板逻辑过重，一般不提倡把逻辑写在模板里，而是抽到服务中。此外模板有些信息是重复的，应该抽离出来。</li>
<li>自定义组件可能只想传入templateRef类型，而不是引入component。</li>
<li>无法做到表单联动。</li>
</ol>
<h2 id="JSON-Schema"><a href="#JSON-Schema" class="headerlink" title="JSON Schema"></a>JSON Schema</h2><p>业内描述动态表单模型往往都会用JSON Schema，它可以规范数据，描述JSON数据所包含的字段、以及字段值的类型，以及依赖关系等。我们以账号密码的表单举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line">  <span class="string">"properties"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: &#123;</span><br><span class="line">    	<span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">    	<span class="string">"maxLength"</span>: <span class="number">11</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"password"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">      <span class="string">"pattern"</span>: <span class="string">"^[A-Z0-9]&#123;9&#125;$"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"email"</span>: &#123;</span><br><span class="line">    	<span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">    	<span class="string">"format"</span>: <span class="string">"email"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"required"</span>: [ <span class="string">"name"</span>, <span class="string">"password"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上我们可以看出要JSON Schmea可以包含数据的的类型、最大长度和正则等验证，如果是object类型还要指名包含的字段等等，非常适合描述表单。有了JSON Schema之后，我们该如何判断给定的数据是否符合其规范呢？比较流行的的库有ajv，他可以用来校验且性能不错。</p>
<p>不仅如此，我们还可以对JSON Schema一些字段做特殊处理，比如说maxLength直接作为输入框的maxLength属性，防止用户输入过长；multipleOf当作数字输入框的步长等等。</p>
<p>我们也需要自定义属性，如组件的大小、class等等，我们都统一定义在ui字段，防止字段太多破坏之前结构。</p>
<p>有了DSL语言，我们接着需要抽离出视图的逻辑，视图往往离不开model层，所以我们先来创建model层。</p>
<h2 id="model"><a href="#model" class="headerlink" title="model"></a>model</h2><h3 id="数据流动"><a href="#数据流动" class="headerlink" title="数据流动"></a>数据流动</h3><p>整个表单数据从根节点向子节点单向流动。表单可以看作组合模式的体现。组合模式是组合多个对象形成树形结构以表示具有“整体-部分”关系的层次结构。表单里有几种项：表单对象、表单数组和表单项。表单项可以独立出现，也可以被包裹到表单数组或者表单对象中，还可以和表单数组一起组成表单对象。表单数组一般往往由表单对象或者表单项组成。可以看出表单数组和表单对象都是容器，而表单项则是叶子节点。通常根节点往往是表单对象，从而形成树形结构。</p>
<p>当对表单设置值的时候，递归地先设置表单项的值和校验是否有效，然后容器会去收集子表单项的值计算出值和校验。伪代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setValue</span>(<span class="params">values: any</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> FormGroup) &#123;</span><br><span class="line">    <span class="keyword">this</span>.children.forEach(<span class="function">(<span class="params">child, name</span>) =&gt;</span> child.setValue(values[name]));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> FormArray) &#123;</span><br><span class="line">     <span class="keyword">this</span>.children.forEach(<span class="function">(<span class="params">child, index</span>) =&gt;</span> child.setValue(values[index]));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.updateValue();</span><br><span class="line">  <span class="keyword">this</span>.runValidators();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是对表单根节点设置值的情况，如果对表单某一项设置值的时候，当设置值完毕的时候，需要通知父节点更新值，直到冒泡到根节点。</p>
<p>因此无论是对表单根节点设置值还是对某一项设置值，数据的流动都是从叶子节点开始冒泡向上直到根节点。</p>
<h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><p>表单校验一般分成两种，同步校验和异步校验。同步校验往往是必填项、最大长度等，异步校验则是判断名字重复等，和后台交互较多。所以优先执行同步校验逻辑，如果有返回错误信息就不再执行异步校验。无论是哪种校验，都应该从左往右执行校验逻辑，所以取得校验器后就将他们组合方便之后的执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">composeSync</span>(<span class="params">validators</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="params">value</span> =&gt;</span> mergeErrors(validators.map(<span class="function"><span class="params">validator</span> =&gt;</span> validator(value)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">composeAsync</span>(<span class="params">validators</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="params">value</span> =&gt;</span> forkJoin(validators).pipe(map(<span class="function"><span class="params">validators</span> =&gt;</span> mergeErrors(validators.map(<span class="function"><span class="params">validator</span> =&gt;</span> validator(value))))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runValidators</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cancelAsyncSubscription();</span><br><span class="line">    <span class="keyword">const</span> errors = <span class="keyword">this</span>.syncValidators ? <span class="keyword">this</span>.syncValidators(value) : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!errors &amp;&amp; <span class="keyword">this</span>.asyncValidators) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subscription = <span class="keyword">this</span>.asyncValidators.subscribe(<span class="function"><span class="params">errors</span> =&gt;</span> <span class="keyword">this</span>.setErrors(errors))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果上次异步校验的结果未返回，将会取消执行。此外，这里用了forkJoin操作符，因为一般都是和后台交互，都是一次性的流，如果这个流的数据是长期流通的，会导致一直阻塞在这里。</p>
<p>除此之外，我们在执行自定义校验之前，需要先执行schema的验证逻辑，防止执行不必要的自定义校验。ajv的错误格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  <span class="string">"keyword"</span>: <span class="string">"required"</span>,</span><br><span class="line">  <span class="string">"dataPath"</span>: <span class="string">".password"</span>,</span><br><span class="line">  <span class="string">"schemaPath"</span>: <span class="string">"#/required"</span>,</span><br><span class="line">  <span class="string">"params"</span>: &#123;<span class="string">"missingProperty"</span>:<span class="string">"password"</span>&#125;,</span><br><span class="line">  <span class="string">"message"</span>:<span class="string">"必填项"</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>此时表单根节点和password单个表单项的校验结果是相同的，一般很少会对表单对象或者表单数组设置校验规则，所以在对表单项设置数据的时候，尽量不去触发父节点的校验。为了让父节点的错误信息和子节点的错误信息是一样的，我们把子节点的错误信息冒泡传播，向上设置。这样判断表单是否有错误的，只要看它的error是否有值即可，而不用收集子节点状态。</p>
<p>其实Angular内部已经实现了FormGroup、FormArray和FormControl表单model。但是在这里我们并不会直接用它：</p>
<h2 id="视图抽离"><a href="#视图抽离" class="headerlink" title="视图抽离"></a>视图抽离</h2><p>我们先来提取重复的视图逻辑。</p>
<h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><p>一个完整的表单应该包含以下元素：</p>
<p><img src="/2020/09/29/动态表单/zhaorenjie/Documents/blog/source/_posts/动态表单/表单项.png" alt="表单项"></p>
<center>表单项</center>

<ul>
<li>是否必填的标志</li>
<li>表单标题</li>
<li>帮助信息</li>
<li>文字框的提示消息</li>
<li>错误消息</li>
<li>更多描述</li>
</ul>
<p>因此这里只有输入框组件是不一样的，可以当作插槽。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"label"</span> [<span class="attr">attr.for</span>]=<span class="string">"id"</span> [<span class="attr">class.required</span>]=<span class="string">"required"</span>&gt;</span></span><br><span class="line">      &#123;&#123; title &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">tooltip</span> *<span class="attr">ngIf</span>=<span class="string">"optionalHelp"</span> [<span class="attr">title</span>]=<span class="string">"optionalHelp"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">type</span>=<span class="string">"question-circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tooltip</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"control"</span> [<span class="attr">class.has-error</span>]=<span class="string">"showError"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ng-content</span>&gt;</span><span class="tag">&lt;/<span class="name">ng-content</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extra</span> *<span class="attr">ngIf</span>=<span class="string">"description"</span> [<span class="attr">innerHTML</span>]=<span class="string">"description"</span>&gt;</span><span class="tag">&lt;/<span class="name">extra</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">explain</span> *<span class="attr">ngIf</span>=<span class="string">"showError"</span>&gt;</span>&#123;&#123;error&#125;&#125;<span class="tag">&lt;/<span class="name">explain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样每个表单组件都可以包裹在其中，包括自定义组件，而不用手动得写重复代码。</p>
<h3 id="其他数据"><a href="#其他数据" class="headerlink" title="其他数据"></a>其他数据</h3><p>其他数据范围比较广，常见的有：</p>
<ul>
<li>数据源：包括远程的，用来渲染select组件这种</li>
<li>ui相关：比如class、size等等</li>
<li>验证器等</li>
<li>默认值</li>
</ul>
<h3 id="视图隔离"><a href="#视图隔离" class="headerlink" title="视图隔离"></a>视图隔离</h3><p> 动态的组件，因为要从之前的模板剥离出来，所以不能在用<code>ngComponentOutlet</code>指令了。其实内置组件和自定义组件在Angular看来没有区别，都是要动态创建的组件。所以我们可以用keyvalue形式定义有哪些组件，再传入key取得渲染的组件，最后用<code>ViewContainerRef</code>视图容器动态创建。例如我们自定义了输入框的组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义组件</span></span><br><span class="line">widgets.set(<span class="string">"input"</span>, CustomInputCompoennt);</span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="keyword">const</span> componentClass = widgets.get(<span class="string">"input"</span>);</span><br><span class="line"><span class="keyword">const</span> componentFactory = resolver.resolveComponentFactory&lt;Widget&lt;FormProperty&gt;&gt;(componentClass);</span><br><span class="line"> container.createComponent(componentFactory);</span><br></pre></td></tr></table></figure>
<p>用这种形式的好处就不必再为自定义组件编写多的代码，统一两种风格。</p>
<p>一般会内置几个表单项组件，例如输入框和单选框等等，但是也避免不了自定义表单项组件。Angular动态创建的视图有两种：template和component。template需要拿到定义好的templateRef，所以我们可以规定它必须写在表单内部，通过指令获取即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dynamic-form&gt;</span><br><span class="line">	&lt;ng-template sf-row=<span class="string">"type"</span>&gt;</span><br><span class="line">		...</span><br><span class="line">	&lt;<span class="regexp">/ng-template&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dynamic-form&gt;</span><br><span class="line"><span class="comment">// js</span></span><br><span class="line">@Directive(&#123;</span><br><span class="line">  selector: <span class="string">'[sf-row]'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SFTemplateDirective</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  @Input(<span class="string">'sf-row'</span>) path: string;</span><br><span class="line">  private _renders = <span class="keyword">new</span> <span class="built_in">Map</span>&lt;string, TemplateRef&lt;<span class="keyword">void</span>&gt;&gt;();</span><br><span class="line">  <span class="keyword">constructor</span>(private templateRef: TemplateRef&lt;void&gt;) &#123;&#125;</span><br><span class="line">  ngOnInit(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._renders.set(<span class="keyword">this</span>.path, <span class="keyword">this</span>.templateRef);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写在表单内部还有一个好处，就是可以把指令的_renders放到表单组件去，在构造器中注入表单组件，并加上@Host修饰器，表示强依赖。</p>
<p>其次是</p>
<h2 id="表单联动"><a href="#表单联动" class="headerlink" title="表单联动"></a>表单联动</h2><p>某个表单项的数据变化时候，往往会影响其他表单项，比如数据源或者是否显示。举个例子，现在有两种登录方式，一种是账号密码登陆，还一种是手机验证码登陆。我们在勾选不同的登录方式时候，呈现的界面也是不同的。通常我们会在模板中指明登陆方式，利用if/else语句判断：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-container</span> *<span class="attr">ngIf</span>=<span class="string">"type==='password'"</span>&gt;</span></span><br><span class="line">	....</span><br><span class="line"><span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ng-container</span> *<span class="attr">ngIf</span>=<span class="string">"type==='mobile'"</span>&gt;</span></span><br><span class="line">	....</span><br><span class="line"><span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样做是可行的，但是如果现在又多了一个变量判断登录方式怎么办？比如说他勾选了男孩的性别，也能显示密码登陆。于是我们又得在模版中多一个变量判断，导致模板变得很臃肿。一般提倡逻辑写在组件或者服务中，模板的判断太多让人捉摸不透。</p>
<p>所以我们将会这种判断逻辑抽取出来。我们需要组合多种变量，在模板中可以直接将逻辑写死，但是抽离出来后，我们需要在每个变量变化后回调判断，就像这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> [(<span class="attr">ngModel</span>)]=<span class="string">"type"</span> (<span class="attr">ngModelChange</span>)=<span class="string">"check()"</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> [(<span class="attr">ngModel</span>)]=<span class="string">"sex"</span> (<span class="attr">ngModelChange</span>)=<span class="string">"check()"</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ng-container</span> *<span class="attr">ngIf</span>=<span class="string">"mobile.visible"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> [(<span class="attr">ngModel</span>)]=<span class="string">"mobile.value"</span>/ &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">function check() &#123;</span><br><span class="line">	mobile.visible = this.type === "password" || sex === "man"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在模板中需要动态显示的表单项，用visible变量标示是否显示。即在表单中，动态显示的表单项model是永远存在的，变化的是ui。这个判断的逻辑只能在该表单中使用。有两个原因，第一个是动态判断的DSL不够通用，完全是强逻辑，最好是JSON字段就可以表示，第二个是需要在模板加上ngModelChange的回调，造成耦合太强。</p>
<p>针对第一个问题，我们可以模仿校验器的使用。因为我们这个动态都是由着表单项的数据变化而变化，所以可以自定义DSL:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visibleIf: &#123; <span class="attr">type</span>: <span class="function"><span class="params">value</span> =&gt;</span> value === <span class="string">"password"</span> &#125;</span><br></pre></td></tr></table></figure>
<p>type键表示是哪个表单项，当表单项符合值的函数调用时就显示。再精简一点，可以直接去掉函数，直接用数组表达<code>[&quot;password&quot;]</code>，因为可能会有多个值符合显示。再进一层，我们可以表达与和或的关系：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visibleIf: &#123; <span class="attr">type</span>: &#123;<span class="attr">value</span>: [<span class="string">"password"</span>], <span class="attr">rel</span>: <span class="string">"and"</span>&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>这样的表达能覆盖大部分的场景。</p>
<p>第二个问题，我们可以改成流的合并。之前的表达都是命令式，比如选择完性别后我们需要主动监听ngModel回调，最好是选择完后数据能够主动推给我们，而不是被动去监听。这时候rxjs流就派上用场了，每个表单项内部都有<code>valueChanges</code>变量，我们订阅后，当表单值改变时候，会推送数据过来。所以根据上述的demo我们可以这样去写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> paths = <span class="built_in">Object</span>.keys(visibleIf);</span><br><span class="line"><span class="keyword">const</span> binds = paths.map(<span class="function"><span class="params">path</span> =&gt;</span> <span class="keyword">this</span>.searchProperty(path).valueChange.pipe(map(<span class="function"><span class="params">value</span> =&gt;</span> visibleIf[path](value)))</span><br><span class="line">combineLatest(binds).pipe(map(<span class="function"><span class="params">values</span> =&gt;</span> values.indexOf(<span class="literal">true</span>) !== <span class="number">-1</span>),distinctUntilChanged()).subscribe(<span class="function"><span class="params">visible</span> =&gt;</span> <span class="keyword">this</span>.visible = visible);</span><br></pre></td></tr></table></figure>
<p>上述的代码表现了或的关系，可以自行合并与和或的关系。rxjs流的出现，使得我们不再监听ngModel就可以拿到值，使得联动具有一定的通用行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是对动态表单的思考，更多参考了<code>delon/forms</code>和<code>ui-model</code>两个项目，通过他们的相同点和不同点分析。一般实现了表单联动后，就能解决后台大部分场景了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/23/webpack打包优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/23/webpack打包优化/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-23T09:56:11+08:00">
                2020-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="webpack打包优化"><a href="#webpack打包优化" class="headerlink" title="webpack打包优化"></a>webpack打包优化</h1><p>最近发现打包后的js文件日益增大，想着之前有看过webpack的优化文章，能不能再次用上。可惜Angular在v6的时候不再支持自定义配置文件，所以能做的事是有限的。</p>
<h2 id="查看文件体积分布"><a href="#查看文件体积分布" class="headerlink" title="查看文件体积分布"></a>查看文件体积分布</h2><p>webpack有多种方法能查看打包后的体积分布，比较直观化的是<code>webpack-bundle-analyzer</code>插件，能图形化的显示打包后的文件大小以及由哪些模块组成。使用方法比较简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-bundle-analyzer</span><br><span class="line">ng build --prod --stats-json &amp;&amp; webpack-bundle-analyzer dist/stats.json</span><br></pre></td></tr></table></figure>
<p>项目打包后的分布如下：</p>
<p><img src="/2020/09/23/webpack打包优化/zhaorenjie/Desktop/optimize/webpack-bundle-analyzer.png" alt="webpack-bundle-analyzer"></p>
<p>可以看到比较大的文件是main文件和scripts文件，这两个在首页时都会加载，所以尤其需要优化。其他的文件都是懒加载的模块，但都无法分析内部模块，所以还需要借助另一个插件<code>source-map-explorer</code>，它可以解析每个文件的模块分布、大小和占比等，使用方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g source-map-explorer </span><br><span class="line">ng build --prod --source-map</span><br><span class="line">source-map-explorer dist<span class="comment">/*.js</span></span><br></pre></td></tr></table></figure>
<p>最后一步需要指定要分析的文件，不能全部一口气分析完。这里涉及到项目内部模块，就不放图了。</p>
<h2 id="体积优化"><a href="#体积优化" class="headerlink" title="体积优化"></a>体积优化</h2><ol>
<li><p>scripts的优化：scripts会打包没有直接导入到项目中，但第三方库又依赖的包，往往写在angular.json文件中的assets里。比如说ng-alian脚手架的动态表单，他依赖了ajv库验证schema是否正确，但我们导入模块的时候只会导入动态表单的库，不会把ajv也引入。因为我们并不需要直接和ajv打交道，而是动态表单引用了它。如果我们不在assets里引入，项目就会报找不到依赖的错误。</p>
<p>所以scripts的库往往都是第三方库，可以通过CDN引入。这里有个权衡，还是ajv库它的大小只有二十几kb，真的有必要通过CDN去引入吗？webpack4拆分公共代码中的默认配置有一项就是公共的chunk需要大于30kb，才会拆分出新的chunk。因为尽管缩小了原先文件的大小，但是多了网络请求，有时候并不一定值得，尤其同一域名下并发请求数是由限制的。所以我们也可以规定只有30kb的文件才通过CDN引入。优化后的scripts文件大小：<img src="/2020/09/23/webpack打包优化/zhaorenjie/Desktop/optimize/采用min后的script.png" alt="采用min后的script"></p>
</li>
<li><p>assets目录内的导入改成http请求：assets目录属于静态目录，放置css、json等静态文件。但是如果我们直接用es规范去导入json等文件，就会把它打包进来。其实更好的方式应是http请求文件，因为都是本地文件，没有消耗。</p>
</li>
<li><p>按需导入：这个也比较常见，比如现在在用的date-fns库，没有注意使用习惯，就直接<code>import {format} from &quot;date-fns&quot;</code>，导致把整个库打包进来。</p>
<p><img src="/2020/09/23/webpack打包优化/zhaorenjie/Desktop/optimize/引入了全部date-fns.png" alt="引入了全部date-fns"></p>
<p>所以应该使用<code>import format from &quot;date-fns/format&quot;</code>，这样打包的时候只会把format打包进来。</p>
<p><img src="/2020/09/23/webpack打包优化/zhaorenjie/Desktop/optimize/按需引入的date-fns.png" alt="按需引入的date-fns"></p>
<p>不过大部分的包基本都是需要全部引入。</p>
<p>如果项目这样的导入方式较多，改起来比较麻烦，可以考虑写个ts的插件，碰到这种格式的导入重新定义ast。</p>
</li>
<li><p>避免库导入却不用：因为项目之前有后端接手过，他们尝试了一些第三方库，却忘记删除，导致引入了无用的包。可以tslint.json中添加<code>no-unused-declaration</code>的规则。</p>
</li>
<li><p>懒加载模块，这点在项目初期就已做到，暂且不表。</p>
</li>
<li><p>引入更合适的包：有时候用到的第三方库只是需要部分功能，却又不支持按需引入，导致把整个库都打包进来，造成了冗余。比如之前在用的解析yaml的js-yaml，虽然整个包体积也才40kb，但是我只需要safeLoad方法，可能只有一半的体积。于是转投<code>yamljs</code>库，体积缩小了。</p>
</li>
<li><p>主模块不引入懒加载模块</p>
</li>
<li><p>摇树优化：Angular在aot模式下会去将ts编译成es代码，并没有用到uglify的摇树优化功能。</p>
</li>
<li><p>抽取公共代码：同样，这个也是Angular内部插件完成，不过在代码组织上，文档上也推荐了如果有多个module需要引入相同的组件，要抽到shared module，否则报错。</p>
<p>不过我们看下webpack默认的splitChunks配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'async'</span>,</span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">      automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">      name: <span class="literal">true</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          priority: <span class="number">-10</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>chunks有三个选项：async表示只从异步加载的模块拆分，initial只从入口模块拆分，all包括两者。如果选了async，那么即使入口文件引入了第三方库，也不会拆分出去。也就是说当我们不改配置，是无法拆分出第三方库的。</li>
<li>minChunks：默认是1。当模块被不同chunks引用的次数大于等于这个配置值时，才会被抽离出去。假设我们把这个值改成2，会发现第三方库还是不会被分离出去。</li>
<li>cacheGroups：自定义拆分规则，default就是入口打包的规则。test可以匹配资源的绝对路径或名称，priority表示规则的优先级，默认配置里给vendors的优先级较高，如果比default低的话，第三方库被引用两次，就会被打包到业务chunk。</li>
<li>minSize：拆分出去的chunk大小必须大于这个值，单位是字节。</li>
<li>maxInitialRequests：表示允许入口并行加载的最大请求数，也可以理解是入口文件拆分出的最多文件数量，防止拆分出太多模块导致请求数量过多而得不偿失。</li>
</ul>
</li>
</ol>
<ul>
<li>maxAsyncRequests：类似maxInitialRequests，用来限制异步模块内部的并行最大请求数的。</li>
</ul>
<p>我们来看下具体案例，假设现在有这样的目录结构</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   &gt; |--src/</span><br><span class="line">   &gt; |   |--a.js</span><br><span class="line">   &gt; |   |--b.js</span><br><span class="line">   &gt; |		|--c.js</span><br><span class="line">   &gt; |   |--index.js</span><br><span class="line">   &gt; |--assets/</span><br><span class="line">   &gt; |		|--jquery.js</span><br><span class="line">   &gt; |--package.json</span><br><span class="line">   &gt; |--webpack.config.js</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>代码逻辑比较简单，index模块引入了a模块和b模块，b模块引入了c模块和underscore库，a模块也引入了c模块和underscore模块，c模块是没有依赖的独立模块。</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">"./a.js"</span>;</span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">"./b.js"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"index----------"</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./c.js"</span>);</span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">"underscore"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a-------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = fn();</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./c.js"</span>);</span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">"underscore"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"b-------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = fn();</span><br><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"c-------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = fn();</span><br></pre></td></tr></table></figure>
<p>我们对配置不做任何改动，当然入口文件要设置成index.js，打包结果发现全部文件都在index.js文件中，这是因为我们没有设置chunks选项，只会去查找异步加载的chunk。我们放开chunks的控制，改成all，发现打包出了vendors~main文件，里面只有underscore库代码。尽管c文件被引用了两次，但是属于同一个chunk，所以被分离出来。</p>
<p>我们把入口文件改造成多入口：</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123; <span class="attr">index</span>: <span class="string">"./multi/index.js"</span>, <span class="attr">a</span>: <span class="string">"./multi/a.js"</span> &#125;,</span><br></pre></td></tr></table></figure>
<p>这样a和c文件都被不同的chunk引用了，我们再来看打包结果，发现还是没有被分离出来。这是因为minSize设置的值较大，webpack认为没有必要分离出来，我们把它的值改小点，改成30，打包后发现多了<code>a~main</code>的文件，里面有a和c文件打包结果，说明分离成功。</p>
<p>接下来我们想要自定义拆分规则，把某些业务代码再分离出来，在src目录下创建locallib文件:</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> query;</span><br></pre></td></tr></table></figure>
<p>然后在a和b模块引用这个模块，需要在webpack中配置：</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cacheGroups: &#123;</span><br><span class="line">  locallib: &#123;  <span class="comment">//拆分指定文件</span></span><br><span class="line">    test: <span class="regexp">/(src\/locallib\.js)$/</span>,</span><br><span class="line">    name: <span class="string">'locallib'</span>,</span><br><span class="line">    chunks: <span class="string">'initial'</span>,</span><br><span class="line">    <span class="comment">// priority： -30</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打包后发现多了locallib的文件，说明分离成功。如果我们添加priority规则并比default设置的小，发现它被打进了<code>a~main</code>文件，这是因为locallib模块也符合default的规则，优先级又较高，所以被拆分到其规则组。神奇的是此时<code>a~main</code>文件消失了，这就是受到了maxInitialRequests影响。这时候index.js入口文件拆分出来的模块有index.js（入口文件也算）、a~index（a模块和index模块公共代码）、vendors~main（第三方库）和locallib（特定业务模块）共4个模块，大于了默认配置3，所以只能抽出3个模块。而为什么不是a~index被拆分出来，是因为它的体积最小决定的。可以修改一下这个配置成4，就可以成功打包。</p>
<p>   所以maxInitialRequests有几点注意：</p>
<ol>
<li>入口文件本身算一个请求。</li>
<li>动态加载得模块不算。</li>
<li>通过runtimeChunk拆分出的runtime不算在内。</li>
<li>只算js文件的请求，css不算在内</li>
<li>如果同时有两个模块满足cacheGroup的规则要进行拆分，但是maxInitialRequests的值只能允许再拆分一个模块，那尺寸更大的模块会被拆分出来。</li>
</ol>
<h2 id="编译速度优化"><a href="#编译速度优化" class="headerlink" title="编译速度优化"></a>编译速度优化</h2><p>这方面基本上无能为力，全靠机器性能了，说下自己在网上看到的。</p>
<ol>
<li>noParse参数：可以不解析第三方库的依赖</li>
<li>DLL链接：把第三方库提前编译好，在项目编译的时候动态链接，就可以不用编译第三方库，提高速度。</li>
<li>happypack插件多线程打包。</li>
<li>cacheLoader缓存。</li>
<li>resolve参数：modules —- 指定第三方库的目录，提高查找速度；extensions —- 常用后缀放在前面，提高查找文件速度。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/21/websocket心跳重连/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/21/websocket心跳重连/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-21T09:57:39+08:00">
                2020-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="websocket心跳重连"><a href="#websocket心跳重连" class="headerlink" title="websocket心跳重连"></a>websocket心跳重连</h1><p>websocket在一次握手后保持长连接，但是在传输过程中会有各种意外导致连接断开，为了保持连接的稳定性，需要发送定期的心跳包，如果心跳没有回应，说明连接已断开重新连接。</p>
<p>最常见的就是长时间的没有发送和接收数据，浏览器有节能策略会主动断开连接，目前测试数据来看chrome是120s到180s左右。除此外浏览器也会遇到断网和锁屏的情况。断网时候服务端发送的数据无法收到，浏览器会在send方法后才发现断网情况再关闭连接，实际测试中断网50s后左右，浏览器调用send方法后会立即关闭连接，而断网50s内，并不会立即关闭，会以50s重新一个周期检测有无重新联网，如果仍然没有网络，关闭连接。这么做的原因可能是为了防止网络抖动。锁屏时候不再执行js代码，所以也会导致长时间的没有数据发送或者接受而关闭连接。</p>
<!-- readMore -->
<p>如果服务端发生意外如报错等导致连接的断开，前端可以在onclose方法中收到不是正常关闭的事件，此时也应该触发重连。</p>
<p>所以我们需要设定心跳机制维持websocket连接，前端在定时向服务端发送ping消息，服务端为了检测网络是否正常和自己仍在工作，也需要回复pong信息。</p>
<h2 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h2><p>websocket对象暴露了一些事件绑定，如果我们需要重连，应该在onerror和onclose事件上绑定重连方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">	 reconnect();</span><br><span class="line">&#125;</span><br><span class="line">ws.onerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  reconnect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，关闭事件的event.code是1006时候意味着浏览器期望收到状态码时连接非正常关闭，就是服务端没有发送关闭帧，这时候触发重连机制。当然，也可以不判断这个状态码，因为不能保证意外的时候就是1006，任何触发关闭事件都应该重连。</p>
<p>此时真正的websocket对象被封装了起来，再对外暴露我们封装的实例的事件。如果想要直接关闭websocket连接，不再去重试的话，应该有个标志位，用户将它值为true后，就不再尝试重连。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WebscoketHeadrtBeat.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.ws.close = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.close();	<span class="comment">// 暴露默认时间</span></span><br><span class="line">		<span class="keyword">this</span>.reconnect();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">WebscoketHeadrtBeat.prototype.close = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.forbidReconnect = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">this</span>.ws.close();</span><br><span class="line">&#125;</span><br><span class="line">WebscoketHeadrtBeat.prototype.reconnect = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.forbidReconnect) <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于心跳重连，我们只需要定时发送心跳，如果后端没有及时响应，就去触发重连。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> heartCheck = &#123;</span><br><span class="line">	pingTimeout = <span class="number">15000</span>,</span><br><span class="line">	pongTimeout = <span class="number">10000</span>,</span><br><span class="line">	pingTimeoutId = <span class="literal">null</span>,</span><br><span class="line">	pongTimeout = <span class="literal">null</span>,</span><br><span class="line">	start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.pingTimeoutId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				ws.send(<span class="string">"ping"</span>);</span><br><span class="line">				<span class="keyword">this</span>.pongTimeoutId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">					ws.close();	<span class="comment">// 由close方法触发重连</span></span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;, <span class="keyword">this</span>.pingTimeout); </span><br><span class="line">	&#125;</span><br><span class="line">	reset = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(<span class="keyword">this</span>.pingTimeoutId);</span><br><span class="line">    clearTimeout(<span class="keyword">this</span>.pongTimeoutId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>浏览器收到信息后就会重置定时器，一定时间后发送ping信息，后端应该及时返回消息，保证连接的正常。如果后端没有在规定时间内返回消息，说明当前连接的不稳定，触发关闭连接且重连。</p>
<p>如果是断网情况，发送ping消息后，浏览器发现没有网络，如果距断网已经超过50s，就会直接关闭连接；否则再等待50s，防止网络抖动，再去关闭。所以pingTimeout和pongTimeout的事件最好都不要超过50s，不然会重复触发关闭和重连。</p>
<p>除此之外，重连的次数一般也是有限制的，一般不会无限重连，导致无用的连接。可以在<code>reconnect</code>方法里计数，防止重连次数过多。</p>
<h2 id="服务端心跳"><a href="#服务端心跳" class="headerlink" title="服务端心跳"></a>服务端心跳</h2><p>像我们项目主要都是后端传输数据，除了让浏览器主动发送心跳包，也可以让服务端定时发送数据。比如服务端每隔10s发送消息，如果浏览器在10s内都没有收到信息，即可关闭连接。这种方式缺点就是需要前后端需要约定好时间，不能灵活调节时间，代码相对比较死。第一种方式，服务端监听接受数据事件即可，收到数据时候立即返回消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scoket.on(<span class="string">"data"</span>, (data) =&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span> (data === <span class="string">"ping"</span>) &#123;</span><br><span class="line">		socket.write(<span class="string">"pong"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="慢重连"><a href="#慢重连" class="headerlink" title="慢重连"></a>慢重连</h2><p>假设现在服务端因为出错导致浏览器重连，重连之后服务端仍然出错，就一直在重复重连。这对带宽影响较大，我们可以设置延迟时间再去重连。</p>
<p>除了这种情况，极端情况就是断网。此时的网络不是很稳定，监听online和offline事件可能不是很准确。比如online事件触发后，进行重连后，又断网了，所以此时判断不准确。而我们短时间内的重连尝试也是没有效果的。可以模仿TCP的慢开始，在没有达到阈值的时候，重连的延迟时间是每次乘以2，达到阈值之后不再变化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> THRESHOLD = <span class="number">120</span>；	<span class="comment">// 阈值时2分钟</span></span><br><span class="line">reconnect() &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.forbidReconnect || repeatLimit &lt;= <span class="keyword">this</span>.options.repeat) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> reconnectTimeout = reconnectTimeout &lt; THRESHOLD ? reconnectTimeout * <span class="number">2</span> : THRESHOLD;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.createWebSocket();</span><br><span class="line">  &#125;, reconnectTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就可以推迟重连的时间，这样用户可能在恢复网络后之前重连成功。恢复网络后（触发online事件），应该立即重置延迟时间，再去重连达到快速恢复的效果。</p>
<p>除此外断网后，断网后一段时间延迟重试时长变得较大后，用户离开电脑或者将电脑锁屏后，浏览器并不会执行js，所以即使恢复网络了，也无法触发online事件，延迟的重试时长仍然是很大的。针对这种情况，可以设置一个定时器，当此次和上次的执行时间间隔较大时候，可认定电脑休眠，于是重置延迟时间。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://cloud.tencent.com/developer/article/1341903" target="_blank" rel="noopener">WebSocket系列之如何建立和维护可靠的连接</a></li>
<li>[<a href="https://www.cnblogs.com/1wen/p/5808276.html" target="_blank" rel="noopener">初探和实现websocket心跳重连</a>]</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/18/用node写个webscoket服务器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/18/用node写个webscoket服务器/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-18T14:05:21+08:00">
                2020-09-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="用node写个webscoket服务器"><a href="#用node写个webscoket服务器" class="headerlink" title="用node写个webscoket服务器"></a>用node写个webscoket服务器</h1><p>websocket这两年已经不是新鲜的事了，服务器可以通过它主动推送数据到客户端，替代了长轮询。最常见的就是webpack-dev-serve，当按下保存键时候浏览器会自动刷新。其中原理也是通过webscoket通知浏览器原地刷新。热更新也是基于此，会把增量更新传递给浏览器。</p>
<p>websocket服务器是TCP的应用程序，基于HTTP/1.1协议握手。利用http协议握手的话，能让webscoket服务器运行在80和443端口，一般客户端都是访问这两个端口；其次可以重用并扩展 HTTP 的Upgrade流，添加自定义首部完成协商。</p>
<!-- readMore -->
<h2 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h2><p>因为基于http协议握手，所以我们先创建一个http服务器，node内置的模块能方便得创建。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.readFile(path.join(__dirname, <span class="string">"index.html"</span>), (err, data) =&gt; &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">"Content-type"</span>: <span class="string">"text/html"</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">      res.end(<span class="string">"500"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.end(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(port, () =&gt;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server running at http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其中index.html实例化了websocket对象，来和我们的服务端通讯。</p>
<p>再来看客户端的请求头</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; GET /chat HTTP/1.1</span><br><span class="line">&gt; Host: example.com:8000</span><br><span class="line">&gt; Upgrade: websocket</span><br><span class="line">&gt; Connection: Upgrade</span><br><span class="line">&gt; Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">&gt; Sec-WebSocket-Version: 13</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<center>[取自MDN]</center>

<p>我们看下每个字段含义：</p>
<ul>
<li>Connection需要标识为Upgrade，表示客户端想要升级，同时Upgrade必须置为webscoket。最后一个Sec-WebSocket-Version表示webscoket版本，现在最新的版本就是13，之前的都应废弃。如果服务端无法理解收到的的websocket版本，则返回Sec-WebSocket-Version包含自己理解的版本。</li>
<li>Sec-WebSocket-Key是随机的字符串，服务器根据这个数据和<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>连接起来，再把结果用SHA-1编码，最后base64编码再转交给客户端。客户端做对比后发现是正确的就可以开始传输数据了。这个作用就是保证服务端是支持websocket协议，如果传给客户端的编码是不正确的，客户端将抛出错误。</li>
</ul>
<p>因此服务端返回的首部如下。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; HTTP/1.1 101 Switching Protocols</span><br><span class="line">&gt; Upgrade: websocket</span><br><span class="line">&gt; Connection: Upgrade</span><br><span class="line">&gt; Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>101响应码表示确认升级到websocket协议</li>
</ul>
<p>编码操作可以通过内置的crypto加密库解决：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAGIC_KEY = <span class="string">"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateAcceptValue</span>(<span class="params">secWsKey</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> crypto.createHash(<span class="string">"sha1"</span>)</span><br><span class="line">    .update(secWsKey + MAGIC_KEY, <span class="string">"utf8"</span>)</span><br><span class="line">    .digest(<span class="string">"base64"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而服务端除了编码操作外，还要判断upgrade首部是否是websocket，其他协议我们都不支持，如果收到的话直接返回400表示错误的请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server.on(<span class="string">"upgrade"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, socket</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (req.headers[<span class="string">"upgrade"</span>] !== <span class="string">"websocket"</span>) &#123;</span><br><span class="line">    socket.end(<span class="string">"HTTP/1.1 400 Bad Request"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 读取客户端提供的Sec-WebSocket-Key和生成编码</span></span><br><span class="line">  <span class="keyword">const</span> secWsKey = req.headers[<span class="string">"sec-websocket-key"</span>];</span><br><span class="line">  <span class="keyword">const</span> hash = generateAcceptValue(secWsKey);</span><br><span class="line">  <span class="comment">// 设置HTTP响应头</span></span><br><span class="line">  <span class="keyword">const</span> responseHeaders = [</span><br><span class="line">    <span class="string">"HTTP/1.1 101 Web Socket Protocol Handshake"</span>,</span><br><span class="line">    <span class="string">"Upgrade: WebSocket"</span>,</span><br><span class="line">    <span class="string">"Connection: Upgrade"</span>,</span><br><span class="line">    <span class="string">`Sec-WebSocket-Accept: <span class="subst">$&#123;hash&#125;</span>`</span>,</span><br><span class="line">  ];</span><br><span class="line">  <span class="comment">// 返回握手请求的响应信息</span></span><br><span class="line">  socket.write(responseHeaders.join(<span class="string">"\r\n"</span>) + <span class="string">"\r\n\r\n"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样握手就完成了，然后开始传输数据。</p>
<p>如果我们任意修改<code>MAGIC_KEY</code>的值，会发现浏览器抛出以下错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebSocket connection to <span class="string">'ws://localhost:8886/'</span> failed: <span class="built_in">Error</span> during WebSocket handshake: Incorrect <span class="string">'Sec-WebSocket-Accept'</span> header value</span><br></pre></td></tr></table></figure>
<h2 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h2><p>所有的传输协议都是通过数据帧来发送数据的，只要遵从了规范格式，浏览器解析后就能做出相应的动作。所以我们来看哈webscoket的数据帧格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<center>[取自MDN]</center>

<p>我们来结合具体的数据帧来解读，假设客户端现在向服务端发送了<code>我是大白</code>的数据，服务端收到的数据是这样的：</p>
<p><img src="/2020/09/18/用node写个webscoket服务器/zhaorenjie/Documents/blog/source/_posts/websocket/我是大白的数据帧.png" alt="我是大白的数据帧"></p>
<p>websocket的数据帧从81开始，灰色部分都是辅助信息，之后才是发送的数据，图片里已经显示了发送的数据。</p>
<ul>
<li><p>FIN表示该帧是否是发送数据的最后一个片段，如果我们发送的数据过长就会分成多个数据帧发送。</p>
</li>
<li><p>RSV1-3可以忽略，它们是用于扩展的。</p>
</li>
<li><p>opcode表示此次数据帧的格式：0x00表示是延续帧，此次发送的数据后面还有帧；0x01表示文本，用utf-8解码；0x02表示二进制流；0x03-0x07没有意义；0x08表示关闭；0x09是个心跳请求（ping）；0x10时心跳相应（pong），这两个操作前端暂时无法发送；0xa0后面的操作码暂时没有意义。</p>
</li>
<li><p>Mask标示是否数据帧是否进行掩码操作，往往客户端发送的数据都是有的，而服务端并没有。</p>
</li>
<li><p>Payload length标示数据长度，如果数据长度小于等于125，读取的数据就是长度；如果是126，需要读取接下来的两个字节才是长度；如果是127，需要读取接下来的八个字节。</p>
</li>
<li><p>Mask Key就是掩码值，长度为2字节；如果Mask为0，没有这2个字节。</p>
</li>
<li><p>发送的数据，如果有掩码操作，需要反掩码，算法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result[i] = origin[i] ^ maskKey[i % <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>即原属数据的第i位和掩码的第i%4进行异或，我们以<code>我是大白</code>为例计算，传过来的编码是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8a 1c 62 22 f6 05 21 78 cf 5d 60 78</span><br></pre></td></tr></table></figure>
<p>对应的maskKey是<code>0x6fb8c5c5</code>，根据上面的算法，如下计算得到的数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> origin = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="string">"0x8a"</span>, <span class="string">"0x1c"</span>, <span class="string">"0x62"</span>, <span class="string">"0x22"</span>, <span class="string">"0xf6"</span>, <span class="string">"0x05"</span>, <span class="string">"0x21"</span>, <span class="string">"0x78"</span>, <span class="string">"0xcf"</span>, <span class="string">"0x5d"</span>, <span class="string">"0x60"</span>, <span class="string">"0x78"</span>]);</span><br><span class="line"><span class="keyword">const</span> maskKey = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0x6f</span>, <span class="number">0xb8</span>, <span class="number">0xc5</span>, <span class="number">0xc5</span>]);</span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(origin.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; origin.length; i++, j = i % <span class="number">4</span>) &#123;</span><br><span class="line">  result[i] = origin[i] ^ maskKey[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURI</span>(<span class="built_in">Array</span>.from(result).map(<span class="function"><span class="params">num</span>=&gt;</span> <span class="string">"%"</span>+<span class="built_in">Number</span>(num).toString(<span class="number">16</span>)).join(<span class="string">''</span>));	<span class="comment">// 输出"我是大白"</span></span><br></pre></td></tr></table></figure>
<p>websocket文字传输采用了utf-8编码，想要得到汉字需要解码。这里使用decodeURI方法，因为web要求url的查询字符串也是采用utf-8编码，decodeURI方法拿来用再合适不过。</p>
<h2 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h2><p>接下里我们来读取客户端的数据，我们先不管长度大于125以上的字符长，所以现在读取的数据帧偏移量是确定的。因为socket读取的数据是buffer对象，所以先说几个基本读取和转换的方法</p>
<ol>
<li>readUInt8、readUInt16BE等，字节以8个字符一单位，readUInt8就是读取一个字节，readUInt16BE读取两个字节，BE表示大端在前，可以看作数据帧过来的顺序。第二个参数是字节的偏移量，readUInt16BE(1,1)，表示读取第二个字节开始的2个字节。</li>
<li>toString和parseInt方法，readUInt8读取到的数字是十进制，有时候需要转换成十六进制或者二进制，toString方法参数可以传递表示进制数。parseInt方法可以把十六进制转成十进制。</li>
</ol>
<p>首先需要读取op操作符，暂时只解析0x01格式的数据帧。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OPCODES = &#123;</span><br><span class="line">  CONTINUE: <span class="number">0</span>,</span><br><span class="line">  TEXT: <span class="number">1</span>,</span><br><span class="line">  BINARY: <span class="number">2</span>,</span><br><span class="line">  CLOSE: <span class="number">8</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseMessage</span>(<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> op = buffer.readUInt8(<span class="number">0</span>) &amp; <span class="number">0x0f</span>;	<span class="comment">// 读取第一个字节</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`op: <span class="subst">$&#123;op&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> OPCODES.TEXT:</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> Msg(buffer).decode();</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"未知的操作码"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在Msg对象里操作buffer。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Msg</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(buffer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parse(buffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parse(buffer) &#123;</span><br><span class="line">    <span class="keyword">const</span> offset = <span class="keyword">this</span>.parseLengthAndMask(buffer);</span><br><span class="line">    <span class="keyword">this</span>.readMaskData(buffer, offset);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parseLengthAndMask(buffer) &#123;</span><br><span class="line">    <span class="keyword">const</span> masks = buffer.readUInt8(<span class="number">1</span>).toString(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> isMask = masks.slice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> length = <span class="built_in">parseInt</span>(masks.slice(<span class="number">1</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> offset = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">if</span> (isMask) &#123;</span><br><span class="line">      <span class="keyword">const</span> maskKey = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(mask_length); <span class="comment">// 初始化长度</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; mask_length; i++) &#123;</span><br><span class="line">        maskKey[i] = toSuffixHexAdecimal(buffer.readUInt8(i + offset)); <span class="comment">// 标志为16进制</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.maskKey = maskKey;</span><br><span class="line">      offset += mask_length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  readMaskData(buffer, offset) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; loadData, length &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> origin = <span class="keyword">this</span>.origin = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">this</span>.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      origin[i + loadData] = toSuffixHexAdecimal(buffer.readUInt8(i + offset));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> origin;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  maskOp() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; maskKey, origin &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(origin.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; origin.length; i++, j = i % <span class="number">4</span>) &#123;</span><br><span class="line">      result[i] = origin[i] ^ maskKey[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  decode() &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">this</span>.maskOp();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">decodeURI</span>(</span><br><span class="line">        <span class="built_in">Array</span>.from(result)</span><br><span class="line">          .map(<span class="function">(<span class="params">r</span>) =&gt;</span> <span class="string">"%"</span> + toHexAdecimal(r))</span><br><span class="line">          .join(<span class="string">""</span>)</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码相对简单，因为此时数据并没有分片的概念，只是单条数据帧。下面来看数据太长之后导致分片的结果：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; Client: FIN=1, opcode=0x1, msg=&quot;hello&quot;</span><br><span class="line">&gt; Server: (process complete message immediately) Hi.</span><br><span class="line">&gt; Client: FIN=0, opcode=0x1, msg=&quot;and a&quot;</span><br><span class="line">&gt; Server: (listening, new message containing text started)</span><br><span class="line">&gt; Client: FIN=0, opcode=0x0, msg=&quot;happy new&quot;</span><br><span class="line">&gt; Server: (listening, payload concatenated to previous message)</span><br><span class="line">&gt; Client: FIN=1, opcode=0x0, msg=&quot;year!&quot;</span><br><span class="line">&gt; Server: (process complete message) Happy new year to you too!</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>一共发了两条信息，第一条帧是完整的消息；第二条分片后，只有最后一次信息FIN才是1，且操作码是0。所以判断FIN是否为1来判断消息是否完整。</p>
<p>再来思考一个问题，分片后的每条数据可以单独解码转成汉字吗？事实是不可以，大部分的汉字utf-8会有3个字节，数据帧只会把这条写满后才会写下一条数据，所以会导致3字节的汉字可能第一字节在前一帧，后面两个字节就在后一帧。如果直接读取分片，会导致decodeURI方法抛出异常，所以需要把所有的数据都读取到再去解码。</p>
<p>除此之外，在node里buffer对象的最大长度是65535，所以在读取大数据时候收到的buffer次数可能会超过分片长度，如果没有超过分片长度的话，这是因为上一帧的剩余的buffer和下一帧的buffer在同一buffer传输过来，这又是一个大坑。所以需要有个变量loadData表示单个数据帧是否传输完成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msgs = [];	<span class="comment">// 收到数据会有多个msg实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseMessage</span>(<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (msgs.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = msgs[msgs.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> left = msg.left();	<span class="comment">// 如果上一帧buffer有剩余，需要截断此次的buffer</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      msg.parse(buffer.slice(<span class="number">0</span>, left));</span><br><span class="line">      <span class="keyword">if</span> (left &gt;= buffer.length) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buffer = buffer.slice(left);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> op = buffer.readUInt8(<span class="number">0</span>) &amp; <span class="number">0x0f</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`op: <span class="subst">$&#123;op&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">let</span> msg;</span><br><span class="line">  <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> OPCODES.TEXT:</span><br><span class="line">      msg = <span class="keyword">new</span> Msg(buffer);</span><br><span class="line">      <span class="keyword">if</span> (msg.finished) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`收到信息：<span class="subst">$&#123;decode([msg.maskOp()])&#125;</span>`</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msgs.push(msg);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OPCODES.CONTINUE:</span><br><span class="line">      msg = <span class="keyword">new</span> Msg(buffer);</span><br><span class="line">      msgs.push(msg);</span><br><span class="line">      <span class="keyword">if</span> (msg.finished) &#123;</span><br><span class="line">        <span class="keyword">const</span> datas = msgs.map(<span class="function">(<span class="params">m</span>) =&gt;</span> m.maskOp());</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`收到信息：<span class="subst">$&#123;decode(datas)&#125;</span>`</span>);</span><br><span class="line">        msgs = [];	<span class="comment">// 清空msgs</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"未知的操作码"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Msg</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(buffer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.loadData = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.buffers = [];</span><br><span class="line">    <span class="keyword">this</span>.parse(buffer);</span><br><span class="line">    <span class="keyword">this</span>.finished = <span class="keyword">this</span>.isFinish(buffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parse(buffer) &#123;</span><br><span class="line">    <span class="keyword">const</span> buffers = <span class="keyword">this</span>.buffers;</span><br><span class="line">    <span class="keyword">if</span> (buffers.length === <span class="number">0</span>) &#123;	<span class="comment">// 如果是第一个buffer，需要在此读取基本信息，否则直接读取数据</span></span><br><span class="line">      buffers.push(buffer);</span><br><span class="line">      <span class="keyword">const</span> offset = <span class="keyword">this</span>.parseLengthAndMask(buffer);</span><br><span class="line">      <span class="keyword">this</span>.origin = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">this</span>.length);</span><br><span class="line">      <span class="keyword">const</span> length = <span class="built_in">Math</span>.min(buffer.length - offset, <span class="keyword">this</span>.length);</span><br><span class="line">      <span class="keyword">this</span>.readMaskData(buffer, offset, length);</span><br><span class="line">      <span class="keyword">this</span>.loadData += length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.readMaskData(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line">      <span class="keyword">this</span>.loadData += buffer.length;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  left() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length - <span class="keyword">this</span>.loadData;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parseLengthAndMask(buffer) &#123;</span><br><span class="line">    <span class="keyword">const</span> masks = buffer.readUInt8(<span class="number">1</span>).toString(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> isMask = masks.slice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> length = <span class="built_in">parseInt</span>(masks.slice(<span class="number">1</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> offset = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (length === <span class="number">126</span>) &#123;	<span class="comment">// 不同长度的字节读取</span></span><br><span class="line">      length = <span class="built_in">parseInt</span>(buffer.readUInt16BE(<span class="number">2</span>).toString(<span class="number">16</span>), <span class="number">16</span>);</span><br><span class="line">      offset += <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (length === <span class="number">127</span>) &#123;</span><br><span class="line">      length = <span class="built_in">parseInt</span>(</span><br><span class="line">        buffer.readUInt32BE(<span class="number">2</span>).toString(<span class="number">16</span>) +</span><br><span class="line">          buffer.readUInt32BE(<span class="number">6</span>).toString(<span class="number">16</span>),</span><br><span class="line">        <span class="number">16</span></span><br><span class="line">      );</span><br><span class="line">      offset += <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">if</span> (isMask) &#123;</span><br><span class="line">      <span class="keyword">const</span> maskKey = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(mask_length); <span class="comment">// 初始化长度</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; mask_length; i++) &#123;</span><br><span class="line">        maskKey[i] = toSuffixHexAdecimal(buffer.readUInt8(i + offset)); <span class="comment">// 标志为16进制</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.maskKey = maskKey;</span><br><span class="line">      offset += mask_length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把decode方法独立出来，因为需要多个msg的实例才能拿到最终数据，所以不再属于对象的方法了。</p>
<p>在decode里又遇到大坑，再度抛出<code>URI malformed</code>异常。定位后发现在js里字符串的长度理论上是可以很长的，但是实际上执行引擎并不一定会有这么大的长度去容纳。而反掩码后得到的字符串过长，导致字符串截断，所以无法正常反掩码了。针对这种情况，对字符串也要分片处理。但是切割位无法很好的处理，我直接把切割的长度定在3的倍数270，因为大部分汉字编码长度都是3。实际上还是要针对每个汉字再解码会好点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> seg_length = <span class="number">270</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decode</span>(<span class="params">datas</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> total = datas.reduce(<span class="function">(<span class="params">total, cur</span>) =&gt;</span> total + cur.length, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> segs = <span class="built_in">Math</span>.ceil(total / seg_length);	<span class="comment">// 分片长度</span></span><br><span class="line">  <span class="keyword">let</span> seg = <span class="number">0</span>,</span><br><span class="line">    segDataIdx = <span class="number">0</span>, <span class="comment">// 指向当前data的索引</span></span><br><span class="line">    dataIdx = <span class="number">0</span>,</span><br><span class="line">    data = datas[seg];</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">while</span> (seg &lt; segs) &#123;</span><br><span class="line">    <span class="keyword">const</span> length = seg === segs - <span class="number">1</span> ? total - seg_length * seg : seg_length;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(length);</span><br><span class="line">    result.push(arr);</span><br><span class="line">    seg++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> arrIdx = <span class="number">0</span>; arrIdx &lt; length; arrIdx++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (segDataIdx === data.length) &#123;	<span class="comment">// 当前data读取完毕</span></span><br><span class="line">        segDataIdx = <span class="number">0</span>;</span><br><span class="line">        data = datas[++dataIdx];</span><br><span class="line">      &#125;</span><br><span class="line">      arr[arrIdx] = data[segDataIdx++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 假设能发送过来的长度那肯定也能读取完毕不会被截断</span></span><br><span class="line">  <span class="keyword">return</span> result.reduce(</span><br><span class="line">    (str, data) =&gt;</span><br><span class="line">      (str += <span class="built_in">decodeURI</span>(</span><br><span class="line">        <span class="built_in">Array</span>.from(data)</span><br><span class="line">          .map(<span class="function">(<span class="params">r</span>) =&gt;</span> <span class="string">"%"</span> + toHexAdecimal(r))</span><br><span class="line">          .join(<span class="string">""</span>)</span><br><span class="line">      )),</span><br><span class="line">    <span class="string">""</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样数据分片的读取我们也完成了。</p>
<h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><p>发送数据就是自己去组装数据帧，不需要掩码，但也要遵从数据长度的规则，这里我们就不再赘述，直接按长度小于126的去组装即可，每一条数据的的FIN都是1，操作码也是0x01。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> b1 = toSuffixHexAdecimal(<span class="number">0x80</span> | OPCODES.TEXT);</span><br><span class="line">  <span class="keyword">const</span> payLoad = Buffer.from(data, <span class="string">"utf8"</span>);</span><br><span class="line">  <span class="keyword">const</span> length = payLoad.length;</span><br><span class="line">  <span class="keyword">const</span> b2 = toSuffixHexAdecimal(length);</span><br><span class="line">  <span class="keyword">const</span> buffer = Buffer.alloc(length + <span class="number">2</span>);</span><br><span class="line">  buffer.writeUInt8(b1, <span class="number">0</span>);</span><br><span class="line">  buffer.writeUInt8(b2, <span class="number">1</span>);</span><br><span class="line">  payLoad.copy(buffer, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p>关闭连接和发送数据的区别就是操作码不一样，而且也不需要长度的说明，就不再贴代码了。当服务端关闭请求时，浏览器也会在此发送个关闭的数据帧给服务端表示收到，之后两者再传输的数据帧就会被抛弃，这点需要注意。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实写websokcet服务器并不是多难的事，只要遵从数据帧的格式解析或者组装就可以， 只是看起来高大上点。不过一开始我也会出现疑惑，比如客户端发送关闭帧时候服务器应该做什么回应才能正式关闭，事实是客户端遵从了协议，发送帧之后就会关闭连接，而并不需要我们做什么。还有就是数据长度太长的坑，无法正常的解析等等，更多的是对这种边界情况的处理。</p>
<p>但是通过此次代码，可以使用wiresharek抓包和协议的理解等，具体代码参见这里<a href="https://github.com/ccanister/websocket" target="_blank" rel="noopener">websocket</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="noopener">websocket mdn</a></li>
<li><a href="http://semlinker.com/you-dont-know-websocket" target="_blank" rel="noopener">你不知道的 WebSocket</a></li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/16/动手写webpack：loader机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/16/动手写webpack：loader机制/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-16T12:02:47+08:00">
                2020-09-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="动手写webpack：loader机制"><a href="#动手写webpack：loader机制" class="headerlink" title="动手写webpack：loader机制"></a>动手写webpack：loader机制</h1><p>webpack默认只能识别js文件，可以解析其导入和导出等。但是在js文件中，我们可能会想直接导入css文件或者图片，就需要自己去处理。loader机制就是声明那些类型的文件可以交给其来处理，甚至你可以直接说js文件交给了webpack内置的loader处理了。将文件内容传入loader再处理成需要的字符串交回给webpack处理。输入和输出都是字符串。不仅如此，同一种类型的文件可以交给多个loader处理，比如css文件可以串行的先交给css-loader处理，再交给style-loader处理，最后返回webpack。</p>
<!-- readMore -->
<p>和loader相比较的，我们往往会讨论plugin。把webpack当作垃圾工厂的话，loader就是垃圾分类，不同类型的垃圾交由不同的loader处理，整理好后交给webpack。plugin可以在处理的过程中自定义事件，比如说处理前先把垃圾都堆在垃圾产地中，或者处理完中后先把屯放的仓库清理干净后再屯放垃圾（cleanWebpackPlugin）。所以在编写plugin时候更多去监听编译过程事件。</p>
<h2 id="loaders的拆解"><a href="#loaders的拆解" class="headerlink" title="loaders的拆解"></a>loaders的拆解</h2><p>因为我们没有配置文件，所以我们配置loader时候直接声明再js的导入中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; obj &#125; <span class="keyword">from</span> <span class="string">"wait-loader!simple-loader!./a"</span>;</span><br></pre></td></tr></table></figure>
<p>通过！标示了前面部分是loader名称，如果有多个loader就用！一直隔开。所以在识别是否是loader时候我们匹配！是否存在即可。整体的思路就是在读取文件内容后，解析依赖时识别和切割loader，再去拿到其绝对路径，从左往右依次执行loader方法取回的字符串就是该依赖内容，最后去识别这个依赖文件的依赖。和普通模块的区别就是多了解析loader这步，所以直接从之前的Module衍生出子类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	init() &#123;</span><br><span class="line">		<span class="keyword">this</span>.code = <span class="keyword">await</span> <span class="keyword">this</span>.readCode(absoulutePath);</span><br><span class="line">		<span class="keyword">const</span> &#123; deps &#125; = parse(<span class="keyword">this</span>);</span><br><span class="line">		....</span><br><span class="line">	&#125;</span><br><span class="line">	readCode() &#123;</span><br><span class="line">    <span class="keyword">return</span> readFile(<span class="keyword">this</span>.absoulutePath);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoaderModule</span> </span>&#123;</span><br><span class="line">  readCode() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.executeLoader();</span><br><span class="line">  &#125;</span><br><span class="line">  executeLoader() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; loaderPaths, contentAbsolutePath, <span class="attr">absoulutePath</span>: request &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> content = readFile(contentAbsolutePath);</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 从右往左执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = loaderPaths.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      content = <span class="built_in">require</span>(loaderPaths[i])(content);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种情况只支持了同步loader的执行，在文档中我们看到当调用了<code>this.async()</code>后表示开启了异步loader，可以用一个变量表示是否是异步的，不是的话我们继续执行下一个loader，否则就返回可执行下个loader的回调。除此之外我们d看到this，说明了loader函数的执行有上下文对象。下面我们以css-loader为例，他是异步的loader，同时也调用了上下文的部分字段：</p>
<ul>
<li>remainingRequest：剩下的loader</li>
<li>currentRequest：比remainingRequest多了当前的loader</li>
</ul>
<p>调用async函数后会返回回调函数后，只有调用了回调函数后才会执行下一个loader。所以最后返回的字符串内容时机是无法确定的，用promise可以解决这个问题，调用resolve之后才算返回了内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">executeLoader() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; loaderPaths, contentAbsolutePath, <span class="attr">absoulutePath</span>: request &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> content = readFile(contentAbsolutePath);</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> loaderFuns = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = loaderPaths.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        loaderFuns.push(<span class="built_in">require</span>(loaderPaths[i]));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> remainingRequest = <span class="keyword">this</span>.popRequest(request);</span><br><span class="line">      <span class="keyword">let</span> currentRequest = request;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">nextLoader</span>(<span class="params">content, needPop</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needPop) &#123;</span><br><span class="line">          remainingRequest = self.popRequest(remainingRequest);</span><br><span class="line">          currentRequest = self.popRequest(currentRequest);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!loaderFuns.length) &#123;</span><br><span class="line">          resolve(content);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> isAsync = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">const</span> context = &#123;</span><br><span class="line">          callback: <span class="function">(<span class="params">error, content</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">              <span class="keyword">throw</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nextLoader(content, <span class="literal">true</span>);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="keyword">async</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            isAsync = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.callback;</span><br><span class="line">          &#125;,</span><br><span class="line">          remainingRequest,</span><br><span class="line">          currentRequest,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> resp = loaderFuns.pop().call(context, content);</span><br><span class="line">        <span class="keyword">if</span> (!isAsync) &#123;</span><br><span class="line">          nextLoader(resp, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      nextLoader(content, <span class="literal">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在文件中调用css文件成功打印了其文件内容，如果我们去掉loader选项，就会报无法处理css文件的错误。另外，在生成的bundle文件中，发现多了runtime等模块。在css-loader的源码中，可以看到它对传入的字符串拼接了import文件的内容，我们在css-loader处理后去分析了它的依赖，所以才会多打包了这些模块。</p>
<p>源代码可以看<a href="https://github.com/ccanister/fake-webpack#fake-webpack" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="pitch-loader"><a href="#pitch-loader" class="headerlink" title="pitch loader"></a>pitch loader</h2><p>本来是想把style-loader和css-loader放在一起处理css文件的，但是发现事实上并没有执行css-loader函数。去到style-loader源码查看时，默认导出函数是空的，但它挂载了pitch方法。根据webpack文档，应该先从左往右执行loader的pitch方法，再从右往左执行loader函数。如果pitch方法返回了字符串，那么终止后面的loader调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a(pitch) -&gt; b(pitch) -&gt; c(pitch) -&gt; c -&gt; b -&gt; a</span><br><span class="line">现在b这个loader执行pitch时候返回了字符串</span><br><span class="line">a(pitch) -&gt; b(pitch) -&gt; a</span><br></pre></td></tr></table></figure>
<p>这样做的好处是什么呢？我们回过头来看style-loader，它需要拿到css的文件内容，但是css-loader最终返回的格式是<code>module.exports = xxx</code>，对于style-loader而言没有任何用处。所以在打包时候它内部需要重新请求css文件，本质上也是调用了css-loader去处理。这样就会导致css-loader执行了两遍。</p>
<p>webpack对loader提供了pitch方法后，style-loader执行后返回字符串就可以提前返回，不用再往后执行了，提高了效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/05/从zepto说起/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/05/从zepto说起/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-05T17:12:47+08:00">
                2020-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从zepto说起"><a href="#从zepto说起" class="headerlink" title="从zepto说起"></a>从zepto说起</h1><p>学完underscore源码，操作对象和常用的函数等应该都是手到擒来了。接下来来看DOM操作，毕竟是前端，更多还是为浏览器服务的。jquery源码点进去一看几千行吧，吓得退了出来，后来发现还有zepto也是针对浏览器的js库，而且更为轻量，没有较多的兼容低版本代码，所以选择看zepto源码。</p>
<p>zepto的测试用例比较恶心，框架好像是自己搭的，测试用例出错的时候也不会说明是哪个出错，只有统计结果xxx运行成功，xxx运行失败，相对而言还是qunit框架的测试反馈直观。</p>
<!-- readMore -->
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>zepto核心方法就是<code>$</code>方法，他可以传入css选择器查询DOM节点，也可以传入字符串创建新的DOM节点，最终返回的是类数组，即带有索引的zepto对象。还可以传入函数，可以在页面加载完毕后执行。</p>
<p>当传入的第一个参数是字符串时候，先删除首尾的空白字符。如果首字符是<code>&lt;</code>，说明是解析字符串创建DOM节点，否则就是查询。</p>
<h3 id="查询DOM节点"><a href="#查询DOM节点" class="headerlink" title="查询DOM节点"></a>查询DOM节点</h3><p>查询接口分成两种：<code>getElementsBy</code>系列和<code>querySelectorAll</code>，浏览器基本能够兼容这两种方法。但是zepto会根据类型判断，依次是id、class和tag，都有对应的<code>getElementsBy</code>方法查询，最后才降低到querySelectorAll函数，采用这种方法的目的肯定是尽可能地提高选择器性能。除了这点，两者其他区别：</p>
<ol>
<li><p>传入参数不同：getElementsBy只能传入单一的id、className和tagName，而<code>querySelectorAll</code>可以接受css选择器。所以zepto中有个正则<code>/^[\w-]*$/</code>判断是否是单一的选择符，防止有空格符隔开，而用了错误的查询。</p>
</li>
<li><p>返回值：这点比较重要，getElementsBy返回的是动态的HTMLCollection，而querySelectorAll返回的是静态的NodeList。可以看这个经典的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// querySelectorAll</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelectorAll(<span class="string">'ul'</span>)[<span class="number">0</span>],</span><br><span class="line">    lis = ul.querySelectorAll(<span class="string">"li"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length ; i++)&#123;</span><br><span class="line">    ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"li"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getElementsBy</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>], </span><br><span class="line">    lis = ul.getElementsByTagName(<span class="string">"li"</span>); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length ; i++)&#123;</span><br><span class="line">    ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"li"</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为getElementsBy返回的是动态节点集合，当该查询有变化时候，返回的集合也会有之变化，所以会导致无限循环。</p>
<p>而querySelectorAll返回的集合就是个快照，不会有什么影响。</p>
<p>当然在zepto中，对两个选择器返回的结果重新塞入新对象中，所以也是个静态集合。</p>
<p>除了这点，HTMLCollection只包含元素节点，即nodeType为1的节点，节点的children属性可以返回这类集合，而NodeList是包含所有类型的节点，可以通过节点的childNodes属性返回。所以有时候前者返回的集合是空的，但后者长度不为空，一般可能返回了文本节点。</p>
</li>
</ol>
<h3 id="解析字符串"><a href="#解析字符串" class="headerlink" title="解析字符串"></a>解析字符串</h3><p>因为浏览器本身就是支持innerHTML属性的，所以第一想法就是利用该属性。但是这里有个坑就是利用innerHTML属性，就要有个父节点，那么父节点的标签名往往会用<code>div</code>，但div父标签并不能创建所有的子节点，比如表格的标签tr、tbody等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">div.innerHTML = <span class="string">"&lt;td&gt;123&lt;/td&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div.childNodes) <span class="comment">// [text]</span></span><br></pre></td></tr></table></figure>
<p>会忽略掉td节点，只有123文本节点。所以父标签需要有个映射表。</p>
<p>另外一点，为了提高性能，当传入单标签的字符串即<code>&lt;div&gt;&lt;/div&gt;</code>，里面没有包裹任何元素时候，会直接使用createElement方法，而不是采用上述方法。</p>
<h2 id="元素属性"><a href="#元素属性" class="headerlink" title="元素属性"></a>元素属性</h2><p>这里的属性指的不是properity，而是我们平常打交道的css、class、prop和attribute等。通常操作就是增删改查，需要关注的一个点是键值有中划线和驼峰两种格式，两者在不同的操作下有时候可取有时候不可取。</p>
<h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><p>想要取得节点的样式，不能直接通过style属性。因为style属性只存储了内联样式，但是节点最终的样式是综合规则计算出来的，单单读取内联样式是不够的。所以正确的做法是通过getComputedStyle(el, [pseudoElt])方法取值，该方法返回了动态的CSSStyleDeclaration对象，第二个参数传入元素的伪类，如<code>:before</code>。当元素的样式更改时，它会自动更新本身。注意，style属性返回的也是CSSStyleDeclaration对象。取值的时候，CSSStyleDeclaration对象同时存储了中划线和驼峰两种键值，比如<code>margin-top</code>就会同时存储<code>margin-top</code>和<code>marginTop</code>两个键值，所以不用在乎键值格式。</p>
<p>删除和设置元素的时候有两种方法：</p>
<ol>
<li>调用style属性的CSSStyleDeclaration对象，它暴露两个方法removeProperty和setProperty。</li>
<li>调用style属性的cssText，它返回了内联样式上所有css字符串，相邻样式用;隔开。设置值的时候可以直接在后面附加属性，如<code>el.style.cssText += &quot;;width:10px&quot;</code>，如果有重名样式，直接覆盖，所以删除样式，可以这样<code>el.style.cssText += &quot;width:null&quot;</code>。</li>
</ol>
<p>以上两种方法的操作都是基于元素的内联样式，而且键值都要改成中划线格式。在zepto中删除操作采用了第一种方法，设置操作采用了第二种方法。第二种方式可以批处理操作，减少浏览器的重排和回流。</p>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>操作class也是有两种方案，而且不区分名字格式，即<code>className</code>和<code>classList</code>，后者也是类数组，有add、remove等方法，可以传入多个参数，可谓是非常的方便。但是IE10以下不兼容，所以又退化回className字符串的操作。</p>
<p>对于字符串的增删改查，往往使用正则匹配是最为方便的。className是是由空格分隔的多个class属性值。所以匹配的字符串应该为<code>/(^|\s)[classname](\s|$)/</code> 形式，有可能会出现在开头或者结尾处。删除时候，直接将其替换成空字符串即可。还有一个点，对于svg类型的标签需要特别的注意，其className得到的是一个对象,类似这样<code>SVGAnimatedString {baseVal: &quot;box hallo&quot;, animVal: &quot;box hallo&quot;}</code>，所以取className的时候，还得看是否有baseVal属性。</p>
<h3 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a>attribute</h3><p>对于元素属性的操作比较简单，分别调用<code>setAttribute</code>、<code>getAttribute</code>和<code>removeAttribute</code>方法。其中属性值都是小写的，即使传入大写字符，也会被小写化。需要注意的是对于不存在的属性，getAttribute方法会返回null，但不代表着删除值的时候，调用setAttribute就可以传入null参数。因为布尔属性无论设置了任何值都会呗认为是true，比如<code>el.setAttribute(disable, null)</code>，此时按钮也会设置禁用状态。所以删除值时候还是用removeAttribute方法替代。</p>
<h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><p>在Angular中有专门一节对比了attribute和property，它认为attribute是HTML属性，而property是DOM节点属性。两者即可以1:1映射，比如<code>id</code>属性，有可能存在attribute没有对应的property，比如<code>aria-*</code>属性，也有可能存在property没有对应的attribute，比如<code>textContent</code>。但是即使有相同的名字，两者意义也是不一样的。所以在Angular中，attribute的作用是初始化元素和指令的状态。而在标准的差异如下：</p>
<ol>
<li><p>取值方法不同：property通过el[name]获取，attribute通过el.getAttribute(name)获取。</p>
</li>
<li><p>同步：property会从attribute中同步属性，意味着改变了attribute也会改变property属性，反之则不会。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el.setAttribute(<span class="string">"disabled"</span>, <span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(el.disbaled)	<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>键值格式：attribute会忽略大小写，property不会忽略，但是有些保留字比如class，不能通过el.class获取，而是el.className</p>
</li>
</ol>
<h3 id="data"><a href="#data" class="headerlink" title="data-*"></a>data-*</h3><p>Data-*是h5具有扩展型的设计，允许在HTML元素中存储额外的信息，js和css都能访问到该属性。在元素上设置值的时候，会忽略大小写，大写字符也会被转成小写的字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  article[data-columns=<span class="string">"3"</span>] &#123;</span><br><span class="line">  	background: orange;</span><br><span class="line">  &#125;</span><br><span class="line">  article::before &#123;</span><br><span class="line">    content: attr(data-columns);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;article id="article" data-columns=3&gt;</span></span><br><span class="line"><span class="regexp">	dabai</span></span><br><span class="line"><span class="regexp">&lt;/</span>article&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> article = <span class="built_in">document</span>.querySelector(<span class="string">"#article"</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(article.dataset.columns);	<span class="comment">// 3</span></span><br><span class="line">	<span class="built_in">console</span>.log(article.getAttribute(<span class="string">"data-columns"</span>));	<span class="comment">// 3</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到对于js而言，有两种操作方法，一个是通过dataset属性，不需要添加data-前缀，但是要把中划线格式转换成驼峰，另外一个是通过attributes属性，需要加上data-的前缀。对于css而言，同样可以直接调用attr方法当作样式值，或者当作属性选择器来改变样式，但都要加上data-的前缀。</p>
<p>这样js通过设置data-*共享变量就能改变元素样式，从而减少逻辑。</p>
<h2 id="DOM的增删改查"><a href="#DOM的增删改查" class="headerlink" title="DOM的增删改查"></a>DOM的增删改查</h2><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>zepto插入元素的方法有很多种，而且写法都很巧妙。我们先来看append、prepend、after和before这四种方法，其他都是衍生方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;div id=<span class="string">"beforeafter"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ js</span></span><br><span class="line"><span class="regexp">$("#beforeafter").append("append");</span></span><br><span class="line"><span class="regexp">$("#beforeafter").prepend("prepend");</span></span><br><span class="line"><span class="regexp">$("#beforeafter").before("before");</span></span><br><span class="line"><span class="regexp">$("#beforeafter").after("after");</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 最后输出 before&lt;div id="beforeafter"&gt;prependappend&lt;/</span>div&gt;after</span><br></pre></td></tr></table></figure>
<p>可以看到append插入到匹配元素的最后一个子节点的后面，prepend是插入到匹配元素的第一个子节点前面。after插入到匹配元素的后面，before插入到匹配元素前面。上下区别是一个在内部，一个在外部。</p>
<p>上面四种方法有两个相同点：</p>
<ol>
<li><p>传入参数是一样的：可以是html字符串，也可以是dom节点、Zepto内置的对象或者以上组成的数组。这个比较好解决，html字符串就调用核心方法<code>fragment</code>解析字符串；如果是数组就去遍历即可。</p>
</li>
<li><p>都是插入到某个元素的节点，最后都可以调用parent.appenchild(node, child)方法。具体可以这么看</p>
<p>|         | parent           | 被插入的元素           |<br>| ——- | —————- | ———————- |<br>| append  | 当前元素         | null                   |<br>| prepend | 当前元素         | 当前元素的firstChild   |<br>| after   | 当前元素的父节点 | 当前元素下一个兄弟节点 |<br>| before  | 当前元素的父节点 | 当前元素               |</p>
</li>
</ol>
<p>解决了这两个问题，就基本能看懂插入元素的函数了。还有两个细节值得关注：</p>
<ul>
<li>如果插入元素是数组且长度大于1，那么插入的元素需要克隆，否则如果元素处在文档中，就会不断从上个元素中删除再插入到下个元素，最后会被插入到zepto对象最后一个元素节点。</li>
<li>如果插入的元素在节点中，而且是内联的script标签节点，需要调用eval方法执行脚本。注意这里上下文的取值<code>var target = el.ownerDocument? el.ownerDocument.defaultView window;</code>。如果是iframe上下文是el.ownerDocument.defaultView，否则正常的窗口上下文是window。</li>
</ul>
<p>after、prepend、before和append衍生的方法分别是insertAfter、prependTo、insertBefore和appendTo，可以看作参数和调用上下文刚好相反即可。</p>
<h3 id="包裹元素"><a href="#包裹元素" class="headerlink" title="包裹元素"></a>包裹元素</h3><p>包裹元素的方法有三种，分别是wrap、wrapAll和wrapInner，文字描述功能有些晦涩，我们直接看demo：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = $(<span class="string">"&lt;b&gt;A&lt;/b&gt;&lt;b&gt;B&lt;/b&gt;"</span>);</span><br><span class="line">el.wrap(<span class="string">"&lt;a class=link&gt;&lt;/a&gt;"</span>);	<span class="comment">// &lt;a class=link&gt;&lt;b&gt;A&lt;/b&gt;&lt;/a&gt;&lt;a class=link&gt;&lt;b&gt;B&lt;/b&gt;&lt;/a&gt;</span></span><br><span class="line">el.wrapAll(<span class="string">"&lt;a class=link&gt;&lt;/a&gt;"</span>);	<span class="comment">// &lt;a class=link&gt;&lt;b&gt;A&lt;/b&gt;&lt;b&gt;B&lt;/b&gt;&lt;/a&gt;</span></span><br><span class="line">el.wrapInner(<span class="string">"&lt;a class=link&gt;&lt;/a&gt;"</span>);	<span class="comment">// &lt;b&gt;&lt;a class=link&gt;A&lt;/a&gt;&lt;/b&gt;&lt;b&gt;&lt;a class=link&gt;B&lt;/a&gt;&lt;/b&gt;&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>
<p>wrap就是包裹el的每个子节点，wrapAll直接包裹el，wrapInner是包裹el的每个子节点的内容。可以发现wrapAll是底层方法，其他两个方法都可以调用它来实现逻辑，所以先来看wrapAll方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wrapAll: <span class="function"><span class="keyword">function</span> (<span class="params">structure</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">    $(<span class="keyword">this</span>[<span class="number">0</span>]).before((structure = $(structure)));</span><br><span class="line">    <span class="keyword">var</span> children;</span><br><span class="line">    <span class="comment">// drill down to the inmost element</span></span><br><span class="line">    <span class="keyword">while</span> ((children = structure.children()).length)</span><br><span class="line">      structure = children.first();</span><br><span class="line">    $(structure).append(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>首先要把外包裹元素插入到文档中，因为structure参数可以是html字符串，如果不先插入文档中，就直接被外层包裹的元素带走无法在浏览器中显示。然后迭代查询外包裹元素的第一个子节点，注意children方法返回的element类型的节点，不会返回文本节点的。最后把被包裹元素插入到第一个子节点末尾。</p>
<p>另外我们来看这两个例子</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">$('.box').wrapAll('.wrap')</span><br><span class="line">// 结果</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时的ul结构仍然存在。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"here"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"here"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">// 结果</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"here"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"here"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时ul结构被移动到第一个div标签中。上述两个例子的结果不同是因为，第一个外包裹元素的第一个子节点就是两个div，而第二个的第一个字节点是第一个class为here的div节点。在append方法中我们提到过被插入的元素长度超过1时候，插入元素会克隆。</p>
<p>看完了wrapAll方法，再来看wrap就很简单，只要遍历每个子元素节点再调用wrapAll方法即可。而wrapInner方法，遍历子元素节点时候，子元素的子节点调用wrapAll方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wrapInner: <span class="function"><span class="keyword">function</span> (<span class="params">structure</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = $(<span class="keyword">this</span>),</span><br><span class="line">    contents = self.childrenNodes,</span><br><span class="line">    contents.length ? contents.wrapAll(structure) : self.append(structure);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="查询DOM内容"><a href="#查询DOM内容" class="headerlink" title="查询DOM内容"></a>查询DOM内容</h3><ol>
<li><p>children：只查询元素节点，即children属性，或者childNodes属性再过滤nodeType为1的节点。</p>
</li>
<li><p>text：text获取有两种方法：innerText和textContent。两者都可以拿到包括子节点的文本内容和设置值。</p>
<ul>
<li>空格等设置：textContent会直接获取所有空格或者换行符，innerText会根据元素是否是块级而合并空格。</li>
<li>子元素隐藏后文本内容显示：textContent仍然显示全部，innerText如果隐藏不再显示。</li>
<li>性能：可以看得出innerText会计算元素属性，性能较差。</li>
</ul>
</li>
<li><p>val：根据value属性取值，注意的是select表单控件的value是多项的，可以根据multiple属性判断。selectedOptions属性可以直接获取选中值，但是ie不支持该属性，所以还是要遍历option元素。</p>
</li>
<li><p>hmtl：根据innerHTML属性设置或者获取。</p>
</li>
<li><p>height和width：我们以width为例先，DOM的宽度有三类：</p>
<ul>
<li>clientWidth:：内容的width+padding</li>
<li>offsetWidth:：内容width+padding+border</li>
<li>scrollWidth：包括由于overflow溢出而在屏幕上不可见的内容宽度。如果没有出现水平滚动条，可以认为等于clientWidth。</li>
</ul>
<p>当然行内元素的宽度都是0。zepto返回的元素宽度用的是scrollWidth。</p>
<p>除此之外，也可以通过el.getBoundingClientRect方法获取，它计算出的width等于右border-左border，看起来和offsetWidth一样。但是这个width是实际渲染出来的宽度，比如说附加了<code>transform:scale(1.5)</code>样式，对于offsetWidth是不会变的，而getBoundingClientRect方法返回的宽度会乘以1.5倍，是实际呈现为准。同理getBoundingClientRect方法返回的top也是从窗口上方开始到元素的border（不包含）为止的高度。如果该元素是可滚动，那么top也是可变的。</p>
<p><img src="/2020/09/05/从zepto说起/zhaorenjie/Documents/blog/source/_posts/从zepto说起/图片尺寸.jpeg" alt="图片尺寸" style="zoom:67%;"></p>
<center>偷了别人的图</center>

<p>上述宽度都是针对元素节点，如果是window，我们一般用innerWidth获取宽度，因为outerHeight往往包括了浏览器的任务栏和窗口高度等。如果是document，我们返回内容宽度即offsetWidth。</p>
</li>
</ol>
<h2 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h2><h3 id="offsetParent"><a href="#offsetParent" class="headerlink" title="offsetParent"></a>offsetParent</h3><p>返回第一个定位过的祖先元素，即祖先元素的的position不是static。DOM原声就有offsetParent属性，但是如果当元素隐藏起来的时候，offsetParent返回null，zepto返回的是body对象。</p>
<h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><p>offset方法类似getBoundingClientRect方法，获取元素的渲染后的width、height、top和left。如果元素既不是html（根据document.documentElement判断）也不在文档中，则返回<code>{top: 0, left: 0}</code>。之前有说过getBoundingClientRect返回的top指的是从窗口上方开始到元素的border为止（不包含）的高度，如果当前文档已滚动，那么取得的top是不准的，所以还要加上window.pageYOffset。</p>
<p>设置值的时候，不能直接赋予元素偏移值。</p>
<p><img src="/2020/09/05/从zepto说起/zhaorenjie/Documents/blog/source/_posts/从zepto说起/offsetParent.jpg" alt="offsetParent" style="zoom:50%;"></p>
<p>如上图所示，元素的偏移量会根据第一个定位过的祖先元素而变化，假设祖先元素的top为100，元素需要设置的top为100，如果直接设置，会导致最后的top为200。所以最终的偏移量应该减去祖先元素的偏移量才是正确的。如果元素的定位属性是<code>static</code>，则会将其改为<code>relative</code>定位，再相对于其正常文档流来计算。</p>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>position方法返回相对于第一个定位过的祖先元素的位置，即<code>{top: xx,left: xx}</code>。如果元素是body或者html节点直接返回<code>{top: 0, left: 0}</code>。</p>
<p>整体思路还是用当前元素相对于文档的位置减去第一个定位祖先元素相对于文档的位置，需要注意的是top从祖先元素的padding（包含）开始直到当前元素的border（包含）。</p>
<h3 id="scrollLeft-amp-amp-scrollTop"><a href="#scrollLeft-amp-amp-scrollTop" class="headerlink" title="scrollLeft &amp;&amp; scrollTop"></a>scrollLeft &amp;&amp; scrollTop</h3><p>取值的话可以直接通过scrollLeft属性，设置值的时候使用scrollTo或者scrollIntoViewIfNeeded方法，传入的第二个参数是<code>{behavior: smooth}</code>，表示平滑滚动，此时会多次触发scroll事件。也可以直接设置scrollLeft值，进行跳转。</p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。网上有个例子很形象，我直接摘抄过来：</p>
<p>有几个同事预计在周一会收取到快递，为签收快递，有两种办法：一是三个人在门口等待快递；二是让快递放在前台由前台代替接受。在现实当中，我们一般会采用第二种方法，让前台帮忙签收。在这里有两层含义：</p>
<ol>
<li>当前同事快递可以由前台代收，即文档中的DOM节点事件能够触发。</li>
<li>新来的同事快递也可以由前台代收，即文档中新增的DOM节点事件也能够触发。</li>
</ol>
<p>可以看到好处是有很多的，最直观的就是提高了效率，不用每个同事去处理快递。类比DOM也是一样的，不用DOM节点自己去添加监听事件，只需要有一个守门人就能够处理所有的事件，能提高浏览器的性能。</p>
<p>而这个守门人是谁呢，就是需要监听事件的父节点，极端来说可以看作根节点。因为事件默认是冒泡的，当触发事件时候，会从触发的节点开始逐级往上最终到达根节点，event.target表示触发事件的节点，我们再根据这个属性判断进行相应的操作。当然，也没有人这么傻会把根节点当作守门人，中途很有可能再被某个处理停止了。往往在父节点附加即可。</p>
<p>一般讨论时候都会用ul做例子，我们也来看：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"add"</span>&gt;</span>添加li<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span>dabai<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"2"</span>&gt;</span>xiaobai<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"3"</span>&gt;</span>middlebai<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>bai<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们想给li标签添加点击后显示起id事件，再给按钮添加增加li节点的事件。一般会这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = <span class="built_in">document</span>.getElementById(<span class="string">"wrapper"</span>);</span><br><span class="line"><span class="keyword">const</span> children = wrapper.getElementsByTagName(<span class="string">"li"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">  children[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  	alert(event.target.id);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"add"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, () =&gt; &#123;</span><br><span class="line">  wrapper.append(<span class="string">`&lt;li id=<span class="subst">$&#123;children.length&#125;</span>&gt;xixixi&lt;/li&gt;`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里的两个问题也是很明显：一个是需要遍历所有的li标签，假设有一百个我们就需要遍历一百次，很消耗性能；再一个就是点击按钮后添加的li节点并没有附加事件监听。</p>
<p>我们利用ul父节点做事件委托，所有的事件处理都在ul监听的事件中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wrapper.addEventListener(<span class="string">"click"</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> target = event.target;</span><br><span class="line">  <span class="keyword">if</span> (target.tagName.toLowerCase() === <span class="string">"li"</span>) &#123;</span><br><span class="line">  	alert(target.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>对evnet.target的标签名是否是li，是的话再去操作，也可以判断是否是div，去做其他操作。点击按钮增加后，也是可以弹出提示的。</p>
<p>这就是简单的事件委托，只需要在父节点监听事件即可。缺陷就有两点：</p>
<ol>
<li>中途的事件可能会停止冒泡，拦截了事件。</li>
<li>有些事件并不支持冒泡，比如focus和blur，下面我们来看zepto是怎么处理的。</li>
</ol>
<p>focus和blur事件虽然不支持冒泡，但他们有个兄弟事件是focusin和focusout，他们的执行顺序是：focus &gt; focus in &gt; blur &gt; focus out。所以有了替代事件。</p>
<p>mouseenter和mouseover也不支持冒泡事件，但是也可以用mouseover和mouseout来模拟，他俩是支持冒泡的。mouseevent中有个属性relatedTarget，表示相关目标节点。mouseover指向从哪里移动到的目标节点，mouseout指向的是目标节点移动到哪里。mouseover在目标节点上移动时候，relatedTarget指向的都是目标节点。所以判断relatedTarget为空或者不为目标节点和其子节点时，可以当作mouseenter和mouseover事件。</p>
<p>zepto实现了从创建事件 -&gt; 绑定事件 -&gt; 触发事件 -&gt; 移除事件的所有流程。</p>
<p>但是我看的版本中创建事件使用了createEvent方法，这在标准中已经过时，推荐用Event的构造器实例化事件，可以传入bubbles等参数表明是否冒泡。</p>
<p>绑定事件中如果传入了选择器，表明使用事件代理，这也说明在传入addEventListener的监听函数中，是会在我们传入的函数上封装一层。为了解绑事件，需要保存初始的函数，除此之外还需要保存事件名称和命名空间、选择器。所以事件绑定时候封装的对象会有以下参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">handler = &#123;</span><br><span class="line">  e: 事件名</span><br><span class="line">  ns：命名空间</span><br><span class="line">  fn: 注册的事件回调</span><br><span class="line">  sel: 筛选的selector</span><br><span class="line">  proxy：真正执行的代理方法</span><br><span class="line">  i：注册后的索引，方便删除</span><br><span class="line">  del：事件代理，用来判断是否需要在冒泡阶段执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 而真正执行的proxy方法如下所示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">handler.proxy = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 给事件打补丁</span></span><br><span class="line">        e = compatible(e)</span><br><span class="line">        <span class="keyword">if</span> (e.isImmediatePropagationStopped()) <span class="keyword">return</span></span><br><span class="line">        e.data = data</span><br><span class="line">        <span class="keyword">var</span> result = callback.apply(element, e._args == <span class="literal">undefined</span> ? [e] : [e].concat(e._args));	<span class="comment">// 可在event.data里面获取一开始传入的参数</span></span><br><span class="line">        <span class="keyword">if</span> (result === <span class="literal">false</span>) e.preventDefault(), e.stopPropagation()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法封装了事件是否需要继续冒泡和停止默认行为以及传入更多参数。</p>
<p>而真正的事件委托代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delegator = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> evt, match = $(e.target).closest(selector, element).get(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">if</span> (match &amp;&amp; match !== element) &#123;</span><br><span class="line">    evt = $.extend(createProxy(e), &#123;<span class="attr">currentTarget</span>: match, <span class="attr">liveFired</span>: element&#125;)</span><br><span class="line">    <span class="keyword">return</span> callback.apply(match, [evt].concat(slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>closest方法为目标元素逐级向上找到和selector匹配的祖先元素，边界为element。如果找到了匹配的元素，扩展currentTarget属性并执行回调函数。</p>
<p>在文档中事件触发，可以调用dispatchEvent方法。不太懂为什么碰到foucus事件时候，直接调用元素的focus方法。因为zepto返回对象并不一定都是DOM节点，如果不是的话，直接拿到该对象绑定的方法即上述所说的handler，然后调用，这样也会导致事件没有冒泡，毕竟也不是DOM节点嘛。</p>
<p>移除事件得看zepto对于绑定的数据结构。对于每个目标元素都有自增ID，事件也是个列表，里面的对象就是上述的handler。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handlers = &#123;</span><br><span class="line">	0: [handler],</span><br><span class="line">	1: [handler]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以取值的时候根据元素的自增id拿到事件列表，再过滤出对应事件删除索引即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://github.com/qianlongo/zepto-analysis" target="_blank" rel="noopener">zepto-analysis</a></li>
<li><a href="[https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8BEvent%E6%A8%A1%E5%9D%97.md](https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/读Zepto源码之Event模块.md">读Zepto源码之Event模块</a>)</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/31/Angular组件样式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/31/Angular组件样式/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-31T16:22:12+08:00">
                2020-08-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Angular组件样式"><a href="#Angular组件样式" class="headerlink" title="Angular组件样式"></a>Angular组件样式</h1><p>最近遇到了在动态创建模板时候，样式无法附加上去的问题。研究了一下，发现和Angular视图封装模式有关，我们先来模拟一下这个情况：</p>
<!-- read more -->
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html模板</span></span><br><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">"container"</span>&gt;</span><br><span class="line">	&lt;ng-template #container&gt;&lt;<span class="regexp">/ng-template&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;ng-template #msgTpl&gt;</span><br><span class="line">	&lt;div <span class="keyword">class</span>=<span class="string">"msg"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>ng-template&gt;</span><br><span class="line"><span class="comment">// component</span></span><br><span class="line"><span class="meta">@ViewChild</span>(<span class="string">"msgTpl"</span>) <span class="keyword">private</span> msgTpl: TemplateRef&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"><span class="meta">@ViewChild</span>(<span class="string">"container"</span>, &#123; read: ViewContainerRef &#125;)</span><br><span class="line"><span class="keyword">private</span> container: ViewContainerRef;</span><br><span class="line"></span><br><span class="line">createMsg() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; container, msgTpl &#125; = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> view = container.createEmbeddedView(msgTpl);</span><br><span class="line">  view.rootNodes[<span class="number">0</span>].innerHTML = <span class="string">`&lt;span class="timestamp"&gt;&lt;b&gt;14:17:52&lt;/b&gt;123 `</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>container是放入模板的容器位置，msgTpl就是模板。创建模板时，我们直接对<code>div</code>节点赋予了html字符串，然而我在css里面定义了<code>timestamp</code>类的背景色，并未生效。具体代码可看<a href="https://stackblitz.com/edit/angular-version-79muv9" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="视图封装模式"><a href="#视图封装模式" class="headerlink" title="视图封装模式"></a>视图封装模式</h2><p>根据Angular文档，组件的样式封装一共有三种：</p>
<ol>
<li><code>Native</code>：使用浏览器原生的<code>Shadow DOM</code>，这种模式下，外界无法入侵组件，组件的样式也无法影响到外界。</li>
<li><code>None</code>：不再封装样式，就和原始开发模式一样，相同的选择器样式会互相覆盖。</li>
<li><code>Emulated</code>：这也是默认封装模式，组件样式无法影响到外界，但是外界样式可以入侵组件。</li>
</ol>
<p>可以在组件元数据中的<code>encapsulation</code> 属性来设置组件封装模式：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">encapsulation: ViewEncapsulation.Native</span><br></pre></td></tr></table></figure>
<p>我们以上述例子着重来分析第三种封装模式，可以看到<code>div</code>节点的选择器多了一些东西，而<code>timestamp</code>并无变化。</p>
<p><img src="/2020/08/31/Angular组件样式/zhaorenjie/Documents/blog/source/_posts/Angular组件样式/无法渲染msg.jpeg" alt="无法渲染msg" style="zoom: 50%;"></p>
<p>这说明仿真模式其实是对DOM节点设置了属性，属性名采用了自增ID以防止名字的冲突。那么为什么<code>timestamp</code>类并后面没有紧跟属性选择器呢？思考一下，Angular是需要经过编译的，样式代码应该在编译过程中会被替换成<code>_ngcontent-xxx</code>格式，而HTML模板编译出来的组件工厂 <code>xx.ngfactory.js</code>会在内部创建节点的过程中设置相同名称的属性。但是我们动态创建的模板直接对html属性赋值字符串的，并没有走Angular内部的创建节点过程，所以导致节点并没有设置属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 编译出来的css --&gt;</span></span><br><span class="line">.msg[_ngcontent-xx] &#123;</span><br><span class="line">	.timestamp &#123;</span><br><span class="line">		xxx</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">&lt;!-- html动态生成后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">_ngcontent-xxx</span> <span class="attr">class</span>=<span class="string">"msg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 赋值了html字符串后,没有设置上属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">_ngcontent-xxx</span> <span class="attr">class</span>=<span class="string">"msg"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"timestamp"</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">span</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么该如何解决这个问题呢？我们再来想平时使用的<code>:host</code>选择器和<code>::ng-deep</code>伪类的作用，当加上<code>:host ::ng-deep</code>选择器后，如果子组件也是仿真模式，那么父组件只要样式权重较大就可以覆盖子组件的样式。而如果直接以<code>::ng-deep</code> 伪类的选择器，按照Angular文档的解释，会完全禁止css样式的包装，从而变成全局样式。我们给msg类分别添加两种选择器看看。</p>
<p>可以看到组件标签会设置<code>_nghost-xxx</code>属性，而子节点都设置了<code>_ngcontent-xxx</code>属性。当带有<code>:host</code>样式时候，样式选择器也会添加属性前缀，而不再是<code>_ngcontent-xx</code>属性选择器，所以父组件才能入侵子组件的样式。而<code>:ng-deep</code>则完全没有变化，没有添加任何选择器，这样的缺点很明显，失去了封装意味着冲突，但是在弹层之类的组件却很有效。</p>
<p>回到之前的问题，<code>timestamp</code>类样式无法附加上，因为他没有<code>_ngcontent</code>前缀。但是刚刚分析<code>::ng-deep</code> 伪类不会对其包装，所以我们只需要在<code>timestamp</code>类添加<code>::ng-deep</code>前缀样式即可生效，验证后成功！</p>
<p>完整代码请看<a href="https://stackblitz.com/edit/angular-version-jfm2fw" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>下面我们来看下源码，首先搜索<code>ngcontent</code>关键词，发现了在<code>dom_renderer</code>文件中有<code>_ngcontent-${COMPONENT_VARIABLE}</code>的正则，并且代码也有和封装模式的枚举有关，看来要找的就是这个文件了。其次，我们对css文件编译，使用<code>.node_modules/.bin/ngc</code>就可以得到组件工厂文件了看一下不同的选择器产生的结果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 源代码																			// 编译结果</span><br><span class="line">.container &#123;																	.container[_ngcontent-%COMP%] &#123;&#125;</span><br><span class="line">	<span class="selector-tag">xx</span>											<span class="selector-tag">----</span>&gt;										<span class="selector-tag">xx</span></span><br><span class="line">&#125;																							&#125;</span><br><span class="line">:host ::ng-deep &#123;															.container [_ngcontent-%COMP%] &#123;</span><br><span class="line">	.container &#123;					  ----&gt;										.timestamp &#123;&#125;</span><br><span class="line">		<span class="selector-class">.timstamp</span> &#123;&#125;															&#125;		</span><br><span class="line">	&#125;											</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">:host</span> &#123;</span><br><span class="line">	.container &#123;						----&gt;								.container [_ngcontent-%COMP%] &#123;</span><br><span class="line">		<span class="selector-class">.timstamp</span> &#123;&#125;																	<span class="selector-class">.timestamp</span> <span class="selector-attr">[_ngcontent-%COMP%]</span> &#123;&#125;</span><br><span class="line">	&#125;																						&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::ng-deep</span> &#123;</span><br><span class="line">	.container &#123;&#125;					  ----&gt;								.container &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">:host-context(p) &#123;														p [_nghost-%COMP%] &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;&#125;						<span class="selector-tag">----</span>&gt;									<span class="selector-class">.container</span> &#123;&#125;</span><br><span class="line">  &#125;																						&#125;</span><br></pre></td></tr></table></figure>
<p>我们都知道Angular不提倡使用原生的方法去操作DOM节点（DOM节点也不建议操作），而是调用<code>renderer2</code>对象去操作，它里面的方法基本覆盖了常用操作，如设置属性、样式和类名等等。这是因为在不同的平台，DOM的操作的api并不是一样的，比如在浏览器端可以直接使用document，而在服务端渲染时并没有document，而是使用了<code>domino</code>库模拟了document。所以如果需要跨平台，最好是调用<code>renderer2</code>对象操作，同理还有<code>DOCUMENT</code>对象等。</p>
<p>不过我们今天的关注并不在此，因为我们只需要看浏览器端的调用即可。Renderer2只会在创建组件的时候才会调用，子节点的创建会调用内部的<code>createElement</code>方法。在<code>DomRendererFactory2</code>类中使用了策略模式根据不同的类型创建Renderer2。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ViewEncapsulation.Emulated: &#123;</span><br><span class="line">  <span class="keyword">let</span> renderer = <span class="keyword">this</span>.rendererByCompId.get(<span class="keyword">type</span>.id);</span><br><span class="line">  <span class="keyword">if</span> (!renderer) &#123;</span><br><span class="line">    renderer = <span class="keyword">new</span> EmulatedEncapsulationDomRenderer2(</span><br><span class="line">      <span class="keyword">this</span>.eventManager, <span class="keyword">this</span>.sharedStylesHost, <span class="keyword">type</span>, <span class="keyword">this</span>.appId);</span><br><span class="line">    <span class="keyword">this</span>.rendererByCompId.set(<span class="keyword">type</span>.id, renderer);</span><br><span class="line">  &#125;</span><br><span class="line">  (&lt;EmulatedEncapsulationDomRenderer2&gt;renderer).applyToHost(element);</span><br><span class="line">  <span class="keyword">return</span> renderer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> EmulatedEncapsulationDomRenderer2&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">      eventManager: EventManager, sharedStylesHost: DomSharedStylesHost,</span></span><br><span class="line"><span class="params">      <span class="keyword">private</span> component: RendererType2, appId: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(eventManager);</span><br><span class="line">    <span class="keyword">const</span> styles = flattenStyles(appId + <span class="string">'-'</span> + component.id, component.styles, []);</span><br><span class="line">    sharedStylesHost.addStyles(styles);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.contentAttr = shimContentAttribute(appId + <span class="string">'-'</span> + component.id);</span><br><span class="line">    <span class="keyword">this</span>.hostAttr = shimHostAttribute(appId + <span class="string">'-'</span> + component.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部有个缓存，键值是组件的id。编译器生成出工厂文件就会带有id，也可以理解为是自增ID。没有击中缓存的话，就会实例化<code>EmulatedEncapsulationDomRenderer2</code>对象，再放入缓存中。在构造器中，利用正则取得组件的<code>host</code>和<code>content</code>的名称，也就是之前所说nghost-xxx和ngcontent-xxx的后缀。有了host名称后，就可以设置组件属性。然后再用正则替换样式，并创建style标签，添加到head标签内。我们可以看到仿真对象的<code>createElement</code>方法，它会先创建DOM子节点，再对子节点设置content名称属性。这样就验证了我们之前的想法。</p>
<p>最后来看影子DOM的封装，就是调用了浏览器的<code>attachShadow</code>方法实现。它不缓存组件的rendere2对象，因为每次创建影子DOM，都会产生新的影子节点，如果缓存就会产生冲突。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上我们可以学习到Angular的视图封装模式：</p>
<ol>
<li>通过编译改变了带有特定选择器如:host的样式代码。</li>
<li>对组件标签设置nghost属性，对组件内部节点设置ngcontent属性。</li>
</ol>
<p>回到之前的问题，其实我们还有一种方法修正，可以创建动态组件，再在父组件中设置</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:host</span> <span class="selector-pseudo">::ng-deep</span> &#123;</span><br><span class="line">	.timestamp &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为只会改变最外层的样式代码，timestamp仍然会附加到子组件样式上。具体代码请看<a href="https://stackblitz.com/edit/angular-version-istypu" target="_blank" rel="noopener">这里</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/19/underscore源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/19/underscore源码解析/" itemprop="url">underscore源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-19T09:43:57+08:00">
                2020-08-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="underscore源码解析"><a href="#underscore源码解析" class="headerlink" title="underscore源码解析"></a>underscore源码解析</h1><p>undersocre是一个 JavaScript 工具库，它提供了一整套函数式编程的实用功能，但是没有扩展任何 JavaScript 内置对象。其中提供了100多个函数，包括常用的：<strong>map</strong>、<strong>filter</strong>、<strong>invoke</strong> — 当然还有更多专业的辅助函数，如：函数绑定、JavaScript 模板功能、创建快速索引、强类型相等测试等等。</p>
<p>我之前用underscore较少，所以在看这种源码的时候，最好自己根据文档实现所有的函数，再去跑一遍测试用例，出错后根据用例修正代码，最后看源码解析，这样体会就比较深。underscore采用了qunit测试框架，用法较为简单。</p>
<!-- readmore -->
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>underscore提供的基本是函数式编程风格的函数，比如使用map函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.map([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], x =&gt; x + <span class="number">1</span>);	<span class="comment">// 输出 2 3 4</span></span><br></pre></td></tr></table></figure>
<p>它同时也支持面向对象风格的编程，仍然是map方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>)	</span><br><span class="line"><span class="comment">// _([1,2,3])返回了一个对象，该对象包含了undersocre的所有方法和Array的部分方法</span></span><br></pre></td></tr></table></figure>
<p>undersocre的面向对象也支持链式调用，调用完方法后都返回新的对象，直到调用value方法取得最终的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.chain([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>).filter(x % <span class="number">2</span> === <span class="number">0</span>).value();	<span class="comment">// 输出 2 4</span></span><br></pre></td></tr></table></figure>
<p>这种思想我们可以借鉴到任何库中，是个很酷的黑科技。</p>
<p>首先链式调用基本就是每个方法能够返回对象本身，对于underscore而言，大部分方法都是静态的函数，直接挂载在<code>_</code>变量，而不是其原型链，无法通过<code>return this</code>返回实例。</p>
<p>underscore中有个mixin函数，传递<code>{name: function}</code>格式参数，会将函数挂载到<code>_</code>变量和原型链上。也就是说我们可以通过<code>_.mixin(_)</code>将 <code>_</code>内部的静态方法挂载在其原型链上，同时如果我们传入自定义的函数，也会挂载。</p>
<p>其次当调用完实例方法后，我们将返回值作为参数再次创建<code>_</code>实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_</span>(<span class="params">wrapped</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span> <span class="keyword">instanceof</span> _) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _(wrapped);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.wrapped = wrapped;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.test = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.parse = <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.prototype.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.wrapped;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.mixin = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i];</span><br><span class="line">    _.prototype[key] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> func = obj[key];</span><br><span class="line">      <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">      args.unshift(<span class="keyword">this</span>.wrapped);</span><br><span class="line">      <span class="keyword">const</span> result = func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _(result);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.mixin(_);</span><br><span class="line"><span class="built_in">console</span>.log(_(<span class="string">"123"</span>).test().parse().value());</span><br></pre></td></tr></table></figure>
<p>如上所述，当方法挂载在原型链上时候，我们都返回一个新的对象，就可以实现链式调用了。<code>value</code>方法不应该暴露在静态方法，因为作为静态方法时完全没有意义，只会返回<code>undefined</code>。</p>
<p>最后调用实例方法有时候想直接返回结果，有时候需要链式调用，所以这里增加<code>_chain</code>方法表示调用该方法后将会返回对象，直到调用value方法。完整的可见<a href="https://codepen.io/ccanister/pen/BajvMwg?editors=1111" target="_blank" rel="noopener">这里</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_.chain = <span class="function"><span class="keyword">function</span> (<span class="params">wrapped</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="keyword">new</span> _(wrapped);</span><br><span class="line">  obj._chain = <span class="literal">true</span>;	<span class="comment">// 标识符</span></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.mixin = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ....</span></span><br><span class="line">  _.prototype[key] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> func = obj[key];</span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">    args.unshift(<span class="keyword">this</span>.wrapped);</span><br><span class="line">    <span class="keyword">const</span> result = func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._chain ? _.chain(result) : result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h2><h3 id="result"><a href="#result" class="headerlink" title="result"></a>result</h3><p>_.result(obj, property, fallback)函数的实现我觉得在整个库中是最巧的。它的定义是：obj对象的属性property如果是函数就调用它，如果是undenfined就去查看fallback属性，如果是函数也去调用，否则返回。其中property可能是数组，那么就去遍历调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  w: <span class="string">"x"</span>,</span><br><span class="line">  x: &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;,</span><br><span class="line">  y: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.result(obj, <span class="string">"z"</span>, <span class="string">"w"</span>)	<span class="comment">// x</span></span><br><span class="line">_.result(obj, [<span class="string">"w"</span>, <span class="string">"z"</span>], <span class="string">"w"</span>)	<span class="comment">// x</span></span><br><span class="line">_.result(obj, [<span class="string">"y"</span>, <span class="string">"a"</span>])	<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>我一开始的想法是假设property是个数组，就排除掉最后一个元素，以适应property是单个值的情况，这样的话会导致遍历完property还再需要判断一遍obj[property]是否有值情况。其实刚好相反，应该把单个值和数组情况合并成数组情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">result</span>(<span class="params">obj, path, fallback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isArray(path)) path = [path];</span><br><span class="line">  <span class="keyword">var</span> length = path.length;</span><br><span class="line">  <span class="keyword">if</span> (!length) &#123;</span><br><span class="line">    <span class="keyword">return</span> isFunction(fallback) ? fallback.call(obj) : fallback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> prop = obj == <span class="literal">null</span> ? <span class="keyword">void</span> <span class="number">0</span> : obj[path[i]];</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">      prop = fallback;</span><br><span class="line">      i = length; <span class="comment">// 这里设为length，既可以跳出循环，又可以调用下面方法。</span></span><br><span class="line">    &#125;</span><br><span class="line">    obj = isFunction(prop) ? prop.call(obj) : prop;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><p>该方法也是backbone的模板引擎方实现。所谓的模板也就是html嵌套了一些动态数据，需要用上下文去渲染。比如下面代码片段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;% <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> people) &#123;%&gt;</span><br><span class="line">    &lt;li&gt;&lt;%= people[key].name %&gt;&lt;%- people[key].action %&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp"> 	&lt;% &#125; %&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>
<p>有几种模板方式：</p>
<ol>
<li>&lt;% … %&gt; - 需要执行的代码。</li>
<li>&lt;%= … %&gt; - 会嵌套在html中的语句。</li>
<li>&lt;%- … &gt; - 需要转义HTML的字符串。</li>
</ol>
<p>当然也可以用自己的风格去替换模板。</p>
<p>其中最难的是模板的上下文是怎么获取，后来查了一下发现有with关键词。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (expression) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">with</span>(data) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">with</span>(data) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在statement代码块中，expression的作用域优先级最高。demo中两个写法都可以正确输出1，这样就会给人造成困扰，这货到底从哪里来的呢。所以es严格模式中仅用了该关键词，但是他是实现template方法的不二之选。</p>
<p>其次是如何处理模板的问题，比如上述的demo，我们是可以转换成下面的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">with</span>(people) &#123;</span><br><span class="line">  result += <span class="string">"&lt;ul&gt;"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> people) &#123;</span><br><span class="line">    result += <span class="string">"&lt;li&gt;"</span>;</span><br><span class="line">    result += people[key].name;</span><br><span class="line">    result += _.escape(p);</span><br><span class="line">    result += <span class="string">"&lt;/li&gt;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result += <span class="string">"&lt;/ul&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>所以的代码都是被包裹在with语句执行的，以便取得上下文变量。&lt;%%&gt;可以直接输出到result中，&lt;%-%&gt;需要转义再输出到result，&lt;%= %&gt;则是直接当做代码语句执行，在这些模板之间的字符串也是直接输出到result中。</p>
<p>有了以上信息，我们要做的工作就是如何匹配替换模板，显然易见的就是正则表达式。有一点需要注意的是匹配&lt;%%&gt;时，自然想到的是<code>/&lt;%=([\s\S])%&gt;/g</code>，这样的话直接匹配到了最后一个%&gt;，例如&lt;%=a%&gt;&lt;%=b%&gt;，匹配了b后面的%&gt;。这是因为正则默认贪婪模式，我们需要在后面添加+?启用非贪婪模式：<code>/&lt;%=([\s\S]+?)%&gt;/g</code>。</p>
<h2 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h2><p><code>toArray</code>方法中有个正则是这么写的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reStrSymbol = <span class="regexp">/[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g</span>;</span><br></pre></td></tr></table></figure>
<p>一开始看到这个正则很懵逼，因为他是用来切割字符串的，直接想法就是<code>split(&quot;&quot;)</code>。</p>
<p>然后去看测试用例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> hearts = <span class="string">"\uD83D\uDC95"</span>;</span><br><span class="line"> <span class="keyword">var</span> pair = hearts.split(<span class="string">""</span>);</span><br><span class="line"> <span class="keyword">var</span> expected = [pair[<span class="number">0</span>], hearts, <span class="string">"&amp;"</span>, hearts, pair[<span class="number">1</span>]];	<span class="comment">// ["�", "💕", "&amp;", "💕", "�"]</span></span><br><span class="line"> assert.deepEqual(</span><br><span class="line">   _.toArray(expected.join(<span class="string">""</span>)),</span><br><span class="line">   expected,</span><br><span class="line">   <span class="string">"maintains astral characters"</span></span><br><span class="line"> );</span><br><span class="line"><span class="comment">// 如果我们直接split("")就会输出["�", "�", "�", "&amp;", "�", "�", "�"]</span></span><br></pre></td></tr></table></figure>
<p>这可真是一脸懵逼，为啥输出了一堆非法字符。</p>
<p>我们再来看这个正则是以\u开头，应该是和utf编码有关，所以我们带着疑惑去网上搜索了下utf编码。</p>
<h3 id="ASCII码说起"><a href="#ASCII码说起" class="headerlink" title="ASCII码说起"></a>ASCII码说起</h3><p>我们在学校学C语言的时候，了解到在计算机内部由于电路，我们将所有信息都展示成二进制的字符串，每一个二进制位有0和1两种状态，通过不同的排列组合，我们就可以表示所有东西。</p>
<p>同时，1字节对应8位二进制数，所以1字节可以表示256种状态。在早期的计算机，需要表示的字符并不多，1字节远远足够，所以ASCII码由此诞生，只有128个字符，最高位均是0，包括了英文字母和数字、一些标点符号和控制符号等。</p>
<p>随着计算机的推广，越来越多的国家开始使用计算机。但是ASCII码只能表示128位字符，这对于其他国家肯定不够呀。所以有的国家对后128位字符下手了，比如144在阿拉伯人的ASCII码中是گ，而在俄罗斯的 ASCII 码中是 ђ。而对于中国，单单常常用的中文就有6000多个了，哪是单单127个字符容得下？于是我们采取了以下两个措施：</p>
<ol>
<li>小于127的字符保持原义，两个大于127的字符连在一起时候代表了汉字。</li>
<li>前面字节（高位）从0xA1到0xF7，后面字节（低位）从0xA1到0xFE。</li>
</ol>
<p>这样我们就大约组合出7000多个简体字了，例如“汉”字就会被编码成BABA。</p>
<p>在这种编码方式中，我们把数学符号、罗马希腊字母和ASCII码中原有的数字和标点符号等都变成两字节编码，这也就是全角字符。而ASCII码红小于127的字符被称作半角字符。</p>
<p>这种编码方式被称为GB2312，其实就是对ASCII码的中文扩展。</p>
<p>再到后来，需要支持的汉字越来越多，就不再对后面字节（低位）限制，只要前面字节（高位）大于127，就意味着这是汉字的开始，不管后面跟着什么内容。这样又可以多了2000个左右汉字。这种编码方式就是GBK。</p>
<p>因为全世界都像我们推出自己的编码方式，想要看懂其他国家的编码，还要安装相关支持。由此美国人推出了unicode字典。它映射了世界上的所有字符对应的数字，例如”汉”字，他的unicode码点是0x6c49。unicode采用了分区定义：</p>
<ol>
<li>目前定义17个平面，每个平面可以有65536个（2^16）字符。</li>
<li>1个基本面：常见字符都存放在这里，U+0000~U+FFFF。</li>
<li>16个辅助平面：U+010000~U+10FFFF。</li>
</ol>
<p>注意的是，“汉”字如何在计算机中存储是没有明确规定的，unicode字典只是存储了映射关系。比如说“汉”的unicode是0x6c49，意味着至少需要两字节；而A的unicode则是0x0041。这里有个很明显的问题，那就是如果统一规定每个符号采用3个字节或者4个字节，对于英文字母来说就是浪费了。这也就是utf-32编码采取的方式，规定所有字符都用4个字节表示，造成了很大的浪费。但是如果你不采取这种方式，那么计算机如何区分unicode和ASCII呢，即它咋知道3个字节可以表示一个符号呢？</p>
<p>于是出现了utf-8和utf-16编码方式。我们先来看utf-8编码，它是一种可变的编码方式，根据不同的符号使用1～4字节来表示。</p>
<table>
<thead>
<tr>
<th style="text-align:left">unicode符号范围</th>
<th>UTF-8编码方式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0000  0000 - 0000  007F</td>
<td>0xxxxxx</td>
</tr>
<tr>
<td style="text-align:left">0000  0080 - 0000  07FF</td>
<td>110xxxxx  10xxxxxx</td>
</tr>
<tr>
<td style="text-align:left">0000  0800 - 0000  FFFF</td>
<td>1110xxxx  10xxxxxx. 10xxxxxx</td>
</tr>
<tr>
<td style="text-align:left">0001  0000 - 0010  FFFF</td>
<td>11110xxx  10xxxxxx  10xxxxxx. 10xxxxxx</td>
</tr>
</tbody>
</table>
<p>我们可以看出，对于单字节而言，首位被设为0，后面7位是Unicode码，所以可以认为ASCII码和utf-8编码方式一致。对于多字节而言，第一个字节的前n位是1，n+1位是0，后面字节前两位都是10。</p>
<p>还是“汉”这个字，unicode是0x6c49，处在第三行的范围中，因此它需要三个字节即1110xxxx  10xxxxxx  10xxxxxx。从“汉”的二进制最后一位开始补充到格式的x中，多出的补0。最后得到的utf-8编码就是11100110 10110001 10001001，即e6b189。</p>
<p>再来看utf-16编码，它结合了定长和变长的两种编码方式，即：基本面的字符占用2个字[U+0000-U+FFFF]，辅助平面的字符占用4个字节[U+010000-U+10FFFF]。那么我们遇到2个字节的时候，是把它当作一个字符，还是把它和后面2个字节一起当作一个字符？</p>
<p>这里终于出场了和正则有关的unicode编码。在基本平面中，从U+D800到U+DFFF是一个空段，不会以对应任何字符，因此这个空段可以映射辅助平面的字符。辅助平面一共会有2^4 * 2^16共2^20个字符位，所以至少需要20个进制位。前十位会映射到<strong>U+D800到U+DBFF</strong>，后十位会映射到<strong>U+DC00到U+DFFF</strong>。这意味着一个辅助平面的字符会被拆成两个辅助平面的字符。当我们遇到第一个字节码点在U+D800到U+DBFF时候，可以断定第二个字节在U+DC00到U+DFFF中，这四个字节必须一起解析。</p>
<p>我们看“𠯆”这个字的码点是0x20BC6，该码点明显属于辅助平面，所以需要4个字节表示。首先用0x20BC6-0x10000计算出超出的部分为0x10BC6，用20位二进制表示，不足高位补0，最后为00010000101111000110，再将前10位映射到U+D800到U+DBFF段，即U+D800+0001000010=0xd842，后10位映射到U+DC00到U+DFFF，即U+DC00+1111000110=0xDFC6。这样得出汉字“𠯆”的utf-16编码为0xd8420xDFC6。unicode提供的公式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H = <span class="built_in">Math</span>.floor((c<span class="number">-0x10000</span>) / <span class="number">0x400</span>)+<span class="number">0xD800</span>	<span class="comment">// 除以0x400 就是将其右移10位</span></span><br><span class="line">L = (c - <span class="number">0x10000</span>) % <span class="number">0x400</span> + <span class="number">0xDC00</span></span><br></pre></td></tr></table></figure>
<p>那么这是不是意味着js是采用了utf-16编码呢，事实上js诞生之初还没有utf-16编码，只有UCS-2编码。UCS-2编码全都使用了2个字节表示字符，因为那时候字符都处在基本平面，所以2个字节够用。到后来utf-16编码出现后，就取代了USC-2编码，可以理解后者是前者的子集。</p>
<p>也就是说js并不认识辅助平面的字符。我们回过头来看测试用例中的”\uD83D\uDC95”字符，明显处在辅助平面，如果我们将其先转成字符串，再重新切割回数组，因为并没有对这个字符进行两字节合并处理，而是直接切割成[“\uD83d”, “\uDC95”]，而这两个字符又没有字典映射，所以就会变成[“�”, “�”]。所以字符串的有关操作，都要对辅助平面特殊处理，需要两字节合并读取。</p>
<p>那么显而易见这个正则表达式，就是为了处理辅助平面。处于第一个和最后一个的正则都是识别基本平面，中间则是识别辅助平面。更紧凑的方式是<code>/[\ud800-\udbff][\udc00-\udfff]|[\s\S]/g</code>。</p>
<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p>通常函数的调用过程分成3个部分：请求（调用）、执行和响应（返回）。在某些场景下，比如响应鼠标移动或者窗口调整大小事件等，出发频率比较频繁。如果处理函数比较复杂，会造成响应速度跟不上调用频率，往往会出现延迟响应，给人造成假死或者卡顿感觉。</p>
<p>因为浏览器资源通常是固定的，不能通过加机器等去提高我们的处理速度。那么退而求其次，我们只响应部分请求，抛弃不必要的响应，能有力提升用户体验。</p>
<p>throttle和debounce就是解决请求和响应速度不匹配的问题。</p>
<h3 id="电梯问题"><a href="#电梯问题" class="headerlink" title="电梯问题"></a>电梯问题</h3><p>想象每天运行的电梯。电梯完成一次运送就是一次函数调用和响应。现在电梯有两种运行策略throttle和debounce，超时时间都设为10s。</p>
<ol>
<li>throttle每次只载一个人，上来一个人之后就开始拒载，直到完成本次运送，再重新开放。当有人在电梯内，下一个人要求上来时，我们可以选择不管其请求或者等到本次运送结束后再去载他。前后两人时间差至少为10s.</li>
<li>debounce当有人要求上电梯时，会放他进来，直到10s内没人要求进来。</li>
</ol>
<p>throttle使用示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 控制台记录窗口滚动事件，触发频率比你想象的要快</span></span><br><span class="line">$(<span class="built_in">window</span>).scroll( log );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台记录窗口滚动事件，每250ms最多触发一次</span></span><br><span class="line">$(<span class="built_in">window</span>).scroll( _.throttle( log, <span class="number">250</span> ) );</span><br></pre></td></tr></table></figure>
<p>debounce使用示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符输入的频率比你预想的要快，Ajax 请求来不及回复。</span></span><br><span class="line">$(<span class="string">'input:text'</span>).keyup( ajax_lookup );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当用户停顿250毫秒以后才开始查找</span></span><br><span class="line">$(<span class="string">'input:text'</span>).keyup( _.debounce( ajax_lookup, <span class="number">250</span> ) );</span><br></pre></td></tr></table></figure>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h4><p>先贴出自己的代码，不管options参数，当延时时间小于上次执行到现在的间隔时间时候，应该立刻去调用函数。所以内部应该有个变量标志是否能够立即执行的时间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer, result, end;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> throttleFun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (!end || end &lt; +<span class="keyword">new</span> <span class="built_in">Date</span>()) &#123;	<span class="comment">// 当end  &lt; +new Date()时意味着时间间隔到了</span></span><br><span class="line">      result = func.apply(<span class="literal">null</span>, args);</span><br><span class="line">      end = wait + +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timer) &#123;	<span class="comment">// 防止重复设定计时器。</span></span><br><span class="line">      timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        end = wait + +<span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 用来判断下次可直接执行的时间</span></span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">        result = func.apply(<span class="literal">null</span>, args);</span><br><span class="line">      &#125;, end - +<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我有个很纠结的点，来看测试用例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">QUnit.test(<span class="string">"throttle repeatedly with results"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">assert</span>) </span>&#123;</span><br><span class="line">    assert.expect(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">var</span> done = assert.async();</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> incr = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ++counter;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> throttledIncr = _.throttle(incr, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">var</span> results = [];</span><br><span class="line">    <span class="keyword">var</span> saveResult = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      results.push(throttledIncr());</span><br><span class="line">    &#125;;</span><br><span class="line">    saveResult();	<span class="comment">// 此时end为void 0，立即执行。</span></span><br><span class="line">    saveResult();	<span class="comment">// 重新上来一个人，我们设定100ms后执行</span></span><br><span class="line">    _.delay(saveResult, <span class="number">60</span>);	<span class="comment">// 已有定时器，忽略</span></span><br><span class="line">    _.delay(saveResult, <span class="number">110</span>);	<span class="comment">// 就在这里，此时上个函数执行后过了10ms，仍在wait间隔内。我一开始以为是在100ms后也就是第210ms时执行，事实上我们看设置定时起的时间参数end - +new Date()，也就是90ms后执行，也就是函数执行完后10s内不能再次执行函数，而不是调用throttle后10s内不能再执行。</span></span><br><span class="line">    _.delay(saveResult, <span class="number">190</span>);	<span class="comment">// 已有定时器，忽略</span></span><br><span class="line">    _.delay(saveResult, <span class="number">230</span>);	<span class="comment">// 设置了70ms后执行。</span></span><br><span class="line">    _.delay(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      assert.strictEqual(results[<span class="number">0</span>], <span class="number">1</span>, <span class="string">"incr was called once"</span>);</span><br><span class="line">      assert.strictEqual(results[<span class="number">1</span>], <span class="number">1</span>, <span class="string">"incr was throttled"</span>);</span><br><span class="line">      assert.strictEqual(results[<span class="number">2</span>], <span class="number">1</span>, <span class="string">"incr was throttled"</span>);</span><br><span class="line">      assert.strictEqual(results[<span class="number">3</span>], <span class="number">2</span>, <span class="string">"incr was called twice"</span>);</span><br><span class="line">      assert.strictEqual(results[<span class="number">4</span>], <span class="number">2</span>, <span class="string">"incr was throttled"</span>);</span><br><span class="line">      assert.strictEqual(results[<span class="number">5</span>], <span class="number">3</span>, <span class="string">"incr was called trailing"</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(counter)</span><br><span class="line">      done();</span><br><span class="line">    &#125;, <span class="number">300</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>underscore源码没有提前计算end，而是计算剩余时间，且有个<code>remaining &gt; wait</code>判断语句，网上说是可能是系统时间被调整了，导致被立即执行，所以该语句块里面会重置计时器。</p>
<h4 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer, result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> debouncFun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="keyword">const</span> callNow = timer == <span class="literal">null</span>;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait);</span><br><span class="line">      <span class="keyword">if</span> (callNow) &#123;	<span class="comment">// 如果递归调用debounceFun，没有该变量，就会直接重复执行func，导致答案不对</span></span><br><span class="line">        result = func();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    debouncFun.cancel();	<span class="comment">// 取消之前的定时器</span></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      func();</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;, wait);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  debouncFun.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> debouncFun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于callNow这个变量，如果我们不需要的话就会造成以下这个问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不设置callNow写法</span></span><br><span class="line"> <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">   <span class="keyword">if</span> (timer == <span class="literal">null</span>) &#123;</span><br><span class="line">     result = func();</span><br><span class="line">   &#125;</span><br><span class="line">   timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     timer = <span class="literal">null</span>;</span><br><span class="line">   &#125;, wait);</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> debouncedIncr = debounce(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="keyword">if</span> (counter &lt; <span class="number">10</span>) debouncedIncr();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">32</span>,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br><span class="line">debouncedIncr();	<span class="comment">// 输出10</span></span><br><span class="line"><span class="built_in">console</span>.log(counter);</span><br><span class="line">delay(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(counter);	<span class="comment">// 输出10</span></span><br><span class="line">&#125;, <span class="number">96</span>);</span><br></pre></td></tr></table></figure>
<p>因为一直在递归调用，本来该输出1。但是由于我们先执行传入的函数，再去设置timer，就会导致永远进不到设置timer这步。</p>
<h3 id="可视化演示"><a href="#可视化演示" class="headerlink" title="可视化演示"></a>可视化演示</h3><p>下面是分别是不加任何修饰的滚屏，加了节流的的滚屏以及加了防抖的滚屏。</p>
<p><img src="/2020/08/19/underscore源码解析/zhaorenjie/Documents/blog/source/_posts/underscore/nothing.gif" alt="nothing"></p>
<center>正常滚动屏幕</center>

<p><img src="/2020/08/19/underscore源码解析/zhaorenjie/Documents/blog/source/_posts/underscore/debounce.gif" alt="debounce"></p>
<center>加了debounce后，停止滚动几百毫秒后，数字才加一</center>

<p><img src="/2020/08/19/underscore源码解析/zhaorenjie/Documents/blog/source/_posts/underscore/throttle.gif" alt="throttle"></p>
<center>加了throttle后，每隔一段时间数字就会加一</center>

<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><p>js有7种类型：number、boolean、string、null、undefined、symbol和引用类型。</p>
<p>通常判断基本类型只要使用typeof即可，但是由于js内部机制导致<code>typeof null === &#39;object&#39;</code>，所以我们仍需要用<code>obj === null</code>判断对象是否为null。每个基本类型都有其包装类，比如number对应的是Number。如果直接使用<code>typeof new Number(5)</code>得到的结果就是<code>object</code>，实际上我们想要得到的是number类型。这时候就可以调用<code>Object.prototype.toString.call(new Number(5)) === [object Number]</code>，再用正则匹配，就能拿到相应的类型。这种判断方法有几个好处：</p>
<ol>
<li>不用理会数据的是否是基本类型还是引用类型。</li>
<li>内置的引用类型如数组，使用typeof只能得到object，但是如果使用toString函数，也可以拿到其真实属性。如果直接使用[].toString()得到是空字符串，因为数组复写了该方法。</li>
</ol>
<p>对于自定义的函数，我们调用toString方法是无效的，只能得到<code>[object Object]</code>。那我们该如何判断自定义函数的是什么类型，这时候就该instanceof上场了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[对象] <span class="keyword">instanceof</span> [构造函数]</span><br></pre></td></tr></table></figure>
<p>左侧的A必须是对象，如果是基础类型数据会直接返回false。它的原理就是会依着原型链往上判断是否等于构造函数。</p>
<p>下面来看如何判断一个数是有限的，需要满足以下几点：</p>
<ol>
<li>允许是字符串，但只能包含数字，不能包含其他字符比如英文字母等。</li>
<li>不能为null、void 0和空字符串以及symbol类型。</li>
</ol>
<p>原生的isFinite函数无法满足第二点，遇到symbol类型的时候直接报错。所以我们需要先判断是否是symbol类型。对于空字符串的处理可以先使用parseFloat函数，会把它转化成NaN。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_.isFinite = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ""返回false -&gt; 可用parseFloat会将""或者null转换成NaN</span></span><br><span class="line">  <span class="comment">// parseFloat也要放在isSymbol后面，因为parseFloat会先将其转换成字符串，而symBol无法转成字符串</span></span><br><span class="line">  <span class="keyword">return</span> !_.isSymbol(num) &amp;&amp; <span class="built_in">isFinite</span>(num) &amp;&amp; !_.isNaN(<span class="built_in">parseFloat</span>(num));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后判断数字是否是NaN，原生的isNaN遇到undefined时会返回false，所以我们需要先判断是否是number类型。另外<code>NaN === NaN</code>会返回false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span> = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _.isNumber(obj) &amp;&amp; <span class="built_in">isNaN</span>(obj);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="literal">NaN</span> !== <span class="literal">NaN</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="基本类型转换较为简单："><a href="#基本类型转换较为简单：" class="headerlink" title="基本类型转换较为简单："></a>基本类型转换较为简单：</h4><ol>
<li><p>字符串转换：通过输出内容（alert）或者String(value)显性都可以转换成字符串。</p>
</li>
<li><p>数字型转换：通过算术操作或者Number(value)显性都可以转换成数字。</p>
<p>| 值         | 转换成…                                               |<br>| ———- | ——————————————————- |<br>| undefined  | NaN                                                     |<br>| null       | 0                                                       |<br>| true/false | 1/0                                                     |<br>| string     | 忽略两端空白，从前往后转化，遇到非数字转换出错时变成NaN |</p>
</li>
<li><p>布尔型转换：通过逻辑操作（&amp;&amp;）或者Boolean显性都可以转换成布尔。 </p>
</li>
</ol>
<table>
<thead>
<tr>
<th>值</th>
<th>转换成…</th>
</tr>
</thead>
<tbody>
<tr>
<td>null,0,undefined,””,NaN</td>
<td>0</td>
</tr>
<tr>
<td>other</td>
<td>1</td>
</tr>
</tbody>
</table>
<h4 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h4><p>那么当<code>obj1 + obj2</code>会发生什么呢？这种情况下一般是把引用类型转换成原始类型，然后执行操作。按照刚刚所说，所有对象转换成布尔类型时都是true，这时候无法正常操作，所以对象只能转换成字符串或者数字类型。</p>
<p>然后我们来看在什么情况下会转成字符串或者数字类型：</p>
<ol>
<li>string类型：通过输出内容（<code></code>拼接或者alert等）或者作为对象的键值（obj[key]）。</li>
<li>Number类型：算术操作（不包括+操作）或者显示转换（+obj）。</li>
<li>default类型：这个代表着此次操作时模糊的，比如+操作，无法确定时加法还是字符串的添加。当然还有面试必备的<code>==</code>也是无法确定的。</li>
</ol>
<p>在<code>Symbol.toPrimitive</code>函数帮助下，我们可以方便的转化成原始类型。该函数接受一个参数<code>hint</code>来判断此次操作需要转换的类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hint == <span class="string">"number"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hint == <span class="string">"string"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj&#125;</span>`</span>);	<span class="comment">// 输出hello</span></span><br><span class="line"><span class="built_in">console</span>.log(+obj);	<span class="comment">// 输出10</span></span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="string">""</span>)	<span class="comment">// 输出"true"</span></span><br></pre></td></tr></table></figure>
<p>那么如果对象没有<code>Symbol.toPrimitive</code>函数该咋办呢？因为<code>Symbol</code>是在es5之后才出现，那么数组对象等都是没有该函数的，那么该如何转换。</p>
<p>这时候toString方法又出现了。我们知道所有对象都有toString和valueOf方法，是从Object原型链继承来的。默认情况下：</p>
<ol>
<li>toString方法返回字符串<code>[Object object]</code>。</li>
<li>valueOf方法返回对象本身，如<code>{}.valueOf === {}</code>。</li>
</ol>
<p>如果遇到需要转换情况遵从以下规则：</p>
<ol>
<li>string类型：toString -&gt; valueOf</li>
<li>number或者default类型：valueOf -&gt; toString</li>
</ol>
<p>这里的调用有个顺序问题，因为当方法返回对象时候，会被忽略，调用下一个方法。如果两个方法都被调用完则会报无法转换成原始类型的错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    money: <span class="number">10</span>,</span><br><span class="line">    name: <span class="string">"dabai"</span>,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;	<span class="comment">// 如果改成&#123;&#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.money;	<span class="comment">// 也改成&#123;&#125;就会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj&#125;</span>`</span>);	<span class="comment">// 输出dabai</span></span><br><span class="line"><span class="built_in">console</span>.log(+obj);	<span class="comment">// 输出10</span></span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="string">""</span>)	<span class="comment">// 输出"10"</span></span><br></pre></td></tr></table></figure>
<p>利用以上特性，我们可以使以下等式成立：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj == <span class="number">1</span> &amp;&amp; obj == <span class="number">2</span> &amp;&amp; obj == <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>只需要对<code>Symbol.toPrimitive</code>方法复写即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	value: <span class="number">0</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    <span class="keyword">return</span> ++<span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看<code>==</code>情况，可以总结成以下几个情况：</p>
<ol>
<li>类型相同时，等同于<code>===</code>情况。</li>
<li>类型不同时，左右两边最终都需要转换成数字类型。</li>
</ol>
<p>例如<code>[] == ![]</code>，我们左右拆解：</p>
<ol>
<li>左边是引用类型转换成原始类型：[] -&gt; [] -&gt; “” -&gt; 0。</li>
<li>右边使用了!操作符：![] -&gt; false -&gt; 0。</li>
<li>0 == 0结束。</li>
</ol>
<h2 id="bind函数的兼容实现"><a href="#bind函数的兼容实现" class="headerlink" title="bind函数的兼容实现"></a>bind函数的兼容实现</h2><p><code>bind</code>函数会创建一个新的绑定函数。它绑定了原函数，并通过传入的参数改变执行的上下文。最常见的场景就是<code>setTimtout</code>时候，防止上下文变成了window。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.query);</span><br><span class="line">&#125;</span><br><span class="line">test = test.bind(&#123;<span class="attr">query</span>: <span class="number">1</span>&#125;);</span><br><span class="line">settimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	test();	<span class="comment">// 不bind的话，会输出void 0</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>在这里我想重新梳理作用域、原型链概念。</p>
<p>js世界里，万物皆对象，就算是函数也可以看作对象。对象可以看作属性和方法的集合，函数也有name属性和bind等方法。而对象又是函数创建出来的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于,可以看作是个语法糖</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">obj.a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>看得出来，对象可以随意增加属性和方法。</p>
<p>当两个对象建立起关联时候，就是继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog = &#123;</span><br><span class="line">	name: <span class="string">"xiaobai"</span>,</span><br><span class="line">	__proto__: animal</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal = &#123;</span><br><span class="line">  eat: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"start to eat"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于有了<code>__proto__</code>属性，dog对象可以沿着这个属性去调用eat方法。但是我们有时候需要判断属性是否存在对象上，而不是沿着<code>__proto__</code>查找到的，就可以使用<code>hasOwnProperty</code>方法来判断。</p>
<p>这也就是所谓的继承。只是js把他定义在对象里，而java定义在类中。</p>
<p>那么通过Object实例化出来的obj，又怎么会有toString、valueOf等方法呢？这个new的操作符又和面向对象的语言有什么区别呢？</p>
<p>为了和国际化对接，我们可以把首字母大写的普通函数看做构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"my name is"</span> + <span class="keyword">this</span>.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样function看起来就很像类了，但是sayHello方法被写在了构造函数中，导致了每个实例化的对象都要开辟出新的内存来存储该方法，造成了很大的浪费。按照之前的说法，只要把每个对象的<code>__proto__</code>指向<code>{sayHello: xx}</code>的原型对象，就可以规避这个问题了。于是<code>prototype</code>正式登场：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">User.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"my name is"</span> + <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dabai = <span class="keyword">new</span> User(<span class="string">"dabai"</span>, <span class="number">22</span>);</span><br><span class="line">dabai.sayHello();	<span class="comment">// my name is dabai</span></span><br></pre></td></tr></table></figure>
<p>User构造函数其实就是个媒介，当实例化User时候，会创建一个新对象，将其<code>__proto__</code>指向了<code>User.prototype</code>，于是就能找到sayHello方法了。再到es6时候，直接提供了class语法糖，就和面向对象长的很像了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	sayHello() &#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="string">"my name is"</span> + <span class="keyword">this</span>.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> xiaobai = <span class="keyword">new</span> User(<span class="string">"xiaobai"</span>, <span class="number">2</span>);</span><br><span class="line">xiaobai.sayHello();	<span class="comment">// my name is xiaobai</span></span><br></pre></td></tr></table></figure>
<p>解释完原型后，那么this和作用域等又是什么东西呢？</p>
<p>当代码在浏览器直接执行以下代码时：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="built_in">console</span>.log(a);	<span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line"><span class="comment">// sceond</span></span><br><span class="line"><span class="built_in">console</span>.log(a);	<span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// third</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);	<span class="comment">// Window&#123;...&#125;</span></span><br><span class="line"><span class="comment">// forth</span></span><br><span class="line"><span class="built_in">console</span>.log(test1);	<span class="comment">// ƒ test1() &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test2);	<span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> test2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>第一个报错，因为a尚未定义；第二个打印出undefined，说明浏览器执行console.log时候，已经将a变量初始化成了undefined；第三个，我们知道无论在什么情况下，我们都能拿到this取值，只是视情况而定；第四个第一句是函数声明，第二句是函数表达式，可以看到函数声明会先对变量设置值，而函数表达式和第二个情况相似，也是初始化成undefined。</p>
<p>综上所述，当代码执行时候，浏览器是会做一些准备工作的：</p>
<ol>
<li>变量和函数表达式：变量声明且初始化成undefined。</li>
<li>this赋值。</li>
<li>函数声明赋值。</li>
</ol>
<p>上述的例子都是在浏览器全局环境执行，而环境又可以分成三种：</p>
<ol>
<li><p>全局环境。</p>
</li>
<li><p>函数体，本质上是由new Function(…)得到的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">add = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"return a+b;"</span></span>);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>eval代码，一般不使用。</p>
</li>
</ol>
<p>在函数体中执行代码和全局肯定稍有不同，比如argument参数，也是浏览器准备好的。每次调用都是新的执行环境，因为每次的argument参数都是不一样的。此外函数可能会调用不在函数中声明的自由变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>a变量是属于全局环境的，当调用test函数时，就会沿着作用域链去查找a。</p>
<p>所以函数执行时会在全局的准备工作上附加以下步骤：</p>
<ol>
<li>参数赋值。</li>
<li>arguments赋值。</li>
<li>确定自由变量的作用域。</li>
</ol>
<p>假设在该函数中同时出现了同一变量名，但是方式分别是参数、函数声明和变量，又会产生怎么冲突呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">c(<span class="number">2</span>);	<span class="comment">// function a() &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>说明变量提升的顺序：函数声明 &gt; 参数 &gt; 变量。</p>
<p>刚刚提到我们会沿着作用域链去查找a变量，我们来看下面代码来明确作用域链：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure>
<p>上述代码两个都会输出<code>local scope</code>，第二个结果令人有点难以捉摸。</p>
<p>事实上在js里面，只有函数才能形成作用域，而if等代码块是不能的。这句话怎么理解呢，我们看下这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// undefined ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>
<p>因为if没有形成作用域，所以a变量声明会被提升到作用域顶端。但是let、const声明是可以限制在块级代码块中，就会报错。</p>
<p>作用域作用就是隔离变量，像例子中checkscope中覆盖了scope变量。而且函数作用域有上下级关系，在哪个作用域中创建就能确立该关系。所以作用域时静态的，当你写下代码时候就已经确定好关系了。如果解析出ast，可以看到scope字段，明确了每个变量的作用域。</p>
<p>当函数内部遇到自由变量即例子中scope时，是去创建函数的作用域中取值，而不是调用函数的作用域中取值。就这样一直查找到全局的作用域也就是全局环境，如果全局作用域也没有，就会报没有定义变量的错误。我们看第二个例子：</p>
<ol>
<li>执行checkscope函数，返回f函数。</li>
<li>执行f函数，遇到了scope变量。</li>
<li>f函数在checkscope中创建，要去checkscope作用域中查找scope变量，刚好有该变量，返回。</li>
</ol>
<p>所以作用域两个知识点：</p>
<ol>
<li>作用域只有函数才能形成，能够隔离变量。</li>
<li>函数内部取自由变量的值时，要去创建它的作用域查找，最外层的作用域时全局环境。</li>
</ol>
<p>我们知道在所有语言里，函数执行可以看作入栈和出栈。当函数执行时就会被压入栈，执行完毕后就会出栈。那么如果这个函数持有了上一个栈中数据时候会怎么样呢？我们把上面的例子修改一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> inner = checkscope();</span><br></pre></td></tr></table></figure>
<p>我们把checkscope函数返回值赋值给了inner变量，现在inner变量可以看作f函数。尽管checkscope执行完毕，但是inner变量持有了它内部的scope变量，所以checkscope是无法出栈，直到inner变量释放为止。这也会造成一个问题：由于迟迟无法释放堆栈，导致内存开销变大。</p>
<p>这也被称为闭包，主要原因就是函数查找自由变量时候需要去创建它的地方去取值。换言之，我们可以认为闭包应用到两种情况：返回参数和传入参数。返回参数就是上述例子，传入参数可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(func(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line">test(add);	<span class="comment">// 输出3</span></span><br></pre></td></tr></table></figure>
<p>闭包我们也讲完了，最后只剩下this取值了，this取值时动态的，在运行时候才能确定，取决于我们时如何调用函数的（全局环境的this就是window）。我们分几种情况讨论：</p>
<ol>
<li><p>构造函数：当new一个对象时候，this指向了实例化出来的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"this指向了User"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> User()	<span class="comment">// this指向了User</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象调用函数：此时this指向了该对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">	x: <span class="number">20</span>,</span><br><span class="line">    test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">user.test();	<span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>全局调用函数：我们把上述例子中改成不用对象调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">	x: <span class="number">20</span>,</span><br><span class="line">    test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test = user.test</span><br><span class="line">test();	<span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>此时test是由全局调用，所以this指向了window变量。再来看稍微复杂点例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">	x: <span class="number">20</span>,</span><br><span class="line">    test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">        test()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">user.test()	<span class="comment">// 20 10</span></span><br></pre></td></tr></table></figure>
<p>尽管由user对象调用了test函数，但是在其内部test函数是被全局调用了，所以还是输出了10。</p>
</li>
<li><p>call &amp;&amp; apply &amp;&amp; bind调用：这种情况由传入的参数决定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">	x: <span class="number">20</span>,</span><br><span class="line">    test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user1 = &#123;<span class="attr">x</span>: <span class="number">10</span>&#125;;</span><br><span class="line">user.test.apply(user1);	<span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>this就是以上4种情况。es5之后出现了箭头函数，它比较特殊，没有this和arguments参数，也不能当作构造函数。但是我们在箭头函数中也可以使用this的值，这是因为它是从上一个作用域中查找得到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// firsr</span></span><br><span class="line">User = <span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> User();	<span class="comment">// Uncaught TypeError: aaaaaaa is not a constructor</span></span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">	x: <span class="number">20</span>,</span><br><span class="line">    test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      	<span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">user.test(<span class="number">100</span>);	<span class="comment">// 20 Arguments [100, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br></pre></td></tr></table></figure>
<p>可以看到this指向了user对象，arguments参数也是从test方法中继承过来的。</p>
<p>下面我们实现简易版的bind方法，其实就是绑定this引用和传入参数，参数的处理可以通过bind传入，也可以通过bind返回的函数再传入。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bind = <span class="function"><span class="keyword">function</span> (<span class="params">func, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">2</span>);</span><br><span class="line">  context = context || globalThis;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callArgs = args.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>));</span><br><span class="line">    <span class="keyword">return</span> func.apply(context, callArgs);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样的实现缺陷就是如果实例化bind返回的函数，正常是忽略传入的context参数，但是传入的参数仍有效，所以我们需要对返回函数的原型链修改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bind = <span class="function"><span class="keyword">function</span> (<span class="params">func, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">2</span>);</span><br><span class="line">  context = context || globalThis;</span><br><span class="line">  <span class="keyword">const</span> boundFun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callArgs = args.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>));</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> boundFun)) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(context, callArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> self = &#123; <span class="attr">__proto__</span>: func.prototype &#125;;</span><br><span class="line">    <span class="keyword">const</span> result = func.apply(self, callArgs);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">"object"</span> ? result : self;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> boundFun;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实就是在模拟new对象过程：</p>
<ol>
<li>创建实例化的对象，一个<code>__proto__</code>属性指向需要构造器的<code>prototype</code>。</li>
<li>调用构造器并传参。</li>
<li>返回的参数如果是对象就返回该参数，否则返回实例化的对象。</li>
</ol>
<p>不过MDN里提到一般不推荐直接调用<code>__proto__</code>属性，使用这种方法会严重影响性能。如果要设置或者取得它的原型链，尽量使用<code>Object.getPrototypeOf</code>或者<code>Object.setPrototypeOf</code>方法。如果创建一个新的且可以继承 <code>[[Prototype]]</code> 的对象，即模拟new对象的过程第一步，推荐使用<code>Object.create</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> self = &#123; <span class="attr">__proto__</span>: func.prototype &#125;;</span><br><span class="line"><span class="comment">// 替换成</span></span><br><span class="line"><span class="keyword">const</span> self = <span class="built_in">Object</span>.create(func);</span><br></pre></td></tr></table></figure>
<p>接着来实现Object.create方法，它使用了个中介函数，防止原型链的污染。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ctor</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseCreate</span>(<span class="params">prototype</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> prototype !== <span class="string">"function"</span> &amp;&amp; <span class="keyword">typeof</span> prototype !== <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  Ctor.prototype = prototype;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> Ctor();</span><br><span class="line">  Ctor.prototype = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把中介函数提取出来，而不是在baseCreate函数内部定义，减少内存消耗。这样我们就避免接触<code>__proto__</code>对象。</p>
<p>之前都是在模拟new操作符，其实我们可以直接调用new操作符去实例化该对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bind = <span class="function"><span class="keyword">function</span> (<span class="params">func, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">2</span>);</span><br><span class="line">  context = context || globalThis;</span><br><span class="line">  <span class="keyword">const</span> boundFun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callArgs = args.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>));</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> boundFun)) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(context, callArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> func(...callArgs);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> boundFun;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>刚刚有提到过<code>Object.create</code>方法，它更多的是在继承中使用，我们来梳理下继承的几种方法。</p>
<ol>
<li>原型链继承</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.names = [<span class="string">'dabai'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getNames = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.names);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();	<span class="comment">// 这步可以这么替代：Child .prototype = Object.create(new Parent())</span></span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child1.getNames())	<span class="comment">// dabai</span></span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ul>
<li>无法对父类的构造函数传参。</li>
<li>原型链直接指向了实例化的父类对象，导致父类构造器内部定义的属性变成了公共属性。(names操作会反映到每个子类实例中)</li>
</ul>
<ol start="2">
<li>借用构造函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.names = [name];</span><br><span class="line">  <span class="keyword">this</span>.getNames = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="keyword">this</span>.names);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, <span class="string">"dabai"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.names.push(<span class="string">'xiaobai'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["dabai", "xiaobai"]</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child2.names);	<span class="comment">// ["dabai"]</span></span><br></pre></td></tr></table></figure>
<p>修正了原型链继承的两个缺点，但出现了新的问题。</p>
<p>缺点：</p>
<ul>
<li>方法需要定义在构造函数。</li>
</ul>
<ol start="3">
<li>组合继承</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.names = [name];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getNames = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.names);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, <span class="string">"dabai"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.names.push(<span class="string">'xiaobai'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["dabai", "xiaobai"]</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child2.names);	<span class="comment">// ["dabai"]</span></span><br></pre></td></tr></table></figure>
<p>结合了两种继承方式，实例化后的子类将会覆盖父类的属性，这样就解决了共享实例问题。</p>
<p>缺点：</p>
<ul>
<li>父类会实例化两遍。</li>
</ul>
<ol start="4">
<li>寄生式继承</li>
</ol>
<p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(o);</span><br><span class="line">    clone.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ul>
<li>对象的方法需要在构造器中定义。</li>
</ul>
<ol start="5">
<li>寄生组合式继承</li>
</ol>
<p>这种方式就是为了避免父类创建两次而诞生的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.names = [name];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getNames = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.names);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, <span class="string">"dabai"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);	<span class="comment">// 可以理解这是寄生</span></span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.names.push(<span class="string">'xiaobai'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["dabai", "xiaobai"]</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child2.names);	<span class="comment">// ["dabai"]</span></span><br></pre></td></tr></table></figure>
<p>引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：</p>
<p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
<p>ts的继承也是这种方式，但它多了静态属性的继承，以及未使用<code>Object.create</code>方法，自己去实现该方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __extends = (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.__extends) || (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> extendStatics = <span class="function"><span class="keyword">function</span> (<span class="params">d, b</span>) </span>&#123;</span><br><span class="line">        extendStatics = <span class="built_in">Object</span>.setPrototypeOf ||</span><br><span class="line">            (&#123; <span class="attr">__proto__</span>: [] &#125; <span class="keyword">instanceof</span> <span class="built_in">Array</span> &amp;&amp; <span class="function"><span class="keyword">function</span> (<span class="params">d, b</span>) </span>&#123; d.__proto__ = b; &#125;) ||</span><br><span class="line">            <span class="function"><span class="keyword">function</span> (<span class="params">d, b</span>) </span>&#123; <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> b) <span class="keyword">if</span> (b.hasOwnProperty(p)) d[p] = b[p]; &#125;;</span><br><span class="line">        <span class="keyword">return</span> extendStatics(d, b);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">d, b</span>) </span>&#123;</span><br><span class="line">        extendStatics(d, b);</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.constructor = d; &#125;</span><br><span class="line">        d.prototype = b === <span class="literal">null</span> ? <span class="built_in">Object</span>.create(b) : (__.prototype = b.prototype, <span class="keyword">new</span> __());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>静态属性的定义既可以在构造器本身上，也可以在构造器的<code>__proto__</code>上。之前有说过不推荐操作<code>__proto__</code>属性，所以extendStatics方法优先使用了<code>Object.setPrototypeOf</code>，如果不存在，再考虑浏览器是否支持定义<code>__proto__</code>属性，如果也不行，再去定义在构造器本身上。</p>
<p>如果父类不存在，调用<code>Object.create(b)</code>方法，这样返回的对象是纯净的，没有Object上的任何方法和属性；如果存在，再用中介函数的原型去引用父类的原型，可以看作<code>Child.prototype = Object.create(Parent.prototype);Child.prototype.constructor = Child;</code>的变种。</p>
<p>复习完了bind，自然要开始看call和apply的实现，两者的差别不大，需要调用的函数惨参数形式不一样，一个是数组一个正常传入。最大的难点就是传参，如果是es6可以直接解构传入，而es5无法一一传入，就要用到eval函数了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call</span>(<span class="params">func, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> args = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    args[i - <span class="number">2</span>] = <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.func = func;</span><br><span class="line">  <span class="keyword">const</span> result = context.func(...args);	<span class="comment">// 直接解构调用</span></span><br><span class="line">  <span class="keyword">delete</span> context.func;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call2</span>(<span class="params">func, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> args = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    args[i - <span class="number">2</span>] = <span class="string">`arguments[<span class="subst">$&#123;i&#125;</span>]`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || &#123;&#125;;</span><br><span class="line">  context.func = func;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="built_in">eval</span>(<span class="string">`context.func(<span class="subst">$&#123;args.join(<span class="string">","</span>)&#125;</span>)`</span>);	<span class="comment">// eval传入每个参数</span></span><br><span class="line">  <span class="keyword">delete</span> context.func;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>提到函数式编程，想起的必定是柯里化，柯里化就是可以传入很多参数给curry函数，也可以分批传入给curry函数。这个最大的好处就是函数参数有时候一部分是一样的，就可以提前传入参数保持参数的作用域，从而实现参数的复用。通常举例都是这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn = curry(add);</span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>)	<span class="comment">// 3</span></span><br><span class="line">fn(<span class="number">1</span>)(<span class="number">2</span>)	<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>最简单的柯里化就是先传部分参数，再传入剩余参数给返回的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callArgs = args.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>));</span><br><span class="line">    <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, callArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个版本的curry函数只能一次性使用，返回的函数只能再传入一次参数就要执行了，一般更具有普遍性的就是可以无限传入参数，知道参数长度大于等于执行函数参数长度，这时候就要用到递归了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callArgs = args.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>));</span><br><span class="line">    <span class="keyword">if</span> (callArgs.length &gt;= func.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, callArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> curry.call(<span class="literal">null</span>, func, ...callArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>闭包函数中的callArgs变量不能用args替代，因为args变量此时是共享的变量，如果多次调用curry返回的函数，就会改变args变量值。递归终止条件是参数长度足够，不够的话，继续调用柯里化函数直到达到终止条件。</p>
<p>和柯里化相对的是偏函数，即利用占位符去固定参数的位置，这些占位符参数可以通过返回的函数重新传入，还是上述例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = partial(add, _, <span class="number">2</span>);</span><br><span class="line">func(<span class="number">1</span>);	<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>underscore也实现了这个函数，这种的简易版本也是很简单，就是将后续参数一一填充到占位符上即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> position = <span class="number">0</span>, len = args.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            args[i] = args[i] === _ ? <span class="built_in">arguments</span>[position++] : args[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(position &lt; <span class="built_in">arguments</span>.length) args.push(<span class="built_in">arguments</span>[position++]);</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>说是对underscore的源码分析，其实更多的是结合了underscore源码梳理了一遍js知识体系，可以多读几遍巩固基础。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="食饼筒">
            
              <p class="site-author-name" itemprop="name">食饼筒</p>
              <p class="site-description motion-element" itemprop="description">do better</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">食饼筒</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>


<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style="display:none">
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style="display:none">
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共60.9k字</span>
</div>
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
