<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="do better">
<meta property="og:type" content="website">
<meta property="og:title" content="稠鱼烧才好吃">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="稠鱼烧才好吃">
<meta property="og:description" content="do better">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="稠鱼烧才好吃">
<meta name="twitter:description" content="do better">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>稠鱼烧才好吃</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">稠鱼烧才好吃</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/02/动手写webpack：打包实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/02/动手写webpack：打包实现/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-02T14:12:09+08:00">
                2020-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="动手写webpack：打包实现"><a href="#动手写webpack：打包实现" class="headerlink" title="动手写webpack：打包实现"></a>动手写webpack：打包实现</h1><p>在大型应用中，模块化是必不可少的，总不能将代码都写在一个文件中。在js诞生之初，作用只是作为简单的脚本，所以并没有模块化规范这一说法。到后来单页应用等出现，模块化是必不可少的。在这之中涌现了几种实现方式，其中commonjs是node的实现方式，它是按照同步去加载模块，所以不适用于浏览器。es6提出了ES Modules的语言标准，使用import等关键字实现。</p>
<p>在模块化的道路上，低版本的浏览器却是拦路虎。为了在低版本浏览器可以使用模块化规范，我们需要将其转化成es5语法才能运行。于是涌现了无数的打包工具，其中脱颖而出的就是webpack，Angular底层打包也是利用了webpack工具。</p>
<!-- readMore -->
<p>所以webpack的学习是必不可少的，从另一面来说，如何实现打包工具也是作为前端该学习的。我在学习的时候，其实并没有看wepack源码，因为它太庞大了。我只是看了它打包出来的代码和文档，然后再去实现，这也是一种学习方法。</p>
<p>我们最后需要实现的能够兼容cjs和ES Modules两种打包方式、import方式的异步加载和loader的加载，这篇先实现第一步的功能。</p>
<h2 id="bundle-js"><a href="#bundle-js" class="headerlink" title="bundle.js"></a>bundle.js</h2><p>首先思考cjs规范打包出来的文件是什么样子的，例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cfn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"c-------"</span>);</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; cfn, count &#125;;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> ces <span class="keyword">from</span> <span class="string">"./c"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; cfn &#125; <span class="keyword">from</span> <span class="string">"./c"</span>;</span><br><span class="line"><span class="keyword">const</span> ccjs = <span class="built_in">require</span>(<span class="string">"./c"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; count &#125; = <span class="built_in">require</span>(<span class="string">"./c"</span>);</span><br></pre></td></tr></table></figure>
<p>对于c文件而言，只需要把导出的值存储到某一变量值，再去映射到map中即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.js打包出来的结果</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"c.js"</span>: (<span class="function"><span class="keyword">function</span>(<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">	"use strict"</span>;</span><br><span class="line">	<span class="built_in">eval</span>(<span class="string">"let count = 0;\nfunction cfn() &#123;\n  console.log(\"c-------\");\n  			   count++;\n&#125;\nmodule.exports = &#123;\n  cfn,\n  count\n&#125;;"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// __webpack_require__方法即请求依赖文件方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 是否已经请求国</span></span><br><span class="line">  <span class="keyword">if</span>(installedModules[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 会将导出值存储到这个变量中</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">    i: moduleId,</span><br><span class="line">    l: <span class="literal">false</span>,</span><br><span class="line">    exports: &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 执行函数</span></span><br><span class="line">  modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line">  <span class="comment">// 标志已经执行过了</span></span><br><span class="line">  <span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到当遇到依赖的文件时候，执行<code>__webpack_require__</code>方法，通过传入<code>module</code>变量将导出的值存储到<code>exports</code>属性中即可。其中该方法既传入了module变量，又传入了<code>module.exports</code>变量，这是因为导出方式既可以是<code>module.exports = {....}</code>，也可以是<code>exports.xx = xx</code>，所以如果直接对exports赋值是没有用的。</p>
<p>对于index.js文件而言，cjs导入的所有变量都是静态的，直接引用即可。也就是对于后三种导入方式都是一样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cfn = __webpack_require__(<span class="string">"./c"</span>);</span><br><span class="line"><span class="keyword">const</span> ccjs = __webpack_require__(<span class="string">"./c"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; count &#125; = __webpack_require__(<span class="string">"./c"</span>);</span><br></pre></td></tr></table></figure>
<p>第一种导入方式有点特殊，我们留在ES Modules导入一起讲。</p>
<p>ES Modules规范是这么导入导出的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">afn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a-------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// d.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"d-------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> dfn;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> aes <span class="keyword">from</span> <span class="string">"./a"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; afn &#125; <span class="keyword">from</span> <span class="string">"./a"</span>;</span><br><span class="line"><span class="keyword">const</span> acjs = <span class="built_in">require</span>(<span class="string">"./a"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; afn &#125; = <span class="built_in">require</span>(<span class="string">"./a"</span>);</span><br></pre></td></tr></table></figure>
<p>按照ES规范导出的变量都是动态的，而不像cjs导出的基本类型变量一开始是多少，就永远是什么，即使内部的函数会改变该变量的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cjs</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;count, add&#125;;</span><br><span class="line"><span class="comment">// es</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add, count &#125; <span class="keyword">from</span> <span class="string">"./es"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(count);	<span class="comment">// 1</span></span><br><span class="line">add();</span><br><span class="line"><span class="built_in">console</span>.log(count);	<span class="comment">// 2</span></span><br><span class="line"><span class="keyword">const</span> &#123;add, count&#125; = <span class="built_in">require</span>(<span class="string">"./cjs"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count);	<span class="comment">// 1</span></span><br><span class="line">add();</span><br><span class="line"><span class="built_in">console</span>.log(count);	<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>静态的变量很好理解，在它导出到exports变量的时候，这个值就确定了，即使函数改变了在文件的改值，exports引用的仍然是原先的值，除非是引用变量，大家都是指向同一地址。</p>
<p>那么打包时候该如何对es变量处理呢？答案就是定义exports的getter方法，这样就能确保返回的值时动态的。例如对于以上的a.js而言，应该是这么导出的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty.define(exports, <span class="string">"afn"</span>, &#123;</span><br><span class="line">	enumerable: <span class="literal">true</span>, </span><br><span class="line">	<span class="keyword">get</span>: function () &#123;</span><br><span class="line">		<span class="keyword">return</span> afn;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样能保证基本类型能取到最新值。但是对于默认导出，它也是静态的，所以无需转换成以上方式。</p>
<p>我们再来看导入方式应该打包成什么样子的，而对于cjs规范导出的变量，它要的变量是静态的，所以和之前一样只需要在开头出导入变量即可。</p>
<p>而对于es规范的模块，为了保证导入的数据是动态，不能在开头处就导入好每个变量，应该在调用的地方再去调用exports变量引用，默认导出的变量可以看作键是<code>default</code>的属性即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="string">"./es.js"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(_es__WEBPACK_IMPORTED_MODULE_0__[<span class="string">"count"</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(_es__WEBPACK_IMPORTED_MODULE_0__[<span class="string">"default"</span>]);</span><br></pre></td></tr></table></figure>
<p>但是以cjs规范导出的默认变量就不太一样了，虽然他没有这个概念，但是它也可以按照这个格式导入<code>import aes from &quot;./a&quot;;</code>，此时也可以看作动态的引用。有时候我们为了兼容cjs的打包规范，允许他以默认变量的值导入，但是cjs规范导出的默认变量值就是exports的引用，我们并不是想要exports值，而是和es一样只是某一个变量而已，这里webpack做了个兼容，允许cjs规范的文件加上__esModule的标志，加上后，我们会去取default属性的值，从而达到和es规范一样的效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require__.n = <span class="function"><span class="keyword">function</span>(<span class="params">module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> getter = <span class="built_in">module</span> &amp;&amp; <span class="built_in">module</span>.__esModule ?</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDefault</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">module</span>[<span class="string">'default'</span>]; &#125; :</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getModuleExports</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">module</span>; &#125;;</span><br><span class="line">  __webpack_require__.d(getter, <span class="string">'a'</span>, getter);</span><br><span class="line">  <span class="keyword">return</span> getter;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// css-loader的文件导出</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(exports, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">  value: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">exports.default = loader;</span><br></pre></td></tr></table></figure>
<p>看css-loader文件的导出就是定义了<code>__esModule</code>标志，所以可以直接定义default属性的值，以默认方式导入时候，我们就可以取到loader函数的值。</p>
<p>综上，我们可以总结：</p>
<table>
<thead>
<tr>
<th></th>
<th>cjs导出方式</th>
<th>es导出方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>cjs解构导入方式</td>
<td>替换require方法</td>
<td>替换require方法</td>
</tr>
<tr>
<td>cjs默认导入方式</td>
<td>替换require方法</td>
<td>替换require方法</td>
</tr>
<tr>
<td>es解构导入方式</td>
<td>导入的模块名会重新命名，不会在文件开头地方就取得值，在调用时候用模块新名字键名取值</td>
<td>同cjs导出方式</td>
</tr>
<tr>
<td>es默认导入方式</td>
<td>导入的模块同样会重新命名，但是会查看是否标志了__esModule，如果是的话会去取default键的值，否则直接导入exports变量</td>
<td>键名为default</td>
</tr>
</tbody>
</table>
<h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><p>解析完bundle.js，我们知道最后的代码需要变成什么样子了。接下来我们只需要对文件内容替换、删除或者增加内容。我们不可能对文件进行逐行匹配，毕竟有注释什么的，所以AST的出现拯救了这个问题。</p>
<p>AST可以理解为提取文件内容的每个符号信息当成节点，最简单的节点只有type类型。例如函数的调用就是callExpression形式，而调用的函数名又是stringLiteral，这样不同的节点会组成新的节点，最后转换成树结构。常见的语法高亮也是提取出AST后，再针对不同的类型处理相应的的颜色。在这里我们先用babylon库将文件内容转化成AST，再@babel/traverse库遍历AST。往往便利时候会采用访问者设计模式，不论是输出到目标代码，亦或是 AST 内部的变换。Visit 中会单独实现每种节点类型的相应实现，本质上仍然是递归过程，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babylon = <span class="built_in">require</span>(<span class="string">"babylon"</span>);</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">"@babel/traverse"</span>).default;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = babylon.parse(code, &#123;</span><br><span class="line">  sourceType: <span class="string">"module"</span>,</span><br><span class="line">  plugins: [<span class="string">"dynamicImport"</span>],</span><br><span class="line">&#125;);</span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  ImportDeclaration(path) &#123;</span><br><span class="line">    xxx</span><br><span class="line">  &#125;,</span><br><span class="line">  CallExpression(path) &#123;</span><br><span class="line">    xxx</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们遇到require和import导入关键词时候，我们需要拿到导入的文件名。在AST中require是名称是<code>require</code>函数调用表达式，import有个专门的类型ImportDeclaration和Import，前者是静态导入，后者是动态导入<code>import(xx).then</code>这种形式。拿到依赖的文件名后，再去重新走一遍该流程，深度优先遍历后拿到所有的依赖文件。</p>
<p>在取得文件依赖后，我们需要处理标示是否是es模块以便变量名的处理，当然这一步你也可以在取得所有文件依赖后再去处理，但是这步需要优先于变量名的处理遍历。简单粗暴的认为如果文件有<code>export</code>关键词，直接标为es模块。</p>
<p>所有文件的统一处理有这么几步：</p>
<ol>
<li>require函数名替换成<code>__webpack_require__</code>名。</li>
<li>export的变量替换成<code>__webpack_require__.d(xxx)</code>，默认导出的变量替换成<code>exports[&#39;default&#39;]</code>。</li>
<li>import进来的文件替换成<code>var xxx = __webpack_require__(xxx)</code> 并合并相同导入文件名，而导入的变量名则改成<code>xxx[key]</code>形式。</li>
</ol>
<p>以上步骤涉及了对AST的几种操作：删除、替换和新增。节点的信息会存储到<code>path</code>路径对象中，而路径对象还记录了节点在书中的位置，节点的父节点以及当前节点的操作。例如节点的删除可以调用<code>path.remove()</code>等，更多请查看<a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>除此之外，还有es模块变量名的替换，一开始的思路记录导入的变量名，在后续变量的调用即stringLiteral节点类型替换节点。这样有个问题，当创建了函数后，函数内部变量名和导入变量名一样的话，也会被替换，此时两者作用域并不相同。后来发现路径对象也存储了作用域<code>scope</code>对象，在这里可以检查变量是否绑定（可以实现简单的摇输优化·），也可以提升变量作用域或者改变变量名字。这里也说明了变量的作用域是静态的，当写好代码那刻，自由变量取值就是确定的。所以上述问题，我们可以在全局环境中调用<code>path.scope.rename(oldValue, newValue)</code>替换变量名。</p>
<p>处理完ast后，我们需要将ast重新变回代码，毕竟在浏览器中运行的还是代码。所以需要用到generator库，他的作用就是解析ast成字符串。我们参照webpack的开发模式，使用eval调用代码，所以对字符串还需要进行空格和双引号等转移处理。</p>
<p>最后我们得到一个依赖关系对象<code>depTree</code>，此对象完整地描述了以下信息：都有哪些模块，各个模块的内容是什么，他们之间的依赖关系又是如何等等。具体的结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    <span class="string">'/Users/zhaorenjie/Documents/project/js/fake-webpack/example/simple/index.js'</span>: Module &#123;</span><br><span class="line">      path: <span class="string">'../example/simple/index.js'</span>,</span><br><span class="line">      absoulutePath: <span class="string">'/Users/zhaorenjie/Documents/project/js/fake-webpack/example/simple/index.js'</span>,</span><br><span class="line">      id: <span class="number">0</span>,</span><br><span class="line">      code: <span class="string">'import ces from "/Users/zhaorenjie/Documents/project/js/fake-webpack/example/simple/c.js";\n'</span> +</span><br><span class="line">        <span class="string">'import &#123; cfn &#125; from "./c";\n'</span> +</span><br><span class="line">        <span class="string">'const ccjs = require("./c");\n'</span> +</span><br><span class="line">        <span class="string">'const &#123; num &#125; = require("./c");\n'</span> +</span><br><span class="line">        <span class="string">'\n'</span> +</span><br><span class="line">        <span class="string">'console.log(ces);\n'</span> +</span><br><span class="line">        <span class="string">'console.log(cfn);\n'</span> +</span><br><span class="line">        <span class="string">'console.log(ccjs);\n'</span> +</span><br><span class="line">        <span class="string">'console.log(num);\n'</span> +</span><br><span class="line">        <span class="string">'\n'</span> +</span><br><span class="line">        <span class="string">'import &#123; count &#125; from "./a";\n'</span> +</span><br><span class="line">        <span class="string">'const acjs = require("./a");\n'</span> +</span><br><span class="line">        <span class="string">'const &#123; afn &#125; = require("./a");\n'</span> +</span><br><span class="line">        <span class="string">'import name from "./a";\n'</span> +</span><br><span class="line">        <span class="string">'\n'</span> +</span><br><span class="line">        <span class="string">'console.log(count);\n'</span> +</span><br><span class="line">        <span class="string">'console.log(acjs);\n'</span> +</span><br><span class="line">        <span class="string">'console.log(afn);\n'</span> +</span><br><span class="line">        <span class="string">'console.log(name);\n'</span>,</span><br><span class="line">      esModule: <span class="literal">true</span>,</span><br><span class="line">      ast: [Node],</span><br><span class="line">      syncDeps: [<span class="built_in">Array</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'/Users/zhaorenjie/Documents/project/js/fake-webpack/example/simple/c.js'</span>: Module &#123;</span><br><span class="line">      path: <span class="string">'/Users/zhaorenjie/Documents/project/js/fake-webpack/example/simple/c.js'</span>,</span><br><span class="line">      absoulutePath: <span class="string">'/Users/zhaorenjie/Documents/project/js/fake-webpack/example/simple/c.js'</span>,</span><br><span class="line">      id: <span class="number">1</span>,</span><br><span class="line">      code: <span class="string">'let num = 0;\n'</span> +</span><br><span class="line">        <span class="string">'function cfn() &#123;\n'</span> +</span><br><span class="line">        <span class="string">'  console.log("c-------");\n'</span> +</span><br><span class="line">        <span class="string">'  num++;\n'</span> +</span><br><span class="line">        <span class="string">'&#125;\n'</span> +</span><br><span class="line">        <span class="string">'\n'</span> +</span><br><span class="line">        <span class="string">'module.exports = &#123; cfn, num &#125;;\n'</span> +</span><br><span class="line">        <span class="string">'\n'</span>,</span><br><span class="line">      syncDeps: [],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'/Users/zhaorenjie/Documents/project/js/fake-webpack/example/simple/a.js'</span>: Module &#123;</span><br><span class="line">      chunks: [],</span><br><span class="line">      path: <span class="string">'./a'</span>,</span><br><span class="line">      absoulutePath: <span class="string">'/Users/zhaorenjie/Documents/project/js/fake-webpack/example/simple/a.js'</span>,</span><br><span class="line">      id: <span class="number">2</span>,</span><br><span class="line">      code: <span class="string">'export function afn() &#123;\n'</span> +</span><br><span class="line">        <span class="string">'  console.log("a-------");\n'</span> +</span><br><span class="line">        <span class="string">'&#125;\n'</span> +</span><br><span class="line">        <span class="string">'export const count = 1;\n'</span> +</span><br><span class="line">        <span class="string">'const name = "dabai";\n'</span> +</span><br><span class="line">        <span class="string">'export default name;\n'</span>,</span><br><span class="line">      esModule: <span class="literal">true</span>,</span><br><span class="line">      ast: [Node],</span><br><span class="line">      syncDeps: [],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mapModuleNameToId: &#123;</span><br><span class="line">    <span class="string">'../example/simple/index.js'</span>: <span class="string">'/Users/zhaorenjie/Documents/project/js/fake-webpack/example/simple/index.js'</span>,</span><br><span class="line">    <span class="string">'/Users/zhaorenjie/Documents/project/js/fake-webpack/example/simple/c.js'</span>: <span class="string">'/Users/zhaorenjie/Documents/project/js/fake-webpack/example/simple/c.js'</span>,</span><br><span class="line">    <span class="string">'./c'</span>: <span class="string">'/Users/zhaorenjie/Documents/project/js/fake-webpack/example/simple/c.js'</span>,</span><br><span class="line">    <span class="string">'./a'</span>: <span class="string">'/Users/zhaorenjie/Documents/project/js/fake-webpack/example/simple/a.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  entry: <span class="string">'/Users/zhaorenjie/Documents/project/js/fake-webpack/example/simple/index.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模块路径"><a href="#模块路径" class="headerlink" title="模块路径"></a>模块路径</h2><p>在找到依赖文件后，那么我们如何知道文件的绝对路径呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add, count &#125; <span class="keyword">from</span> <span class="string">"./es"</span>;</span><br><span class="line"><span class="keyword">import</span> css <span class="keyword">from</span> <span class="string">"./index.css"</span>;</span><br><span class="line"><span class="keyword">import</span> ces <span class="keyword">from</span> <span class="string">"/Users/xxxx/simple/c.js"</span>;</span><br><span class="line"><span class="keyword">const</span> babylon = <span class="built_in">require</span>(<span class="string">"babylon"</span>);</span><br></pre></td></tr></table></figure>
<p>可以看出导入的文件可以没有后缀名，可以导入相对或者绝对路径，也可以导入node_modules里的文件。</p>
<p>目前采用的查找逻辑：</p>
<ol>
<li>判断文件有没有后缀，没有的话默认是js文件，在webpack中是可以配置查找后缀名，所以推荐把常用的写在前面，提高查找速度。</li>
<li>如果给出的是绝对路径/相对路径，只查找一次。找到后返回绝对路径。找不到的话直接报错。</li>
<li>如果给出的是模块名字，没有任何前缀，去入口文件的同级目录查找，存在的话返回绝对路径。</li>
<li>第三步没找到话，去入口文件的node_modules下查找，如果是目录的话，查看package.json的main字段，根据该字段返回绝对路径，没有该字段返回index.js，再没有报错；如果是文件的话，返回绝对路径。</li>
</ol>
<h2 id="拼接bundle-js"><a href="#拼接bundle-js" class="headerlink" title="拼接bundle.js"></a>拼接bundle.js</h2><p>这是最后一步，我们默认输出的主模块文件名为bundle.js。根据上述的<code>depTree</code>对象，我们便能完成这最后的一步：<strong>output.js文件的拼接。</strong>我们提取webpack的基本函数当作模板存储到单独地文件中，而需要运行的模块控制逻辑就是遍历<code>depTree</code>对象。</p>
<p>源代码可以看<a href="https://github.com/ccanister/fake-webpack#fake-webpack" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.babeljs.cn/docs/babel-types" target="_blank" rel="noopener">babel-types</a></li>
<li><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md" target="_blank" rel="noopener">plugin-handbook</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/02/Angular CLI底层 ---- 神秘的构建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/02/Angular CLI底层 ---- 神秘的构建/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-02T14:12:09+08:00">
                2020-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Angular-CLI底层-—-神秘的构建"><a href="#Angular-CLI底层-—-神秘的构建" class="headerlink" title="Angular CLI底层 —- 神秘的构建"></a>Angular CLI底层 —- 神秘的构建</h1><p>本文翻译自<a href="https://medium.com/dailyjs/angular-cli-6-under-the-hood-builders-demystified-f0690ebcf01" target="_blank" rel="noopener">Angular CLI under the hood — builders demystified</a>。</p>
<!-- readMore -->
<p>今天我们将探究底层并从头开始创建自定的构建器。</p>
<h2 id="Angular-CLI构建"><a href="#Angular-CLI构建" class="headerlink" title="Angular CLI构建"></a>Angular CLI构建</h2><p>Angular CLI从6+版本开始不再使用之前老版本的，而采用了新的结构，划分成更小的模块。</p>
<p>事实上，Angular CLI不会对<em>angular.json</em>中提供的配置做处理，它只是包装了<a href="https://github.com/angular/angular-cli/tree/7.2.x/packages/angular_devkit" target="_blank" rel="noopener">Angular Dev Kit</a>并触发构建目标，简单来说：</p>
<ul>
<li>Angular CLI包中有很多预定义命令，帮助和CLI相关的东西。</li>
<li>Archiet包会处理<em>angular.json</em>的配置。它需要将构建目标映射成相关的构建器，然后再创建并将<em>angular.json</em>对应参数传递给构建器。</li>
<li>构建器器是真正干活的。比如<a href="https://github.com/angular/angular-cli/tree/7.2.x/packages/angular_devkit/build_angular/src/browser" target="_blank" rel="noopener">BrowserBuilder</a>为浏览器运行webpack，<a href="https://github.com/angular/angular-cli/tree/7.2.x/packages/angular_devkit/build_angular/src/karma" target="_blank" rel="noopener">KarmaBuilder</a>会在测试的时候启动Karma和运行webpack等等。</li>
</ul>
<h2 id="Angular-CLI命令和结构目标"><a href="#Angular-CLI命令和结构目标" class="headerlink" title="Angular CLI命令和结构目标"></a>Angular CLI命令和结构目标</h2><p>当我们运行<code>ng serve</code>和<code>ng test</code>或者任何<a href="https://github.com/angular/angular-cli/wiki" target="_blank" rel="noopener">预定义</a>的命令时候，会发生以下事情：</p>
<ul>
<li>Angular CLI命令会转变成相关结构目标</li>
<li>构建器被创建</li>
<li>相关参数会被传递给构建器</li>
</ul>
<p>当你运行自定义的构建器时候，只会发生上述的二和三。</p>
<p>简而言之，有一个通用的命令：<code>ng run</code>，它接受结构目标作为参数（格式为<code>project: target</code>）。</p>
<p>而任何Angular CLI预定义命令都会映射成结构目标而可以用ng run运行。比如说：</p>
<ul>
<li><code>ng build</code>: <code>ng run my-cool-project:build</code></li>
<li><code>ng test</code>: <code>ng run my-cool-project:test</code></li>
</ul>
<p>更美好的是你可以创建自己的构建器，并起名任意的目标名称。</p>
<p>比如说你可以为自己的构建器起名为<code>my-target</code>，并执行<code>ng run</code>命令：<code>ng run my-cool-project:my-target</code></p>
<p>或者你可以直接替换任意已经存在的目标并执行Angular CLI预定义目标。因为如上所述，Angular CLI会被映射成相关的结构目标</p>
<h2 id="结构目标配置"><a href="#结构目标配置" class="headerlink" title="结构目标配置"></a>结构目标配置</h2><p>让我们进一步查看<em>angular.json</em>配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"$schema"</span>: <span class="string">"./node_modules/@angular/cli/lib/config/schema.json"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"newProjectRoot"</span>: <span class="string">"projects"</span>,</span><br><span class="line">  <span class="attr">"projects"</span>: &#123;</span><br><span class="line">    <span class="attr">"example"</span>: &#123;</span><br><span class="line">      <span class="attr">"root"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"sourceRoot"</span>: <span class="string">"src"</span>,</span><br><span class="line">      <span class="attr">"projectType"</span>: <span class="string">"application"</span>,</span><br><span class="line">      <span class="attr">"prefix"</span>: <span class="string">"app"</span>,</span><br><span class="line">      <span class="attr">"schematics"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"architect"</span>: &#123;</span><br><span class="line">        <span class="attr">"build"</span>: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        "serve": &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个项目都有个入口叫做结构，并且包含所有的配置。在上述的demo中，我们只有一个项目叫做<code>example</code>，并且有两个结构目标：<code>build</code>和<code>serve</code></p>
<p>如果你想要有一个新的机构目标叫做<code>format</code>，你可以像这样添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;$schema&quot;: &quot;./node_modules/@angular/cli/lib/config/schema.json&quot;,</span><br><span class="line">  &quot;version&quot;: 1,</span><br><span class="line">  &quot;newProjectRoot&quot;: &quot;projects&quot;,</span><br><span class="line">  &quot;projects&quot;: &#123;</span><br><span class="line">    &quot;example&quot;: &#123;</span><br><span class="line">      &quot;root&quot;: &quot;&quot;,</span><br><span class="line">      &quot;sourceRoot&quot;: &quot;src&quot;,</span><br><span class="line">      &quot;projectType&quot;: &quot;application&quot;,</span><br><span class="line">      &quot;prefix&quot;: &quot;app&quot;,</span><br><span class="line">      &quot;schematics&quot;: &#123;&#125;,</span><br><span class="line">      &quot;architect&quot;: &#123;</span><br><span class="line">        &quot;build&quot;: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;serve&quot;: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;format&quot;: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个结构目标又包含三个属性：</p>
<ul>
<li><p><code>builder</code>：构建器的路径。</p>
<p>路径格式为<code>[package-path]:[builder-name]</code>，其中<code>[package-path]</code>是在<em>package.json</em>文件中定义过的入口依赖，而<code>[builder-name]</code>是<em>builder.json</em>文件中入口之一（我们之后还会讨论）。</p>
</li>
<li><p><code>options</code> ：构建器的配置。必须和构建器模式匹配，否则命令将会失败。</p>
</li>
<li><p><code>configurations</code>：替代目标（比如prod，dev等）选项的集合。这是可选属性。</p>
</li>
</ul>
<p>我们说了足够的理论背景，下面进入实战吧。</p>
<h2 id="创建自己的构建器"><a href="#创建自己的构建器" class="headerlink" title="创建自己的构建器"></a>创建自己的构建器</h2><p>我不喜欢做徒劳的事，所以我想出了一个好点子，它可比<em>Hello World Builder</em>厉害多了，但是又是相当的简单。</p>
<p>让我们来想象一个场景，你想要展示你的应用上次构建的的时间日期，我们可以把它放在某个文件中，系统将会加载获取然后在页脚展示。</p>
<p>我们要做的就是实现一个创建时间日期文件的构建器。</p>
<h3 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h3><p>一个包可以创建多个构建者，但是在我们例子中只有一个。</p>
<p>首先你需要为构建者包创建文件夹，然后加入<em>package.json</em>文件（结构认定构建者包是npm包）。</p>
<p><em>package.json</em>会多出一个入口：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"builders": "builders.json"</span><br></pre></td></tr></table></figure>
<p>提示：文件名不一定必须是<code>builders.json</code>，可以是任意你想的。</p>
<h3 id="builder-json"><a href="#builder-json" class="headerlink" title="builder.json"></a>builder.json</h3><p><code>builder.json</code>将会描述你的构建器。它是一个遵循Angular构建器结构的JSON文件，它将有以下结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;$schema&quot;: &quot;@angular-devkit/architect/src/builders-schema.json&quot;,</span><br><span class="line">  &quot;builders&quot;: &#123;</span><br><span class="line">    &quot;builder-name&quot;: &#123;</span><br><span class="line">      &quot;class&quot;: &quot;path-to-builder-class&quot;,</span><br><span class="line">      &quot;schema&quot;: &quot;path-to-builder-schema&quot;,</span><br><span class="line">      &quot;description&quot;: &quot;builder-description&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    ... more builders definitions</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个<code>builders.json</code>文件可以有多个构建器定义。</p>
<h3 id="构建器定义"><a href="#构建器定义" class="headerlink" title="构建器定义"></a>构建器定义</h3><p>每个构建器都有两个属性：</p>
<ol>
<li><code>class</code>：实现了<code>Builders</code>接口的Javascript文件路径。结构将会解析配置和创建实例。你可以在这里找到该接口定义。</li>
<li><code>schema</code>：定义了构建器配置的json schema路径（在结构中就是property属性）。结构将会验证配置是否符合schema定义，如果出错将会构建失败。</li>
</ol>
<p>这里是我们的自定义的<em>builders.json</em>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;$schema&quot;: &quot;@angular-devkit/architect/src/builders-schema.json&quot;,</span><br><span class="line">  &quot;builders&quot;: &#123;</span><br><span class="line">    &quot;file&quot;: &#123;</span><br><span class="line">      &quot;class&quot;: &quot;./timestamp.builder.js&quot;,</span><br><span class="line">      &quot;schema&quot;: &quot;./schema.json&quot;,</span><br><span class="line">      &quot;description&quot;: &quot;Builder that creates timestamp&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="schema-json"><a href="#schema-json" class="headerlink" title="schema.json"></a>schema.json</h3><p>我们允许开发者修改时间戳的格式和其保存路径，所以<em>schema.json</em>可以这么定义：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"id"</span>: <span class="string">"TimestampBuilderSchema"</span>,</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"Timestamp builder"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"Timestamp builder options"</span>,</span><br><span class="line">  <span class="string">"properties"</span>: &#123;</span><br><span class="line">    <span class="string">"format"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">      <span class="string">"description"</span>: <span class="string">"Timestamp format"</span>,</span><br><span class="line">      <span class="string">"default"</span>: <span class="string">"dd/mm/yyyy"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"path"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">      <span class="string">"description"</span>: <span class="string">"Path to the timestamp file"</span>,</span><br><span class="line">      <span class="string">"default"</span>: <span class="string">"./timestamp"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果开发者没有在配置中没有指定，就会用default值替代。</p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>为了格式化日期，我们使用dateformat包。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i dateformat</span><br></pre></td></tr></table></figure>
<p>我们会使用Typescript（不是强制的）来开发构建器，所以我们也会安装。</p>
<p>同时，我们也会用到使用<code>@angular-devkit/core</code>的方法和<code>@angular-devkit/architect</code>的接口。</p>
<p>为了更好的支持Typescript静态类型，我们最好也安装<code>@types</code>的<code>node</code>和<code>dateformat</code>。</p>
<p>以下是开发时候需要的依赖（<code>@angular-devkit</code>会在运行时期用到）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @angular-devkit/core @angular-devkit/architect @types/node @types/dateformat typescript</span><br></pre></td></tr></table></figure>
<h3 id="构建器"><a href="#构建器" class="headerlink" title="构建器"></a>构建器</h3><p>现在我们准备实现构建器。</p>
<p>首先我们在<em>schema.d.ts</em>文件中定义接口作为构建器配置类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> TimestampBuilderSchema &#123;</span><br><span class="line">	format: <span class="built_in">string</span>;</span><br><span class="line">	path: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后我们继承<code>Builder</code>泛型接口：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;Builder, BuilderConfiguration, BuilderContext, BuildEvent&#125; <span class="keyword">from</span> <span class="string">'@angular-devkit/architect'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Observable&#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;TimestampBuilderSchema&#125; <span class="keyword">from</span> <span class="string">'./schema'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> TimestampBuilder <span class="keyword">implements</span> Builder&lt;TimestampBuilderSchema&gt; &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> context: BuilderContext</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run(builderConfig: BuilderConfiguration&lt;Partial&lt;TimestampBuilderSchema&gt;&gt;): Observable&lt;BuildEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>run</code>方法需要返回<code>BuildEvent</code>类型的Observable：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> BuildEvent &#123;</span><br><span class="line">    success: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BuildEvent</code>将会提示结构是否执行成功，随后结构再会去告诉CLI，CLI会以合适的值退出进程。</p>
<p>在我们的例子中如果时间的文件创建成功就会返回成功标志，否则失败：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Builder, BuilderConfiguration, BuilderContext, BuildEvent&#125; <span class="keyword">from</span> <span class="string">'@angular-devkit/architect'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;bindNodeCallback, Observable, of&#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;catchError, map, tap&#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;TimestampBuilderSchema&#125; <span class="keyword">from</span> <span class="string">'./schema'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;getSystemPath&#125; <span class="keyword">from</span> <span class="string">'@angular-devkit/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;writeFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> dateFormat <span class="keyword">from</span> <span class="string">'dateformat'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> TimestampBuilder <span class="keyword">implements</span> Builder&lt;TimestampBuilderSchema&gt; &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> context: BuilderContext</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run(builderConfig: BuilderConfiguration&lt;Partial&lt;TimestampBuilderSchema&gt;&gt;): Observable&lt;BuildEvent&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">this</span>.context.workspace.root;</span><br><span class="line">    <span class="keyword">const</span> &#123;path, format&#125; = builderConfig.options;</span><br><span class="line">    <span class="keyword">const</span> timestampFileName = <span class="string">`<span class="subst">$&#123;getSystemPath(root)&#125;</span>/<span class="subst">$&#123;path&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">const</span> writeFileObservable = bindNodeCallback(writeFile);</span><br><span class="line">    <span class="keyword">return</span> writeFileObservable(timestampFileName, dateFormat(<span class="keyword">new</span> <span class="built_in">Date</span>(), format)).pipe(</span><br><span class="line">      map(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;success: <span class="literal">true</span>&#125;)),</span><br><span class="line">      tap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.context.logger.info(<span class="string">"Timestamp created"</span>)),</span><br><span class="line">      catchError(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.context.logger.error(<span class="string">"Failed to create timestamp"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> of(&#123;success: <span class="literal">false</span>&#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们分解一哈：</p>
<ol>
<li>我们先获取应用的根目录</li>
<li>然后我们获取<code>path</code>和<code>format</code>参数。他们应该在应用的<em>angular.json</em>文件配置中指明，否则就会有默认值。</li>
<li><code>getSystemPath</code>方法是获取系统准确路径的，它将和<code>path</code>结合起来作为我们需要创建出的文件路径。</li>
<li>我们使用<code>fs</code>模块的<code>writeFile</code>方法，但最终需要返回Observable对象，但<code>writeFile</code>是回调函数，因此我们用<code>bindNodeCallback</code>方法将其转为成具有返回observable对象的函数。</li>
<li>我们将<code>format</code>参数传递给<code>formatDate</code>方法，并将返回的日期写入文件中。</li>
<li>以后如果文件创建成功，我们就返回成功，否则返回失败。</li>
</ol>
<p>顺利地将源代码编译成JavaScript。</p>
<h3 id="使用构建器"><a href="#使用构建器" class="headerlink" title="使用构建器"></a>使用构建器</h3><p>现在构建器已经准备就绪，你可以通过在<em>angular.json</em>文件指定<code>timestamp</code>包的相关路径使用它：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"architect"</span>: &#123;</span><br><span class="line">        <span class="string">"timestamp"</span>: &#123;</span><br><span class="line">          <span class="string">"builder"</span>: <span class="string">"[relative-path-to-timestamp-package]:file"</span>,</span><br><span class="line">          <span class="string">"options"</span>: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者将它打包成npm包，并在本地安装：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm pack</span><br><span class="line">cp angular-builders-timestamp<span class="number">-1.0</span><span class="number">.0</span>.tgz [host-application-root]</span><br><span class="line">cd [host-application-root]</span><br><span class="line">npm i -D angular-builders-timestamp<span class="number">-1.0</span><span class="number">.0</span>.tgz</span><br></pre></td></tr></table></figure>
<p><em>angular.json</em></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"architect": &#123;</span><br><span class="line">        "timestamp": &#123;</span><br><span class="line">          "builder": "@angular-builders/timestamp:file",</span><br><span class="line">          "options": &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>我希望你能享受这篇文章并能很好的理解构建器。</p>
<p>所有的<code>timestamp</code>构建器（上述demo）源代码都可以在<a href="https://github.com/just-jeb/angular-builders/tree/7.x.x/packages/timestamp" target="_blank" rel="noopener">这里</a>找到。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/02/动手写webpack：代码分离/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/02/动手写webpack：代码分离/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-02T14:12:08+08:00">
                2020-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="动手写webpack：代码分离"><a href="#动手写webpack：代码分离" class="headerlink" title="动手写webpack：代码分离"></a>动手写webpack：代码分离</h1><p>代码分离的意义在于将模块分到不同的chunk中，减小文件的大小，同时可以按需加载或者并行加载文件，加快响应时间。常用的代码分离有三种：</p>
<ol>
<li>入口起点：配置entry参数手动分离代码。</li>
<li>防止重复：配置optimization去重和分离chunk。</li>
<li>动态导入：调用import函数分离代码。</li>
</ol>
<!-- read more -->
<p>这里我们只实现第三种分离方式。</p>
<h2 id="chunk、module和bundle"><a href="#chunk、module和bundle" class="headerlink" title="chunk、module和bundle"></a>chunk、module和bundle</h2><p>在研究代码分离之前，我们先明白这三个名词，尤其是chunk的含义，因为分离主要建立在它的基础之上。</p>
<ul>
<li>module可以理解成一个文件，每个文件就是modu了，导入某个文件时就是导入了某个module。</li>
<li>chunk是多个module的集合，可以是一对一，也可以是一对多。如何结合module就是拆分的逻辑。</li>
<li>bundle可以看作是一对一的chunk，是chunk的最后输出，中间还经历了压缩等步骤。</li>
</ul>
<h2 id="分离点选择"><a href="#分离点选择" class="headerlink" title="分离点选择"></a>分离点选择</h2><p>在这里我们只实现第三步的代码分离，即识别<code>import</code>函数调用。当分离遇到导入相同的模块怎么办，有几点需要遵守：</p>
<ol>
<li>当主chunk也加载了模块，模块应该打包到主chunk中。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; z &#125; <span class="keyword">from</span> <span class="string">"./common"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">afn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; z &#125; <span class="keyword">from</span> <span class="string">"./common"</span>;</span><br><span class="line"><span class="keyword">import</span>(<span class="string">"./a"</span>).then(<span class="function">(<span class="params">a</span>) =&gt;</span> a.afn());		<span class="comment">// common.js会打包到mainchunk中</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>异步的chunk加载了相同的模块，主chunk并没有，模块打包到各自chunk中。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; z &#125; <span class="keyword">from</span> <span class="string">"./common"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">afn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; z &#125; <span class="keyword">from</span> <span class="string">"./common"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bfn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">"./a"</span>).then(<span class="function">(<span class="params">a</span>) =&gt;</span> a.afn());</span><br><span class="line"><span class="keyword">import</span>(<span class="string">"./b"</span>).then(<span class="function">(<span class="params">&#123; bfn &#125;</span>) =&gt;</span> bfn()); <span class="comment">// a.js和b.js的chunk都有common.js模块</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>和第一点类似，如果异步的chunk入口被主chunk导入，直接把整个异步chunk导入到主chunk中。</li>
</ol>
<p>import函数在AST表示成Import类型，第一个参数就是模块名。即：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  Import(path) &#123;</span><br><span class="line">  	asyncDeps.add(path.parent.arguments[<span class="number">0</span>].value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="构建chunk"><a href="#构建chunk" class="headerlink" title="构建chunk"></a>构建chunk</h2><p> 对于模块而言，需要区分同步模块和异步模块。同步模块作为chunk的一部分加入，但是如果加入的父chunk包含，则不用再加入。而异步模块作为chunk的入口，需要重新实例化chunk，同理如果父chunk也已经包含了这个模块，我们也不再需要新chunk了。伪代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildChunk</span>(<span class="params">entryModule, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parentIncludeModule(entryModule, parent)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> chunk = <span class="keyword">new</span> Chunk(entryModule, parent);</span><br><span class="line">  addModuleToChunk(entryModule, chunk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addModuleToChunk</span>(<span class="params">module, chunk</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parentIncludeModule(<span class="built_in">module</span>, chunk)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> childChunk = isParentChunk(<span class="built_in">module</span>, chunk);</span><br><span class="line">  <span class="keyword">if</span> (childChunk) &#123;</span><br><span class="line">    childChunk.modules = childChunk.modules.filter(</span><br><span class="line">      (m) =&gt; m === <span class="built_in">module</span> || <span class="built_in">module</span>.syncDeps.includes(m)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  chunk.modules.push(<span class="built_in">module</span>);</span><br><span class="line">  <span class="built_in">module</span>.chunks.push(chunk); <span class="comment">// 一个模块可能属于多个chunk</span></span><br><span class="line">  <span class="built_in">module</span>.syncDeps.forEach(<span class="function">(<span class="params">syncDep</span>) =&gt;</span> addModuleToChunk(syncDep.module, chunk));</span><br><span class="line">  <span class="built_in">module</span>.asyncDeps.forEach(<span class="function">(<span class="params">asyncDep</span>) =&gt;</span> buildChunk(asyncDep.module, chunk));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>parentIncludeModule函数表示模块是否已经在其加入的chunk的父chunk中。</p>
<p>buildChunk函数新建了chunk，其中的判断符合原则二。addModuleToChunk函数将模块加入chunk中，第一个判断符合原则三。而随后的过滤是什么意思呢，我们来假设一个场景：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">"./a"</span>).then(<span class="function">(<span class="params">&#123; afn &#125;</span>) =&gt;</span> afn());</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> c = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; c &#125; <span class="keyword">from</span> <span class="string">"./c"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">"./a"</span>;</span><br></pre></td></tr></table></figure>
<p>index入口文件先同步导入了c文件，c文件中动态导入了a文件，随后入口文件再次同步导入了a文件。此时策略为了遵从原则xx，从而打包到其父chunk，这里应该是主chunk。但是在addModuleToChunk函数中我们先去处理同步模块，就会先去处理c模块，导致a模块还是成为了新chunk的入口模块。所以我们需要修正这种情况，当导入a模块时候，查找子chunk中是否有该模块，有的话从子chunk中剔除其本身以及依赖模块。因为同步的导入会永远发生在动态的导入之前，所以只需要多处理这种情况就可以了。</p>
<p>对于chunk而言，我们要区分主chunk和其他chunk，因为主chunk比其他chunk多出了运行时代码。但两者又需要解析模块的运行代码，所以抽离出父类的chunk。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chunk</span> </span>&#123;</span><br><span class="line">	buildOutput() &#123;&#125;</span><br><span class="line">	buildModules() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainChunk</span> </span>&#123;</span><br><span class="line">  buildOutput(total) &#123;</span><br><span class="line">    <span class="keyword">let</span> buffers = [];</span><br><span class="line">    <span class="keyword">if</span> (total &gt; <span class="number">1</span>) &#123;	<span class="comment">// 根据chunks数量决定模板</span></span><br><span class="line">      buffers.push(dynamicTemplate);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      buffers.push(syncTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> buffers;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从前一章得到的depTree对象构建出的chunks对象如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  MainChunk &#123;</span><br><span class="line">    id: <span class="number">0</span>,</span><br><span class="line">    parent: <span class="literal">null</span>,</span><br><span class="line">    entry: [Module],</span><br><span class="line">    modules: [ [Module], [Module], [Module], [Module] ],</span><br><span class="line">    filename: <span class="string">'bundle'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  Chunk &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    parent: [MainChunk],</span><br><span class="line">    entry: [Module],</span><br><span class="line">    modules: [ [Module] ],</span><br><span class="line">    filename: <span class="string">'1-bundle'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="拼接output-js"><a href="#拼接output-js" class="headerlink" title="拼接output.js"></a>拼接output.js</h2><p> 拼接output.js的过程和上章是差不多的，逻辑都已经封住在了chunk类内部。注意的是，修正后内部的modules数量可能为空，此时不再创建文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chunks = sources.chunks;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; chunks.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> chunk = chunks[i];</span><br><span class="line">    <span class="keyword">if</span> (empty(chunk.modules)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> buffers = chunk.buildOutput(chunks.length);</span><br><span class="line">    writeFile(chunk.filename, buffers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源代码可以看<a href="https://github.com/ccanister/fake-webpack#fake-webpack" target="_blank" rel="noopener">这里</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/29/动态表单/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/29/动态表单/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-29T09:57:04+08:00">
                2020-09-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="动态表单"><a href="#动态表单" class="headerlink" title="动态表单"></a>动态表单</h1><p>后台项目中一般往往都是增删改查，增和改操作都是表单操作，查一般是列表页或者详情页。其实Angular的表单支持算是蛮好的，双向绑定的机制可以在视图数据改变的时候，验证或者和其他表单项联动等操作。但是业务逻辑大部分是相似的，往往代码都是重复的，造成了复制和粘贴。所以动态表单在后台地位还是很大的。</p>
<!-- readMore -->
<h2 id="简单版的动态表单"><a href="#简单版的动态表单" class="headerlink" title="简单版的动态表单"></a>简单版的动态表单</h2><p>动态表单无非就是根据业务对象的元数据创建动态表单，得益于Angular的双向绑定，数据的改变会影响ui，用户改变ui的同时也会反向影响数据，所以只需要根据模型的类型渲染组件即可。</p>
<p>最简单的方法是在模板中使用<code>ngSwitch</code>组件判断类型。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-container</span> *<span class="attr">ngSwitch</span>=<span class="string">"field.type"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> *<span class="attr">ngSwitchCase</span>=<span class="string">"string"</span> [<span class="attr">formControl</span>]=<span class="string">"field.control"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> *<span class="attr">ngSwitchCase</span>=<span class="string">"textarea"</span> [<span class="attr">formControl</span>]=<span class="string">"field.control"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngSwitchDefault</span> [<span class="attr">ngComponentOutletInjector</span>]=<span class="string">"injector [ngComponentOutlet]="</span><span class="attr">field.editor</span>"&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后一种情况是用户自定义的组件。</p>
<p>这种表单很简单，也可以用，但是有几个缺点：</p>
<ol>
<li>没有合适的DSL语言去描述模型</li>
<li>模板逻辑过重，一般不提倡把逻辑写在模板里，而是抽到服务中。此外模板有些信息是重复的，应该抽离出来。</li>
<li>自定义组件可能只想传入templateRef类型，而不是引入component。</li>
<li>无法做到表单联动。</li>
</ol>
<h2 id="JSON-Schema"><a href="#JSON-Schema" class="headerlink" title="JSON Schema"></a>JSON Schema</h2><p>业内描述动态表单模型往往都会用JSON Schema，它可以规范数据，描述JSON数据所包含的字段、以及字段值的类型，以及依赖关系等。我们以账号密码的表单举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line">  <span class="string">"properties"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: &#123;</span><br><span class="line">    	<span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">    	<span class="string">"maxLength"</span>: <span class="number">11</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"password"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">      <span class="string">"pattern"</span>: <span class="string">"^[A-Z0-9]&#123;9&#125;$"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"email"</span>: &#123;</span><br><span class="line">    	<span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">    	<span class="string">"format"</span>: <span class="string">"email"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"required"</span>: [ <span class="string">"name"</span>, <span class="string">"password"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上我们可以看出要JSON Schmea可以包含数据的的类型、最大长度和正则等验证，如果是object类型还要指名包含的字段等等，非常适合描述表单。有了JSON Schema之后，我们该如何判断给定的数据是否符合其规范呢？比较流行的的库有ajv，他可以用来校验且性能不错。</p>
<p>不仅如此，我们还可以对JSON Schema一些字段做特殊处理，比如说maxLength直接作为输入框的maxLength属性，防止用户输入过长；multipleOf当作数字输入框的步长等等。</p>
<p>我们也需要自定义属性，如组件的大小、class等等，我们都统一定义在ui字段，防止字段太多破坏之前结构。</p>
<p>有了DSL语言，我们接着需要抽离出视图的逻辑，视图往往离不开model层，所以我们先来创建model层。</p>
<h2 id="model"><a href="#model" class="headerlink" title="model"></a>model</h2><h3 id="数据流动"><a href="#数据流动" class="headerlink" title="数据流动"></a>数据流动</h3><p>整个表单数据从根节点向子节点单向流动。表单可以看作组合模式的体现。组合模式是组合多个对象形成树形结构以表示具有“整体-部分”关系的层次结构。表单里有几种项：表单对象、表单数组和表单项。表单项可以独立出现，也可以被包裹到表单数组或者表单对象中，还可以和表单数组一起组成表单对象。表单数组一般往往由表单对象或者表单项组成。可以看出表单数组和表单对象都是容器，而表单项则是叶子节点。通常根节点往往是表单对象，从而形成树形结构。</p>
<p>当对表单设置值的时候，递归地先设置表单项的值和校验是否有效，然后容器会去收集子表单项的值计算出值和校验。伪代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setValue</span>(<span class="params">values: any</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> FormGroup) &#123;</span><br><span class="line">    <span class="keyword">this</span>.children.forEach(<span class="function">(<span class="params">child, name</span>) =&gt;</span> child.setValue(values[name]));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> FormArray) &#123;</span><br><span class="line">     <span class="keyword">this</span>.children.forEach(<span class="function">(<span class="params">child, index</span>) =&gt;</span> child.setValue(values[index]));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.updateValue();</span><br><span class="line">  <span class="keyword">this</span>.runValidators();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是对表单根节点设置值的情况，如果对表单某一项设置值的时候，当设置值完毕的时候，需要通知父节点更新值，直到冒泡到根节点。</p>
<p>因此无论是对表单根节点设置值还是对某一项设置值，数据的流动都是从叶子节点开始冒泡向上直到根节点。</p>
<h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><p>表单校验一般分成两种，同步校验和异步校验。同步校验往往是必填项、最大长度等，异步校验则是判断名字重复等，和后台交互较多。所以优先执行同步校验逻辑，如果有返回错误信息就不再执行异步校验。无论是哪种校验，都应该从左往右执行校验逻辑，所以取得校验器后就将他们组合方便之后的执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">composeSync</span>(<span class="params">validators</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="params">value</span> =&gt;</span> mergeErrors(validators.map(<span class="function"><span class="params">validator</span> =&gt;</span> validator(value)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">composeAsync</span>(<span class="params">validators</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="params">value</span> =&gt;</span> forkJoin(validators).pipe(map(<span class="function"><span class="params">validators</span> =&gt;</span> mergeErrors(validators.map(<span class="function"><span class="params">validator</span> =&gt;</span> validator(value))))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runValidators</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cancelAsyncSubscription();</span><br><span class="line">    <span class="keyword">const</span> errors = <span class="keyword">this</span>.syncValidators ? <span class="keyword">this</span>.syncValidators(value) : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!errors &amp;&amp; <span class="keyword">this</span>.asyncValidators) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subscription = <span class="keyword">this</span>.asyncValidators.subscribe(<span class="function"><span class="params">errors</span> =&gt;</span> <span class="keyword">this</span>.setErrors(errors))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果上次异步校验的结果未返回，将会取消执行。此外，这里用了forkJoin操作符，因为一般都是和后台交互，都是一次性的流，如果这个流的数据是长期流通的，会导致一直阻塞在这里。</p>
<p>除此之外，我们在执行自定义校验之前，需要先执行schema的验证逻辑，防止执行不必要的自定义校验。ajv的错误格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  <span class="string">"keyword"</span>: <span class="string">"required"</span>,</span><br><span class="line">  <span class="string">"dataPath"</span>: <span class="string">".password"</span>,</span><br><span class="line">  <span class="string">"schemaPath"</span>: <span class="string">"#/required"</span>,</span><br><span class="line">  <span class="string">"params"</span>: &#123;<span class="string">"missingProperty"</span>:<span class="string">"password"</span>&#125;,</span><br><span class="line">  <span class="string">"message"</span>:<span class="string">"必填项"</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>此时表单根节点和password单个表单项的校验结果是相同的，一般很少会对表单对象或者表单数组设置校验规则，所以在对表单项设置数据的时候，尽量不去触发父节点的校验。为了让父节点的错误信息和子节点的错误信息是一样的，我们把子节点的错误信息冒泡传播，向上设置。这样判断表单是否有错误的，只要看它的error是否有值即可，而不用收集子节点状态。</p>
<p>其实Angular内部已经实现了FormGroup、FormArray和FormControl表单model。但是在这里我们并不会直接用它：</p>
<h2 id="视图抽离"><a href="#视图抽离" class="headerlink" title="视图抽离"></a>视图抽离</h2><p>我们先来提取重复的视图逻辑。</p>
<h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><p>一个完整的表单应该包含以下元素：</p>
<p><img src="/2020/09/29/动态表单/zhaorenjie/Documents/blog/source/_posts/动态表单/表单项.png" alt="表单项"></p>
<center>表单项</center>

<ul>
<li>是否必填的标志</li>
<li>表单标题</li>
<li>帮助信息</li>
<li>文字框的提示消息</li>
<li>错误消息</li>
<li>更多描述</li>
</ul>
<p>因此这里只有输入框组件是不一样的，可以当作插槽。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"label"</span> [<span class="attr">attr.for</span>]=<span class="string">"id"</span> [<span class="attr">class.required</span>]=<span class="string">"required"</span>&gt;</span></span><br><span class="line">      &#123;&#123; title &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">tooltip</span> *<span class="attr">ngIf</span>=<span class="string">"optionalHelp"</span> [<span class="attr">title</span>]=<span class="string">"optionalHelp"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">type</span>=<span class="string">"question-circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tooltip</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"control"</span> [<span class="attr">class.has-error</span>]=<span class="string">"showError"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ng-content</span>&gt;</span><span class="tag">&lt;/<span class="name">ng-content</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extra</span> *<span class="attr">ngIf</span>=<span class="string">"description"</span> [<span class="attr">innerHTML</span>]=<span class="string">"description"</span>&gt;</span><span class="tag">&lt;/<span class="name">extra</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">explain</span> *<span class="attr">ngIf</span>=<span class="string">"showError"</span>&gt;</span>&#123;&#123;error&#125;&#125;<span class="tag">&lt;/<span class="name">explain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样每个表单组件都可以包裹在其中，包括自定义组件，而不用手动得写重复代码。</p>
<h3 id="其他数据"><a href="#其他数据" class="headerlink" title="其他数据"></a>其他数据</h3><p>其他数据范围比较广，常见的有：</p>
<ul>
<li>数据源：包括远程的，用来渲染select组件这种</li>
<li>ui相关：比如class、size等等</li>
<li>验证器等</li>
<li>默认值</li>
</ul>
<h3 id="视图隔离"><a href="#视图隔离" class="headerlink" title="视图隔离"></a>视图隔离</h3><p> 动态的组件，因为要从之前的模板剥离出来，所以不能在用<code>ngComponentOutlet</code>指令了。其实内置组件和自定义组件在Angular看来没有区别，都是要动态创建的组件。所以我们可以用keyvalue形式定义有哪些组件，再传入key取得渲染的组件，最后用<code>ViewContainerRef</code>视图容器动态创建。例如我们自定义了输入框的组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义组件</span></span><br><span class="line">widgets.set(<span class="string">"input"</span>, CustomInputCompoennt);</span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="keyword">const</span> componentClass = widgets.get(<span class="string">"input"</span>);</span><br><span class="line"><span class="keyword">const</span> componentFactory = resolver.resolveComponentFactory&lt;Widget&lt;FormProperty&gt;&gt;(componentClass);</span><br><span class="line"> container.createComponent(componentFactory);</span><br></pre></td></tr></table></figure>
<p>用这种形式的好处就不必再为自定义组件编写多的代码，统一两种风格。</p>
<p>一般会内置几个表单项组件，例如输入框和单选框等等，但是也避免不了自定义表单项组件。Angular动态创建的视图有两种：template和component。template需要拿到定义好的templateRef，所以我们可以规定它必须写在表单内部，通过指令获取即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dynamic-form&gt;</span><br><span class="line">	&lt;ng-template sf-row=<span class="string">"type"</span>&gt;</span><br><span class="line">		...</span><br><span class="line">	&lt;<span class="regexp">/ng-template&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dynamic-form&gt;</span><br><span class="line"><span class="comment">// js</span></span><br><span class="line">@Directive(&#123;</span><br><span class="line">  selector: <span class="string">'[sf-row]'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SFTemplateDirective</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  @Input(<span class="string">'sf-row'</span>) path: string;</span><br><span class="line">  private _renders = <span class="keyword">new</span> <span class="built_in">Map</span>&lt;string, TemplateRef&lt;<span class="keyword">void</span>&gt;&gt;();</span><br><span class="line">  <span class="keyword">constructor</span>(private templateRef: TemplateRef&lt;void&gt;) &#123;&#125;</span><br><span class="line">  ngOnInit(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._renders.set(<span class="keyword">this</span>.path, <span class="keyword">this</span>.templateRef);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写在表单内部还有一个好处，就是可以把指令的_renders放到表单组件去，在构造器中注入表单组件，并加上@Host修饰器，表示强依赖。</p>
<p>其次是</p>
<h2 id="表单联动"><a href="#表单联动" class="headerlink" title="表单联动"></a>表单联动</h2><p>某个表单项的数据变化时候，往往会影响其他表单项，比如数据源或者是否显示。举个例子，现在有两种登录方式，一种是账号密码登陆，还一种是手机验证码登陆。我们在勾选不同的登录方式时候，呈现的界面也是不同的。通常我们会在模板中指明登陆方式，利用if/else语句判断：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-container</span> *<span class="attr">ngIf</span>=<span class="string">"type==='password'"</span>&gt;</span></span><br><span class="line">	....</span><br><span class="line"><span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ng-container</span> *<span class="attr">ngIf</span>=<span class="string">"type==='mobile'"</span>&gt;</span></span><br><span class="line">	....</span><br><span class="line"><span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样做是可行的，但是如果现在又多了一个变量判断登录方式怎么办？比如说他勾选了男孩的性别，也能显示密码登陆。于是我们又得在模版中多一个变量判断，导致模板变得很臃肿。一般提倡逻辑写在组件或者服务中，模板的判断太多让人捉摸不透。</p>
<p>所以我们将会这种判断逻辑抽取出来。我们需要组合多种变量，在模板中可以直接将逻辑写死，但是抽离出来后，我们需要在每个变量变化后回调判断，就像这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> [(<span class="attr">ngModel</span>)]=<span class="string">"type"</span> (<span class="attr">ngModelChange</span>)=<span class="string">"check()"</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> [(<span class="attr">ngModel</span>)]=<span class="string">"sex"</span> (<span class="attr">ngModelChange</span>)=<span class="string">"check()"</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ng-container</span> *<span class="attr">ngIf</span>=<span class="string">"mobile.visible"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> [(<span class="attr">ngModel</span>)]=<span class="string">"mobile.value"</span>/ &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">function check() &#123;</span><br><span class="line">	mobile.visible = this.type === "password" || sex === "man"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在模板中需要动态显示的表单项，用visible变量标示是否显示。即在表单中，动态显示的表单项model是永远存在的，变化的是ui。这个判断的逻辑只能在该表单中使用。有两个原因，第一个是动态判断的DSL不够通用，完全是强逻辑，最好是JSON字段就可以表示，第二个是需要在模板加上ngModelChange的回调，造成耦合太强。</p>
<p>针对第一个问题，我们可以模仿校验器的使用。因为我们这个动态都是由着表单项的数据变化而变化，所以可以自定义DSL:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visibleIf: &#123; <span class="attr">type</span>: <span class="function"><span class="params">value</span> =&gt;</span> value === <span class="string">"password"</span> &#125;</span><br></pre></td></tr></table></figure>
<p>type键表示是哪个表单项，当表单项符合值的函数调用时就显示。再精简一点，可以直接去掉函数，直接用数组表达<code>[&quot;password&quot;]</code>，因为可能会有多个值符合显示。再进一层，我们可以表达与和或的关系：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visibleIf: &#123; <span class="attr">type</span>: &#123;<span class="attr">value</span>: [<span class="string">"password"</span>], <span class="attr">rel</span>: <span class="string">"and"</span>&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>这样的表达能覆盖大部分的场景。</p>
<p>第二个问题，我们可以改成流的合并。之前的表达都是命令式，比如选择完性别后我们需要主动监听ngModel回调，最好是选择完后数据能够主动推给我们，而不是被动去监听。这时候rxjs流就派上用场了，每个表单项内部都有<code>valueChanges</code>变量，我们订阅后，当表单值改变时候，会推送数据过来。所以根据上述的demo我们可以这样去写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> paths = <span class="built_in">Object</span>.keys(visibleIf);</span><br><span class="line"><span class="keyword">const</span> binds = paths.map(<span class="function"><span class="params">path</span> =&gt;</span> <span class="keyword">this</span>.searchProperty(path).valueChange.pipe(map(<span class="function"><span class="params">value</span> =&gt;</span> visibleIf[path](value)))</span><br><span class="line">combineLatest(binds).pipe(map(<span class="function"><span class="params">values</span> =&gt;</span> values.indexOf(<span class="literal">true</span>) !== <span class="number">-1</span>),distinctUntilChanged()).subscribe(<span class="function"><span class="params">visible</span> =&gt;</span> <span class="keyword">this</span>.visible = visible);</span><br></pre></td></tr></table></figure>
<p>上述的代码表现了或的关系，可以自行合并与和或的关系。rxjs流的出现，使得我们不再监听ngModel就可以拿到值，使得联动具有一定的通用行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是对动态表单的思考，更多参考了<code>delon/forms</code>和<code>ui-model</code>两个项目，通过他们的相同点和不同点分析。一般实现了表单联动后，就能解决后台大部分场景了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/23/webpack打包优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/23/webpack打包优化/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-23T09:56:11+08:00">
                2020-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="webpack打包优化"><a href="#webpack打包优化" class="headerlink" title="webpack打包优化"></a>webpack打包优化</h1><p>最近发现打包后的js文件日益增大，想着之前有看过webpack的优化文章，能不能再次用上。可惜Angular在v6的时候不再支持自定义配置文件，所以能做的事是有限的。</p>
<h2 id="查看文件体积分布"><a href="#查看文件体积分布" class="headerlink" title="查看文件体积分布"></a>查看文件体积分布</h2><p>webpack有多种方法能查看打包后的体积分布，比较直观化的是<code>webpack-bundle-analyzer</code>插件，能图形化的显示打包后的文件大小以及由哪些模块组成。使用方法比较简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-bundle-analyzer</span><br><span class="line">ng build --prod --stats-json &amp;&amp; webpack-bundle-analyzer dist/stats.json</span><br></pre></td></tr></table></figure>
<p>项目打包后的分布如下：</p>
<p><img src="/2020/09/23/webpack打包优化/zhaorenjie/Desktop/optimize/webpack-bundle-analyzer.png" alt="webpack-bundle-analyzer"></p>
<p>可以看到比较大的文件是main文件和scripts文件，这两个在首页时都会加载，所以尤其需要优化。其他的文件都是懒加载的模块，但都无法分析内部模块，所以还需要借助另一个插件<code>source-map-explorer</code>，它可以解析每个文件的模块分布、大小和占比等，使用方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g source-map-explorer </span><br><span class="line">ng build --prod --source-map</span><br><span class="line">source-map-explorer dist<span class="comment">/*.js</span></span><br></pre></td></tr></table></figure>
<p>最后一步需要指定要分析的文件，不能全部一口气分析完。这里涉及到项目内部模块，就不放图了。</p>
<h2 id="体积优化"><a href="#体积优化" class="headerlink" title="体积优化"></a>体积优化</h2><ol>
<li><p>scripts的优化：scripts会打包没有直接导入到项目中，但第三方库又依赖的包，往往写在angular.json文件中的assets里。比如说ng-alian脚手架的动态表单，他依赖了ajv库验证schema是否正确，但我们导入模块的时候只会导入动态表单的库，不会把ajv也引入。因为我们并不需要直接和ajv打交道，而是动态表单引用了它。如果我们不在assets里引入，项目就会报找不到依赖的错误。</p>
<p>所以scripts的库往往都是第三方库，可以通过CDN引入。这里有个权衡，还是ajv库它的大小只有二十几kb，真的有必要通过CDN去引入吗？webpack4拆分公共代码中的默认配置有一项就是公共的chunk需要大于30kb，才会拆分出新的chunk。因为尽管缩小了原先文件的大小，但是多了网络请求，有时候并不一定值得，尤其同一域名下并发请求数是由限制的。所以我们也可以规定只有30kb的文件才通过CDN引入。优化后的scripts文件大小：<img src="/2020/09/23/webpack打包优化/zhaorenjie/Desktop/optimize/采用min后的script.png" alt="采用min后的script"></p>
</li>
<li><p>assets目录内的导入改成http请求：assets目录属于静态目录，放置css、json等静态文件。但是如果我们直接用es规范去导入json等文件，就会把它打包进来。其实更好的方式应是http请求文件，因为都是本地文件，没有消耗。</p>
</li>
<li><p>按需导入：这个也比较常见，比如现在在用的date-fns库，没有注意使用习惯，就直接<code>import {format} from &quot;date-fns&quot;</code>，导致把整个库打包进来。</p>
<p><img src="/2020/09/23/webpack打包优化/zhaorenjie/Desktop/optimize/引入了全部date-fns.png" alt="引入了全部date-fns"></p>
<p>所以应该使用<code>import format from &quot;date-fns/format&quot;</code>，这样打包的时候只会把format打包进来。</p>
<p><img src="/2020/09/23/webpack打包优化/zhaorenjie/Desktop/optimize/按需引入的date-fns.png" alt="按需引入的date-fns"></p>
<p>不过大部分的包基本都是需要全部引入。</p>
<p>如果项目这样的导入方式较多，改起来比较麻烦，可以考虑写个ts的插件，碰到这种格式的导入重新定义ast。</p>
</li>
<li><p>避免库导入却不用：因为项目之前有后端接手过，他们尝试了一些第三方库，却忘记删除，导致引入了无用的包。可以tslint.json中添加<code>no-unused-declaration</code>的规则。</p>
</li>
<li><p>懒加载模块，这点在项目初期就已做到，暂且不表。</p>
</li>
<li><p>引入更合适的包：有时候用到的第三方库只是需要部分功能，却又不支持按需引入，导致把整个库都打包进来，造成了冗余。比如之前在用的解析yaml的js-yaml，虽然整个包体积也才40kb，但是我只需要safeLoad方法，可能只有一半的体积。于是转投<code>yamljs</code>库，体积缩小了。</p>
</li>
<li><p>主模块不引入懒加载模块</p>
</li>
<li><p>摇树优化：Angular在aot模式下会去将ts编译成es代码，并没有用到uglify的摇树优化功能。</p>
</li>
<li><p>抽取公共代码：同样，这个也是Angular内部插件完成，不过在代码组织上，文档上也推荐了如果有多个module需要引入相同的组件，要抽到shared module，否则报错。</p>
<p>不过我们看下webpack默认的splitChunks配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'async'</span>,</span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">      automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">      name: <span class="literal">true</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          priority: <span class="number">-10</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>chunks有三个选项：async表示只从异步加载的模块拆分，initial只从入口模块拆分，all包括两者。如果选了async，那么即使入口文件引入了第三方库，也不会拆分出去。也就是说当我们不改配置，是无法拆分出第三方库的。</li>
<li>minChunks：默认是1。当模块被不同chunks引用的次数大于等于这个配置值时，才会被抽离出去。假设我们把这个值改成2，会发现第三方库还是不会被分离出去。</li>
<li>cacheGroups：自定义拆分规则，default就是入口打包的规则。test可以匹配资源的绝对路径或名称，priority表示规则的优先级，默认配置里给vendors的优先级较高，如果比default低的话，第三方库被引用两次，就会被打包到业务chunk。</li>
<li>minSize：拆分出去的chunk大小必须大于这个值，单位是字节。</li>
<li>maxInitialRequests：表示允许入口并行加载的最大请求数，也可以理解是入口文件拆分出的最多文件数量，防止拆分出太多模块导致请求数量过多而得不偿失。</li>
</ul>
</li>
</ol>
<ul>
<li>maxAsyncRequests：类似maxInitialRequests，用来限制异步模块内部的并行最大请求数的。</li>
</ul>
<p>我们来看下具体案例，假设现在有这样的目录结构</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   &gt; |--src/</span><br><span class="line">   &gt; |   |--a.js</span><br><span class="line">   &gt; |   |--b.js</span><br><span class="line">   &gt; |		|--c.js</span><br><span class="line">   &gt; |   |--index.js</span><br><span class="line">   &gt; |--assets/</span><br><span class="line">   &gt; |		|--jquery.js</span><br><span class="line">   &gt; |--package.json</span><br><span class="line">   &gt; |--webpack.config.js</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>代码逻辑比较简单，index模块引入了a模块和b模块，b模块引入了c模块和underscore库，a模块也引入了c模块和underscore模块，c模块是没有依赖的独立模块。</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">"./a.js"</span>;</span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">"./b.js"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"index----------"</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./c.js"</span>);</span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">"underscore"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a-------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = fn();</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./c.js"</span>);</span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">"underscore"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"b-------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = fn();</span><br><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"c-------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = fn();</span><br></pre></td></tr></table></figure>
<p>我们对配置不做任何改动，当然入口文件要设置成index.js，打包结果发现全部文件都在index.js文件中，这是因为我们没有设置chunks选项，只会去查找异步加载的chunk。我们放开chunks的控制，改成all，发现打包出了vendors~main文件，里面只有underscore库代码。尽管c文件被引用了两次，但是属于同一个chunk，所以被分离出来。</p>
<p>我们把入口文件改造成多入口：</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123; <span class="attr">index</span>: <span class="string">"./multi/index.js"</span>, <span class="attr">a</span>: <span class="string">"./multi/a.js"</span> &#125;,</span><br></pre></td></tr></table></figure>
<p>这样a和c文件都被不同的chunk引用了，我们再来看打包结果，发现还是没有被分离出来。这是因为minSize设置的值较大，webpack认为没有必要分离出来，我们把它的值改小点，改成30，打包后发现多了<code>a~main</code>的文件，里面有a和c文件打包结果，说明分离成功。</p>
<p>接下来我们想要自定义拆分规则，把某些业务代码再分离出来，在src目录下创建locallib文件:</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> query;</span><br></pre></td></tr></table></figure>
<p>然后在a和b模块引用这个模块，需要在webpack中配置：</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cacheGroups: &#123;</span><br><span class="line">  locallib: &#123;  <span class="comment">//拆分指定文件</span></span><br><span class="line">    test: <span class="regexp">/(src\/locallib\.js)$/</span>,</span><br><span class="line">    name: <span class="string">'locallib'</span>,</span><br><span class="line">    chunks: <span class="string">'initial'</span>,</span><br><span class="line">    <span class="comment">// priority： -30</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打包后发现多了locallib的文件，说明分离成功。如果我们添加priority规则并比default设置的小，发现它被打进了<code>a~main</code>文件，这是因为locallib模块也符合default的规则，优先级又较高，所以被拆分到其规则组。神奇的是此时<code>a~main</code>文件消失了，这就是受到了maxInitialRequests影响。这时候index.js入口文件拆分出来的模块有index.js（入口文件也算）、a~index（a模块和index模块公共代码）、vendors~main（第三方库）和locallib（特定业务模块）共4个模块，大于了默认配置3，所以只能抽出3个模块。而为什么不是a~index被拆分出来，是因为它的体积最小决定的。可以修改一下这个配置成4，就可以成功打包。</p>
<p>   所以maxInitialRequests有几点注意：</p>
<ol>
<li>入口文件本身算一个请求。</li>
<li>动态加载得模块不算。</li>
<li>通过runtimeChunk拆分出的runtime不算在内。</li>
<li>只算js文件的请求，css不算在内</li>
<li>如果同时有两个模块满足cacheGroup的规则要进行拆分，但是maxInitialRequests的值只能允许再拆分一个模块，那尺寸更大的模块会被拆分出来。</li>
</ol>
<h2 id="编译速度优化"><a href="#编译速度优化" class="headerlink" title="编译速度优化"></a>编译速度优化</h2><p>这方面基本上无能为力，全靠机器性能了，说下自己在网上看到的。</p>
<ol>
<li>noParse参数：可以不解析第三方库的依赖</li>
<li>DLL链接：把第三方库提前编译好，在项目编译的时候动态链接，就可以不用编译第三方库，提高速度。</li>
<li>happypack插件多线程打包。</li>
<li>cacheLoader缓存。</li>
<li>resolve参数：modules —- 指定第三方库的目录，提高查找速度；extensions —- 常用后缀放在前面，提高查找文件速度。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/21/websocket心跳重连/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/21/websocket心跳重连/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-21T09:57:39+08:00">
                2020-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="websocket心跳重连"><a href="#websocket心跳重连" class="headerlink" title="websocket心跳重连"></a>websocket心跳重连</h1><p>websocket在一次握手后保持长连接，但是在传输过程中会有各种意外导致连接断开，为了保持连接的稳定性，需要发送定期的心跳包，如果心跳没有回应，说明连接已断开重新连接。</p>
<p>最常见的就是长时间的没有发送和接收数据，浏览器有节能策略会主动断开连接，目前测试数据来看chrome是120s到180s左右。除此外浏览器也会遇到断网和锁屏的情况。断网时候服务端发送的数据无法收到，浏览器会在send方法后才发现断网情况再关闭连接，实际测试中断网50s后左右，浏览器调用send方法后会立即关闭连接，而断网50s内，并不会立即关闭，会以50s重新一个周期检测有无重新联网，如果仍然没有网络，关闭连接。这么做的原因可能是为了防止网络抖动。锁屏时候不再执行js代码，所以也会导致长时间的没有数据发送或者接受而关闭连接。</p>
<!-- readMore -->
<p>如果服务端发生意外如报错等导致连接的断开，前端可以在onclose方法中收到不是正常关闭的事件，此时也应该触发重连。</p>
<p>所以我们需要设定心跳机制维持websocket连接，前端在定时向服务端发送ping消息，服务端为了检测网络是否正常和自己仍在工作，也需要回复pong信息。</p>
<h2 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h2><p>websocket对象暴露了一些事件绑定，如果我们需要重连，应该在onerror和onclose事件上绑定重连方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">	 reconnect();</span><br><span class="line">&#125;</span><br><span class="line">ws.onerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  reconnect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，关闭事件的event.code是1006时候意味着浏览器期望收到状态码时连接非正常关闭，就是服务端没有发送关闭帧，这时候触发重连机制。当然，也可以不判断这个状态码，因为不能保证意外的时候就是1006，任何触发关闭事件都应该重连。</p>
<p>此时真正的websocket对象被封装了起来，再对外暴露我们封装的实例的事件。如果想要直接关闭websocket连接，不再去重试的话，应该有个标志位，用户将它值为true后，就不再尝试重连。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WebscoketHeadrtBeat.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.ws.close = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.close();	<span class="comment">// 暴露默认时间</span></span><br><span class="line">		<span class="keyword">this</span>.reconnect();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">WebscoketHeadrtBeat.prototype.close = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.forbidReconnect = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">this</span>.ws.close();</span><br><span class="line">&#125;</span><br><span class="line">WebscoketHeadrtBeat.prototype.reconnect = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.forbidReconnect) <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于心跳重连，我们只需要定时发送心跳，如果后端没有及时响应，就去触发重连。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> heartCheck = &#123;</span><br><span class="line">	pingTimeout = <span class="number">15000</span>,</span><br><span class="line">	pongTimeout = <span class="number">10000</span>,</span><br><span class="line">	pingTimeoutId = <span class="literal">null</span>,</span><br><span class="line">	pongTimeout = <span class="literal">null</span>,</span><br><span class="line">	start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.pingTimeoutId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				ws.send(<span class="string">"ping"</span>);</span><br><span class="line">				<span class="keyword">this</span>.pongTimeoutId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">					ws.close();	<span class="comment">// 由close方法触发重连</span></span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;, <span class="keyword">this</span>.pingTimeout); </span><br><span class="line">	&#125;</span><br><span class="line">	reset = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(<span class="keyword">this</span>.pingTimeoutId);</span><br><span class="line">    clearTimeout(<span class="keyword">this</span>.pongTimeoutId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>浏览器收到信息后就会重置定时器，一定时间后发送ping信息，后端应该及时返回消息，保证连接的正常。如果后端没有在规定时间内返回消息，说明当前连接的不稳定，触发关闭连接且重连。</p>
<p>如果是断网情况，发送ping消息后，浏览器发现没有网络，如果距断网已经超过50s，就会直接关闭连接；否则再等待50s，防止网络抖动，再去关闭。所以pingTimeout和pongTimeout的事件最好都不要超过50s，不然会重复触发关闭和重连。</p>
<p>除此之外，重连的次数一般也是有限制的，一般不会无限重连，导致无用的连接。可以在<code>reconnect</code>方法里计数，防止重连次数过多。</p>
<h2 id="服务端心跳"><a href="#服务端心跳" class="headerlink" title="服务端心跳"></a>服务端心跳</h2><p>像我们项目主要都是后端传输数据，除了让浏览器主动发送心跳包，也可以让服务端定时发送数据。比如服务端每隔10s发送消息，如果浏览器在10s内都没有收到信息，即可关闭连接。这种方式缺点就是需要前后端需要约定好时间，不能灵活调节时间，代码相对比较死。第一种方式，服务端监听接受数据事件即可，收到数据时候立即返回消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scoket.on(<span class="string">"data"</span>, (data) =&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span> (data === <span class="string">"ping"</span>) &#123;</span><br><span class="line">		socket.write(<span class="string">"pong"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="慢重连"><a href="#慢重连" class="headerlink" title="慢重连"></a>慢重连</h2><p>假设现在服务端因为出错导致浏览器重连，重连之后服务端仍然出错，就一直在重复重连。这对带宽影响较大，我们可以设置延迟时间再去重连。</p>
<p>除了这种情况，极端情况就是断网。此时的网络不是很稳定，监听online和offline事件可能不是很准确。比如online事件触发后，进行重连后，又断网了，所以此时判断不准确。而我们短时间内的重连尝试也是没有效果的。可以模仿TCP的慢开始，在没有达到阈值的时候，重连的延迟时间是每次乘以2，达到阈值之后不再变化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> THRESHOLD = <span class="number">120</span>；	<span class="comment">// 阈值时2分钟</span></span><br><span class="line">reconnect() &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.forbidReconnect || repeatLimit &lt;= <span class="keyword">this</span>.options.repeat) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> reconnectTimeout = reconnectTimeout &lt; THRESHOLD ? reconnectTimeout * <span class="number">2</span> : THRESHOLD;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.createWebSocket();</span><br><span class="line">  &#125;, reconnectTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就可以推迟重连的时间，这样用户可能在恢复网络后之前重连成功。恢复网络后（触发online事件），应该立即重置延迟时间，再去重连达到快速恢复的效果。</p>
<p>除此外断网后，断网后一段时间延迟重试时长变得较大后，用户离开电脑或者将电脑锁屏后，浏览器并不会执行js，所以即使恢复网络了，也无法触发online事件，延迟的重试时长仍然是很大的。针对这种情况，可以设置一个定时器，当此次和上次的执行时间间隔较大时候，可认定电脑休眠，于是重置延迟时间。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://cloud.tencent.com/developer/article/1341903" target="_blank" rel="noopener">WebSocket系列之如何建立和维护可靠的连接</a></li>
<li>[<a href="https://www.cnblogs.com/1wen/p/5808276.html" target="_blank" rel="noopener">初探和实现websocket心跳重连</a>]</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/18/用node写个webscoket服务器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/18/用node写个webscoket服务器/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-18T14:05:21+08:00">
                2020-09-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="用node写个webscoket服务器"><a href="#用node写个webscoket服务器" class="headerlink" title="用node写个webscoket服务器"></a>用node写个webscoket服务器</h1><p>websocket这两年已经不是新鲜的事了，服务器可以通过它主动推送数据到客户端，替代了长轮询。最常见的就是webpack-dev-serve，当按下保存键时候浏览器会自动刷新。其中原理也是通过webscoket通知浏览器原地刷新。热更新也是基于此，会把增量更新传递给浏览器。</p>
<p>websocket服务器是TCP的应用程序，基于HTTP/1.1协议握手。利用http协议握手的话，能让webscoket服务器运行在80和443端口，一般客户端都是访问这两个端口；其次可以重用并扩展 HTTP 的Upgrade流，添加自定义首部完成协商。</p>
<!-- readMore -->
<h2 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h2><p>因为基于http协议握手，所以我们先创建一个http服务器，node内置的模块能方便得创建。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.readFile(path.join(__dirname, <span class="string">"index.html"</span>), (err, data) =&gt; &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">"Content-type"</span>: <span class="string">"text/html"</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">      res.end(<span class="string">"500"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.end(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(port, () =&gt;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server running at http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其中index.html实例化了websocket对象，来和我们的服务端通讯。</p>
<p>再来看客户端的请求头</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; GET /chat HTTP/1.1</span><br><span class="line">&gt; Host: example.com:8000</span><br><span class="line">&gt; Upgrade: websocket</span><br><span class="line">&gt; Connection: Upgrade</span><br><span class="line">&gt; Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">&gt; Sec-WebSocket-Version: 13</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<center>[取自MDN]</center>

<p>我们看下每个字段含义：</p>
<ul>
<li>Connection需要标识为Upgrade，表示客户端想要升级，同时Upgrade必须置为webscoket。最后一个Sec-WebSocket-Version表示webscoket版本，现在最新的版本就是13，之前的都应废弃。如果服务端无法理解收到的的websocket版本，则返回Sec-WebSocket-Version包含自己理解的版本。</li>
<li>Sec-WebSocket-Key是随机的字符串，服务器根据这个数据和<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>连接起来，再把结果用SHA-1编码，最后base64编码再转交给客户端。客户端做对比后发现是正确的就可以开始传输数据了。这个作用就是保证服务端是支持websocket协议，如果传给客户端的编码是不正确的，客户端将抛出错误。</li>
</ul>
<p>因此服务端返回的首部如下。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; HTTP/1.1 101 Switching Protocols</span><br><span class="line">&gt; Upgrade: websocket</span><br><span class="line">&gt; Connection: Upgrade</span><br><span class="line">&gt; Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>101响应码表示确认升级到websocket协议</li>
</ul>
<p>编码操作可以通过内置的crypto加密库解决：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAGIC_KEY = <span class="string">"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateAcceptValue</span>(<span class="params">secWsKey</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> crypto.createHash(<span class="string">"sha1"</span>)</span><br><span class="line">    .update(secWsKey + MAGIC_KEY, <span class="string">"utf8"</span>)</span><br><span class="line">    .digest(<span class="string">"base64"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而服务端除了编码操作外，还要判断upgrade首部是否是websocket，其他协议我们都不支持，如果收到的话直接返回400表示错误的请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server.on(<span class="string">"upgrade"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, socket</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (req.headers[<span class="string">"upgrade"</span>] !== <span class="string">"websocket"</span>) &#123;</span><br><span class="line">    socket.end(<span class="string">"HTTP/1.1 400 Bad Request"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 读取客户端提供的Sec-WebSocket-Key和生成编码</span></span><br><span class="line">  <span class="keyword">const</span> secWsKey = req.headers[<span class="string">"sec-websocket-key"</span>];</span><br><span class="line">  <span class="keyword">const</span> hash = generateAcceptValue(secWsKey);</span><br><span class="line">  <span class="comment">// 设置HTTP响应头</span></span><br><span class="line">  <span class="keyword">const</span> responseHeaders = [</span><br><span class="line">    <span class="string">"HTTP/1.1 101 Web Socket Protocol Handshake"</span>,</span><br><span class="line">    <span class="string">"Upgrade: WebSocket"</span>,</span><br><span class="line">    <span class="string">"Connection: Upgrade"</span>,</span><br><span class="line">    <span class="string">`Sec-WebSocket-Accept: <span class="subst">$&#123;hash&#125;</span>`</span>,</span><br><span class="line">  ];</span><br><span class="line">  <span class="comment">// 返回握手请求的响应信息</span></span><br><span class="line">  socket.write(responseHeaders.join(<span class="string">"\r\n"</span>) + <span class="string">"\r\n\r\n"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样握手就完成了，然后开始传输数据。</p>
<p>如果我们任意修改<code>MAGIC_KEY</code>的值，会发现浏览器抛出以下错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebSocket connection to <span class="string">'ws://localhost:8886/'</span> failed: <span class="built_in">Error</span> during WebSocket handshake: Incorrect <span class="string">'Sec-WebSocket-Accept'</span> header value</span><br></pre></td></tr></table></figure>
<h2 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h2><p>所有的传输协议都是通过数据帧来发送数据的，只要遵从了规范格式，浏览器解析后就能做出相应的动作。所以我们来看哈webscoket的数据帧格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<center>[取自MDN]</center>

<p>我们来结合具体的数据帧来解读，假设客户端现在向服务端发送了<code>我是大白</code>的数据，服务端收到的数据是这样的：</p>
<p><img src="/2020/09/18/用node写个webscoket服务器/zhaorenjie/Documents/blog/source/_posts/websocket/我是大白的数据帧.png" alt="我是大白的数据帧"></p>
<p>websocket的数据帧从81开始，灰色部分都是辅助信息，之后才是发送的数据，图片里已经显示了发送的数据。</p>
<ul>
<li><p>FIN表示该帧是否是发送数据的最后一个片段，如果我们发送的数据过长就会分成多个数据帧发送。</p>
</li>
<li><p>RSV1-3可以忽略，它们是用于扩展的。</p>
</li>
<li><p>opcode表示此次数据帧的格式：0x00表示是延续帧，此次发送的数据后面还有帧；0x01表示文本，用utf-8解码；0x02表示二进制流；0x03-0x07没有意义；0x08表示关闭；0x09是个心跳请求（ping）；0x10时心跳相应（pong），这两个操作前端暂时无法发送；0xa0后面的操作码暂时没有意义。</p>
</li>
<li><p>Mask标示是否数据帧是否进行掩码操作，往往客户端发送的数据都是有的，而服务端并没有。</p>
</li>
<li><p>Payload length标示数据长度，如果数据长度小于等于125，读取的数据就是长度；如果是126，需要读取接下来的两个字节才是长度；如果是127，需要读取接下来的八个字节。</p>
</li>
<li><p>Mask Key就是掩码值，长度为2字节；如果Mask为0，没有这2个字节。</p>
</li>
<li><p>发送的数据，如果有掩码操作，需要反掩码，算法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result[i] = origin[i] ^ maskKey[i % <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>即原属数据的第i位和掩码的第i%4进行异或，我们以<code>我是大白</code>为例计算，传过来的编码是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8a 1c 62 22 f6 05 21 78 cf 5d 60 78</span><br></pre></td></tr></table></figure>
<p>对应的maskKey是<code>0x6fb8c5c5</code>，根据上面的算法，如下计算得到的数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> origin = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="string">"0x8a"</span>, <span class="string">"0x1c"</span>, <span class="string">"0x62"</span>, <span class="string">"0x22"</span>, <span class="string">"0xf6"</span>, <span class="string">"0x05"</span>, <span class="string">"0x21"</span>, <span class="string">"0x78"</span>, <span class="string">"0xcf"</span>, <span class="string">"0x5d"</span>, <span class="string">"0x60"</span>, <span class="string">"0x78"</span>]);</span><br><span class="line"><span class="keyword">const</span> maskKey = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0x6f</span>, <span class="number">0xb8</span>, <span class="number">0xc5</span>, <span class="number">0xc5</span>]);</span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(origin.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; origin.length; i++, j = i % <span class="number">4</span>) &#123;</span><br><span class="line">  result[i] = origin[i] ^ maskKey[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURI</span>(<span class="built_in">Array</span>.from(result).map(<span class="function"><span class="params">num</span>=&gt;</span> <span class="string">"%"</span>+<span class="built_in">Number</span>(num).toString(<span class="number">16</span>)).join(<span class="string">''</span>));	<span class="comment">// 输出"我是大白"</span></span><br></pre></td></tr></table></figure>
<p>websocket文字传输采用了utf-8编码，想要得到汉字需要解码。这里使用decodeURI方法，因为web要求url的查询字符串也是采用utf-8编码，decodeURI方法拿来用再合适不过。</p>
<h2 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h2><p>接下里我们来读取客户端的数据，我们先不管长度大于125以上的字符长，所以现在读取的数据帧偏移量是确定的。因为socket读取的数据是buffer对象，所以先说几个基本读取和转换的方法</p>
<ol>
<li>readUInt8、readUInt16BE等，字节以8个字符一单位，readUInt8就是读取一个字节，readUInt16BE读取两个字节，BE表示大端在前，可以看作数据帧过来的顺序。第二个参数是字节的偏移量，readUInt16BE(1,1)，表示读取第二个字节开始的2个字节。</li>
<li>toString和parseInt方法，readUInt8读取到的数字是十进制，有时候需要转换成十六进制或者二进制，toString方法参数可以传递表示进制数。parseInt方法可以把十六进制转成十进制。</li>
</ol>
<p>首先需要读取op操作符，暂时只解析0x01格式的数据帧。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OPCODES = &#123;</span><br><span class="line">  CONTINUE: <span class="number">0</span>,</span><br><span class="line">  TEXT: <span class="number">1</span>,</span><br><span class="line">  BINARY: <span class="number">2</span>,</span><br><span class="line">  CLOSE: <span class="number">8</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseMessage</span>(<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> op = buffer.readUInt8(<span class="number">0</span>) &amp; <span class="number">0x0f</span>;	<span class="comment">// 读取第一个字节</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`op: <span class="subst">$&#123;op&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> OPCODES.TEXT:</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> Msg(buffer).decode();</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"未知的操作码"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在Msg对象里操作buffer。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Msg</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(buffer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parse(buffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parse(buffer) &#123;</span><br><span class="line">    <span class="keyword">const</span> offset = <span class="keyword">this</span>.parseLengthAndMask(buffer);</span><br><span class="line">    <span class="keyword">this</span>.readMaskData(buffer, offset);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parseLengthAndMask(buffer) &#123;</span><br><span class="line">    <span class="keyword">const</span> masks = buffer.readUInt8(<span class="number">1</span>).toString(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> isMask = masks.slice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> length = <span class="built_in">parseInt</span>(masks.slice(<span class="number">1</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> offset = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">if</span> (isMask) &#123;</span><br><span class="line">      <span class="keyword">const</span> maskKey = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(mask_length); <span class="comment">// 初始化长度</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; mask_length; i++) &#123;</span><br><span class="line">        maskKey[i] = toSuffixHexAdecimal(buffer.readUInt8(i + offset)); <span class="comment">// 标志为16进制</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.maskKey = maskKey;</span><br><span class="line">      offset += mask_length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  readMaskData(buffer, offset) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; loadData, length &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> origin = <span class="keyword">this</span>.origin = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">this</span>.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      origin[i + loadData] = toSuffixHexAdecimal(buffer.readUInt8(i + offset));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> origin;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  maskOp() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; maskKey, origin &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(origin.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; origin.length; i++, j = i % <span class="number">4</span>) &#123;</span><br><span class="line">      result[i] = origin[i] ^ maskKey[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  decode() &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">this</span>.maskOp();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">decodeURI</span>(</span><br><span class="line">        <span class="built_in">Array</span>.from(result)</span><br><span class="line">          .map(<span class="function">(<span class="params">r</span>) =&gt;</span> <span class="string">"%"</span> + toHexAdecimal(r))</span><br><span class="line">          .join(<span class="string">""</span>)</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码相对简单，因为此时数据并没有分片的概念，只是单条数据帧。下面来看数据太长之后导致分片的结果：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; Client: FIN=1, opcode=0x1, msg=&quot;hello&quot;</span><br><span class="line">&gt; Server: (process complete message immediately) Hi.</span><br><span class="line">&gt; Client: FIN=0, opcode=0x1, msg=&quot;and a&quot;</span><br><span class="line">&gt; Server: (listening, new message containing text started)</span><br><span class="line">&gt; Client: FIN=0, opcode=0x0, msg=&quot;happy new&quot;</span><br><span class="line">&gt; Server: (listening, payload concatenated to previous message)</span><br><span class="line">&gt; Client: FIN=1, opcode=0x0, msg=&quot;year!&quot;</span><br><span class="line">&gt; Server: (process complete message) Happy new year to you too!</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>一共发了两条信息，第一条帧是完整的消息；第二条分片后，只有最后一次信息FIN才是1，且操作码是0。所以判断FIN是否为1来判断消息是否完整。</p>
<p>再来思考一个问题，分片后的每条数据可以单独解码转成汉字吗？事实是不可以，大部分的汉字utf-8会有3个字节，数据帧只会把这条写满后才会写下一条数据，所以会导致3字节的汉字可能第一字节在前一帧，后面两个字节就在后一帧。如果直接读取分片，会导致decodeURI方法抛出异常，所以需要把所有的数据都读取到再去解码。</p>
<p>除此之外，在node里buffer对象的最大长度是65535，所以在读取大数据时候收到的buffer次数可能会超过分片长度，如果没有超过分片长度的话，这是因为上一帧的剩余的buffer和下一帧的buffer在同一buffer传输过来，这又是一个大坑。所以需要有个变量loadData表示单个数据帧是否传输完成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msgs = [];	<span class="comment">// 收到数据会有多个msg实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseMessage</span>(<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (msgs.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = msgs[msgs.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> left = msg.left();	<span class="comment">// 如果上一帧buffer有剩余，需要截断此次的buffer</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      msg.parse(buffer.slice(<span class="number">0</span>, left));</span><br><span class="line">      <span class="keyword">if</span> (left &gt;= buffer.length) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buffer = buffer.slice(left);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> op = buffer.readUInt8(<span class="number">0</span>) &amp; <span class="number">0x0f</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`op: <span class="subst">$&#123;op&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">let</span> msg;</span><br><span class="line">  <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> OPCODES.TEXT:</span><br><span class="line">      msg = <span class="keyword">new</span> Msg(buffer);</span><br><span class="line">      <span class="keyword">if</span> (msg.finished) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`收到信息：<span class="subst">$&#123;decode([msg.maskOp()])&#125;</span>`</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msgs.push(msg);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OPCODES.CONTINUE:</span><br><span class="line">      msg = <span class="keyword">new</span> Msg(buffer);</span><br><span class="line">      msgs.push(msg);</span><br><span class="line">      <span class="keyword">if</span> (msg.finished) &#123;</span><br><span class="line">        <span class="keyword">const</span> datas = msgs.map(<span class="function">(<span class="params">m</span>) =&gt;</span> m.maskOp());</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`收到信息：<span class="subst">$&#123;decode(datas)&#125;</span>`</span>);</span><br><span class="line">        msgs = [];	<span class="comment">// 清空msgs</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"未知的操作码"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Msg</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(buffer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.loadData = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.buffers = [];</span><br><span class="line">    <span class="keyword">this</span>.parse(buffer);</span><br><span class="line">    <span class="keyword">this</span>.finished = <span class="keyword">this</span>.isFinish(buffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parse(buffer) &#123;</span><br><span class="line">    <span class="keyword">const</span> buffers = <span class="keyword">this</span>.buffers;</span><br><span class="line">    <span class="keyword">if</span> (buffers.length === <span class="number">0</span>) &#123;	<span class="comment">// 如果是第一个buffer，需要在此读取基本信息，否则直接读取数据</span></span><br><span class="line">      buffers.push(buffer);</span><br><span class="line">      <span class="keyword">const</span> offset = <span class="keyword">this</span>.parseLengthAndMask(buffer);</span><br><span class="line">      <span class="keyword">this</span>.origin = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">this</span>.length);</span><br><span class="line">      <span class="keyword">const</span> length = <span class="built_in">Math</span>.min(buffer.length - offset, <span class="keyword">this</span>.length);</span><br><span class="line">      <span class="keyword">this</span>.readMaskData(buffer, offset, length);</span><br><span class="line">      <span class="keyword">this</span>.loadData += length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.readMaskData(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line">      <span class="keyword">this</span>.loadData += buffer.length;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  left() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length - <span class="keyword">this</span>.loadData;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parseLengthAndMask(buffer) &#123;</span><br><span class="line">    <span class="keyword">const</span> masks = buffer.readUInt8(<span class="number">1</span>).toString(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> isMask = masks.slice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> length = <span class="built_in">parseInt</span>(masks.slice(<span class="number">1</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> offset = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (length === <span class="number">126</span>) &#123;	<span class="comment">// 不同长度的字节读取</span></span><br><span class="line">      length = <span class="built_in">parseInt</span>(buffer.readUInt16BE(<span class="number">2</span>).toString(<span class="number">16</span>), <span class="number">16</span>);</span><br><span class="line">      offset += <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (length === <span class="number">127</span>) &#123;</span><br><span class="line">      length = <span class="built_in">parseInt</span>(</span><br><span class="line">        buffer.readUInt32BE(<span class="number">2</span>).toString(<span class="number">16</span>) +</span><br><span class="line">          buffer.readUInt32BE(<span class="number">6</span>).toString(<span class="number">16</span>),</span><br><span class="line">        <span class="number">16</span></span><br><span class="line">      );</span><br><span class="line">      offset += <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">if</span> (isMask) &#123;</span><br><span class="line">      <span class="keyword">const</span> maskKey = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(mask_length); <span class="comment">// 初始化长度</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; mask_length; i++) &#123;</span><br><span class="line">        maskKey[i] = toSuffixHexAdecimal(buffer.readUInt8(i + offset)); <span class="comment">// 标志为16进制</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.maskKey = maskKey;</span><br><span class="line">      offset += mask_length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把decode方法独立出来，因为需要多个msg的实例才能拿到最终数据，所以不再属于对象的方法了。</p>
<p>在decode里又遇到大坑，再度抛出<code>URI malformed</code>异常。定位后发现在js里字符串的长度理论上是可以很长的，但是实际上执行引擎并不一定会有这么大的长度去容纳。而反掩码后得到的字符串过长，导致字符串截断，所以无法正常反掩码了。针对这种情况，对字符串也要分片处理。但是切割位无法很好的处理，我直接把切割的长度定在3的倍数270，因为大部分汉字编码长度都是3。实际上还是要针对每个汉字再解码会好点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> seg_length = <span class="number">270</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decode</span>(<span class="params">datas</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> total = datas.reduce(<span class="function">(<span class="params">total, cur</span>) =&gt;</span> total + cur.length, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> segs = <span class="built_in">Math</span>.ceil(total / seg_length);	<span class="comment">// 分片长度</span></span><br><span class="line">  <span class="keyword">let</span> seg = <span class="number">0</span>,</span><br><span class="line">    segDataIdx = <span class="number">0</span>, <span class="comment">// 指向当前data的索引</span></span><br><span class="line">    dataIdx = <span class="number">0</span>,</span><br><span class="line">    data = datas[seg];</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">while</span> (seg &lt; segs) &#123;</span><br><span class="line">    <span class="keyword">const</span> length = seg === segs - <span class="number">1</span> ? total - seg_length * seg : seg_length;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(length);</span><br><span class="line">    result.push(arr);</span><br><span class="line">    seg++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> arrIdx = <span class="number">0</span>; arrIdx &lt; length; arrIdx++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (segDataIdx === data.length) &#123;	<span class="comment">// 当前data读取完毕</span></span><br><span class="line">        segDataIdx = <span class="number">0</span>;</span><br><span class="line">        data = datas[++dataIdx];</span><br><span class="line">      &#125;</span><br><span class="line">      arr[arrIdx] = data[segDataIdx++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 假设能发送过来的长度那肯定也能读取完毕不会被截断</span></span><br><span class="line">  <span class="keyword">return</span> result.reduce(</span><br><span class="line">    (str, data) =&gt;</span><br><span class="line">      (str += <span class="built_in">decodeURI</span>(</span><br><span class="line">        <span class="built_in">Array</span>.from(data)</span><br><span class="line">          .map(<span class="function">(<span class="params">r</span>) =&gt;</span> <span class="string">"%"</span> + toHexAdecimal(r))</span><br><span class="line">          .join(<span class="string">""</span>)</span><br><span class="line">      )),</span><br><span class="line">    <span class="string">""</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样数据分片的读取我们也完成了。</p>
<h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><p>发送数据就是自己去组装数据帧，不需要掩码，但也要遵从数据长度的规则，这里我们就不再赘述，直接按长度小于126的去组装即可，每一条数据的的FIN都是1，操作码也是0x01。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> b1 = toSuffixHexAdecimal(<span class="number">0x80</span> | OPCODES.TEXT);</span><br><span class="line">  <span class="keyword">const</span> payLoad = Buffer.from(data, <span class="string">"utf8"</span>);</span><br><span class="line">  <span class="keyword">const</span> length = payLoad.length;</span><br><span class="line">  <span class="keyword">const</span> b2 = toSuffixHexAdecimal(length);</span><br><span class="line">  <span class="keyword">const</span> buffer = Buffer.alloc(length + <span class="number">2</span>);</span><br><span class="line">  buffer.writeUInt8(b1, <span class="number">0</span>);</span><br><span class="line">  buffer.writeUInt8(b2, <span class="number">1</span>);</span><br><span class="line">  payLoad.copy(buffer, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p>关闭连接和发送数据的区别就是操作码不一样，而且也不需要长度的说明，就不再贴代码了。当服务端关闭请求时，浏览器也会在此发送个关闭的数据帧给服务端表示收到，之后两者再传输的数据帧就会被抛弃，这点需要注意。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实写websokcet服务器并不是多难的事，只要遵从数据帧的格式解析或者组装就可以， 只是看起来高大上点。不过一开始我也会出现疑惑，比如客户端发送关闭帧时候服务器应该做什么回应才能正式关闭，事实是客户端遵从了协议，发送帧之后就会关闭连接，而并不需要我们做什么。还有就是数据长度太长的坑，无法正常的解析等等，更多的是对这种边界情况的处理。</p>
<p>但是通过此次代码，可以使用wiresharek抓包和协议的理解等，具体代码参见这里<a href="https://github.com/ccanister/websocket" target="_blank" rel="noopener">websocket</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="noopener">websocket mdn</a></li>
<li><a href="http://semlinker.com/you-dont-know-websocket" target="_blank" rel="noopener">你不知道的 WebSocket</a></li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/16/动手写webpack：loader机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/16/动手写webpack：loader机制/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-16T12:02:47+08:00">
                2020-09-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="动手写webpack：loader机制"><a href="#动手写webpack：loader机制" class="headerlink" title="动手写webpack：loader机制"></a>动手写webpack：loader机制</h1><p>webpack默认只能识别js文件，可以解析其导入和导出等。但是在js文件中，我们可能会想直接导入css文件或者图片，就需要自己去处理。loader机制就是声明那些类型的文件可以交给其来处理，甚至你可以直接说js文件交给了webpack内置的loader处理了。将文件内容传入loader再处理成需要的字符串交回给webpack处理。输入和输出都是字符串。不仅如此，同一种类型的文件可以交给多个loader处理，比如css文件可以串行的先交给css-loader处理，再交给style-loader处理，最后返回webpack。</p>
<!-- readMore -->
<p>和loader相比较的，我们往往会讨论plugin。把webpack当作垃圾工厂的话，loader就是垃圾分类，不同类型的垃圾交由不同的loader处理，整理好后交给webpack。plugin可以在处理的过程中自定义事件，比如说处理前先把垃圾都堆在垃圾产地中，或者处理完中后先把屯放的仓库清理干净后再屯放垃圾（cleanWebpackPlugin）。所以在编写plugin时候更多去监听编译过程事件。</p>
<h2 id="loaders的拆解"><a href="#loaders的拆解" class="headerlink" title="loaders的拆解"></a>loaders的拆解</h2><p>因为我们没有配置文件，所以我们配置loader时候直接声明再js的导入中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; obj &#125; <span class="keyword">from</span> <span class="string">"wait-loader!simple-loader!./a"</span>;</span><br></pre></td></tr></table></figure>
<p>通过！标示了前面部分是loader名称，如果有多个loader就用！一直隔开。所以在识别是否是loader时候我们匹配！是否存在即可。整体的思路就是在读取文件内容后，解析依赖时识别和切割loader，再去拿到其绝对路径，从左往右依次执行loader方法取回的字符串就是该依赖内容，最后去识别这个依赖文件的依赖。和普通模块的区别就是多了解析loader这步，所以直接从之前的Module衍生出子类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	init() &#123;</span><br><span class="line">		<span class="keyword">this</span>.code = <span class="keyword">await</span> <span class="keyword">this</span>.readCode(absoulutePath);</span><br><span class="line">		<span class="keyword">const</span> &#123; deps &#125; = parse(<span class="keyword">this</span>);</span><br><span class="line">		....</span><br><span class="line">	&#125;</span><br><span class="line">	readCode() &#123;</span><br><span class="line">    <span class="keyword">return</span> readFile(<span class="keyword">this</span>.absoulutePath);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoaderModule</span> </span>&#123;</span><br><span class="line">  readCode() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.executeLoader();</span><br><span class="line">  &#125;</span><br><span class="line">  executeLoader() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; loaderPaths, contentAbsolutePath, <span class="attr">absoulutePath</span>: request &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> content = readFile(contentAbsolutePath);</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 从右往左执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = loaderPaths.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      content = <span class="built_in">require</span>(loaderPaths[i])(content);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种情况只支持了同步loader的执行，在文档中我们看到当调用了<code>this.async()</code>后表示开启了异步loader，可以用一个变量表示是否是异步的，不是的话我们继续执行下一个loader，否则就返回可执行下个loader的回调。除此之外我们d看到this，说明了loader函数的执行有上下文对象。下面我们以css-loader为例，他是异步的loader，同时也调用了上下文的部分字段：</p>
<ul>
<li>remainingRequest：剩下的loader</li>
<li>currentRequest：比remainingRequest多了当前的loader</li>
</ul>
<p>调用async函数后会返回回调函数后，只有调用了回调函数后才会执行下一个loader。所以最后返回的字符串内容时机是无法确定的，用promise可以解决这个问题，调用resolve之后才算返回了内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">executeLoader() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; loaderPaths, contentAbsolutePath, <span class="attr">absoulutePath</span>: request &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> content = readFile(contentAbsolutePath);</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> loaderFuns = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = loaderPaths.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        loaderFuns.push(<span class="built_in">require</span>(loaderPaths[i]));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> remainingRequest = <span class="keyword">this</span>.popRequest(request);</span><br><span class="line">      <span class="keyword">let</span> currentRequest = request;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">nextLoader</span>(<span class="params">content, needPop</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needPop) &#123;</span><br><span class="line">          remainingRequest = self.popRequest(remainingRequest);</span><br><span class="line">          currentRequest = self.popRequest(currentRequest);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!loaderFuns.length) &#123;</span><br><span class="line">          resolve(content);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> isAsync = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">const</span> context = &#123;</span><br><span class="line">          callback: <span class="function">(<span class="params">error, content</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">              <span class="keyword">throw</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nextLoader(content, <span class="literal">true</span>);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="keyword">async</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            isAsync = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.callback;</span><br><span class="line">          &#125;,</span><br><span class="line">          remainingRequest,</span><br><span class="line">          currentRequest,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> resp = loaderFuns.pop().call(context, content);</span><br><span class="line">        <span class="keyword">if</span> (!isAsync) &#123;</span><br><span class="line">          nextLoader(resp, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      nextLoader(content, <span class="literal">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在文件中调用css文件成功打印了其文件内容，如果我们去掉loader选项，就会报无法处理css文件的错误。另外，在生成的bundle文件中，发现多了runtime等模块。在css-loader的源码中，可以看到它对传入的字符串拼接了import文件的内容，我们在css-loader处理后去分析了它的依赖，所以才会多打包了这些模块。</p>
<p>源代码可以看<a href="https://github.com/ccanister/fake-webpack#fake-webpack" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="pitch-loader"><a href="#pitch-loader" class="headerlink" title="pitch loader"></a>pitch loader</h2><p>本来是想把style-loader和css-loader放在一起处理css文件的，但是发现事实上并没有执行css-loader函数。去到style-loader源码查看时，默认导出函数是空的，但它挂载了pitch方法。根据webpack文档，应该先从左往右执行loader的pitch方法，再从右往左执行loader函数。如果pitch方法返回了字符串，那么终止后面的loader调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a(pitch) -&gt; b(pitch) -&gt; c(pitch) -&gt; c -&gt; b -&gt; a</span><br><span class="line">现在b这个loader执行pitch时候返回了字符串</span><br><span class="line">a(pitch) -&gt; b(pitch) -&gt; a</span><br></pre></td></tr></table></figure>
<p>这样做的好处是什么呢？我们回过头来看style-loader，它需要拿到css的文件内容，但是css-loader最终返回的格式是<code>module.exports = xxx</code>，对于style-loader而言没有任何用处。所以在打包时候它内部需要重新请求css文件，本质上也是调用了css-loader去处理。这样就会导致css-loader执行了两遍。</p>
<p>webpack对loader提供了pitch方法后，style-loader执行后返回字符串就可以提前返回，不用再往后执行了，提高了效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/05/从zepto说起/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/05/从zepto说起/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-05T17:12:47+08:00">
                2020-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从zepto说起"><a href="#从zepto说起" class="headerlink" title="从zepto说起"></a>从zepto说起</h1><p>学完underscore源码，操作对象和常用的函数等应该都是手到擒来了。接下来来看DOM操作，毕竟是前端，更多还是为浏览器服务的。jquery源码点进去一看几千行吧，吓得退了出来，后来发现还有zepto也是针对浏览器的js库，而且更为轻量，没有较多的兼容低版本代码，所以选择看zepto源码。</p>
<p>zepto的测试用例比较恶心，框架好像是自己搭的，测试用例出错的时候也不会说明是哪个出错，只有统计结果xxx运行成功，xxx运行失败，相对而言还是qunit框架的测试反馈直观。</p>
<!-- readMore -->
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>zepto核心方法就是<code>$</code>方法，他可以传入css选择器查询DOM节点，也可以传入字符串创建新的DOM节点，最终返回的是类数组，即带有索引的zepto对象。还可以传入函数，可以在页面加载完毕后执行。</p>
<p>当传入的第一个参数是字符串时候，先删除首尾的空白字符。如果首字符是<code>&lt;</code>，说明是解析字符串创建DOM节点，否则就是查询。</p>
<h3 id="查询DOM节点"><a href="#查询DOM节点" class="headerlink" title="查询DOM节点"></a>查询DOM节点</h3><p>查询接口分成两种：<code>getElementsBy</code>系列和<code>querySelectorAll</code>，浏览器基本能够兼容这两种方法。但是zepto会根据类型判断，依次是id、class和tag，都有对应的<code>getElementsBy</code>方法查询，最后才降低到querySelectorAll函数，采用这种方法的目的肯定是尽可能地提高选择器性能。除了这点，两者其他区别：</p>
<ol>
<li><p>传入参数不同：getElementsBy只能传入单一的id、className和tagName，而<code>querySelectorAll</code>可以接受css选择器。所以zepto中有个正则<code>/^[\w-]*$/</code>判断是否是单一的选择符，防止有空格符隔开，而用了错误的查询。</p>
</li>
<li><p>返回值：这点比较重要，getElementsBy返回的是动态的HTMLCollection，而querySelectorAll返回的是静态的NodeList。可以看这个经典的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// querySelectorAll</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelectorAll(<span class="string">'ul'</span>)[<span class="number">0</span>],</span><br><span class="line">    lis = ul.querySelectorAll(<span class="string">"li"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length ; i++)&#123;</span><br><span class="line">    ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"li"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getElementsBy</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>], </span><br><span class="line">    lis = ul.getElementsByTagName(<span class="string">"li"</span>); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length ; i++)&#123;</span><br><span class="line">    ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"li"</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为getElementsBy返回的是动态节点集合，当该查询有变化时候，返回的集合也会有之变化，所以会导致无限循环。</p>
<p>而querySelectorAll返回的集合就是个快照，不会有什么影响。</p>
<p>当然在zepto中，对两个选择器返回的结果重新塞入新对象中，所以也是个静态集合。</p>
<p>除了这点，HTMLCollection只包含元素节点，即nodeType为1的节点，节点的children属性可以返回这类集合，而NodeList是包含所有类型的节点，可以通过节点的childNodes属性返回。所以有时候前者返回的集合是空的，但后者长度不为空，一般可能返回了文本节点。</p>
</li>
</ol>
<h3 id="解析字符串"><a href="#解析字符串" class="headerlink" title="解析字符串"></a>解析字符串</h3><p>因为浏览器本身就是支持innerHTML属性的，所以第一想法就是利用该属性。但是这里有个坑就是利用innerHTML属性，就要有个父节点，那么父节点的标签名往往会用<code>div</code>，但div父标签并不能创建所有的子节点，比如表格的标签tr、tbody等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">div.innerHTML = <span class="string">"&lt;td&gt;123&lt;/td&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div.childNodes) <span class="comment">// [text]</span></span><br></pre></td></tr></table></figure>
<p>会忽略掉td节点，只有123文本节点。所以父标签需要有个映射表。</p>
<p>另外一点，为了提高性能，当传入单标签的字符串即<code>&lt;div&gt;&lt;/div&gt;</code>，里面没有包裹任何元素时候，会直接使用createElement方法，而不是采用上述方法。</p>
<h2 id="元素属性"><a href="#元素属性" class="headerlink" title="元素属性"></a>元素属性</h2><p>这里的属性指的不是properity，而是我们平常打交道的css、class、prop和attribute等。通常操作就是增删改查，需要关注的一个点是键值有中划线和驼峰两种格式，两者在不同的操作下有时候可取有时候不可取。</p>
<h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><p>想要取得节点的样式，不能直接通过style属性。因为style属性只存储了内联样式，但是节点最终的样式是综合规则计算出来的，单单读取内联样式是不够的。所以正确的做法是通过getComputedStyle(el, [pseudoElt])方法取值，该方法返回了动态的CSSStyleDeclaration对象，第二个参数传入元素的伪类，如<code>:before</code>。当元素的样式更改时，它会自动更新本身。注意，style属性返回的也是CSSStyleDeclaration对象。取值的时候，CSSStyleDeclaration对象同时存储了中划线和驼峰两种键值，比如<code>margin-top</code>就会同时存储<code>margin-top</code>和<code>marginTop</code>两个键值，所以不用在乎键值格式。</p>
<p>删除和设置元素的时候有两种方法：</p>
<ol>
<li>调用style属性的CSSStyleDeclaration对象，它暴露两个方法removeProperty和setProperty。</li>
<li>调用style属性的cssText，它返回了内联样式上所有css字符串，相邻样式用;隔开。设置值的时候可以直接在后面附加属性，如<code>el.style.cssText += &quot;;width:10px&quot;</code>，如果有重名样式，直接覆盖，所以删除样式，可以这样<code>el.style.cssText += &quot;width:null&quot;</code>。</li>
</ol>
<p>以上两种方法的操作都是基于元素的内联样式，而且键值都要改成中划线格式。在zepto中删除操作采用了第一种方法，设置操作采用了第二种方法。第二种方式可以批处理操作，减少浏览器的重排和回流。</p>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>操作class也是有两种方案，而且不区分名字格式，即<code>className</code>和<code>classList</code>，后者也是类数组，有add、remove等方法，可以传入多个参数，可谓是非常的方便。但是IE10以下不兼容，所以又退化回className字符串的操作。</p>
<p>对于字符串的增删改查，往往使用正则匹配是最为方便的。className是是由空格分隔的多个class属性值。所以匹配的字符串应该为<code>/(^|\s)[classname](\s|$)/</code> 形式，有可能会出现在开头或者结尾处。删除时候，直接将其替换成空字符串即可。还有一个点，对于svg类型的标签需要特别的注意，其className得到的是一个对象,类似这样<code>SVGAnimatedString {baseVal: &quot;box hallo&quot;, animVal: &quot;box hallo&quot;}</code>，所以取className的时候，还得看是否有baseVal属性。</p>
<h3 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a>attribute</h3><p>对于元素属性的操作比较简单，分别调用<code>setAttribute</code>、<code>getAttribute</code>和<code>removeAttribute</code>方法。其中属性值都是小写的，即使传入大写字符，也会被小写化。需要注意的是对于不存在的属性，getAttribute方法会返回null，但不代表着删除值的时候，调用setAttribute就可以传入null参数。因为布尔属性无论设置了任何值都会呗认为是true，比如<code>el.setAttribute(disable, null)</code>，此时按钮也会设置禁用状态。所以删除值时候还是用removeAttribute方法替代。</p>
<h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><p>在Angular中有专门一节对比了attribute和property，它认为attribute是HTML属性，而property是DOM节点属性。两者即可以1:1映射，比如<code>id</code>属性，有可能存在attribute没有对应的property，比如<code>aria-*</code>属性，也有可能存在property没有对应的attribute，比如<code>textContent</code>。但是即使有相同的名字，两者意义也是不一样的。所以在Angular中，attribute的作用是初始化元素和指令的状态。而在标准的差异如下：</p>
<ol>
<li><p>取值方法不同：property通过el[name]获取，attribute通过el.getAttribute(name)获取。</p>
</li>
<li><p>同步：property会从attribute中同步属性，意味着改变了attribute也会改变property属性，反之则不会。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el.setAttribute(<span class="string">"disabled"</span>, <span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(el.disbaled)	<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>键值格式：attribute会忽略大小写，property不会忽略，但是有些保留字比如class，不能通过el.class获取，而是el.className</p>
</li>
</ol>
<h3 id="data"><a href="#data" class="headerlink" title="data-*"></a>data-*</h3><p>Data-*是h5具有扩展型的设计，允许在HTML元素中存储额外的信息，js和css都能访问到该属性。在元素上设置值的时候，会忽略大小写，大写字符也会被转成小写的字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  article[data-columns=<span class="string">"3"</span>] &#123;</span><br><span class="line">  	background: orange;</span><br><span class="line">  &#125;</span><br><span class="line">  article::before &#123;</span><br><span class="line">    content: attr(data-columns);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;article id="article" data-columns=3&gt;</span></span><br><span class="line"><span class="regexp">	dabai</span></span><br><span class="line"><span class="regexp">&lt;/</span>article&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> article = <span class="built_in">document</span>.querySelector(<span class="string">"#article"</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(article.dataset.columns);	<span class="comment">// 3</span></span><br><span class="line">	<span class="built_in">console</span>.log(article.getAttribute(<span class="string">"data-columns"</span>));	<span class="comment">// 3</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到对于js而言，有两种操作方法，一个是通过dataset属性，不需要添加data-前缀，但是要把中划线格式转换成驼峰，另外一个是通过attributes属性，需要加上data-的前缀。对于css而言，同样可以直接调用attr方法当作样式值，或者当作属性选择器来改变样式，但都要加上data-的前缀。</p>
<p>这样js通过设置data-*共享变量就能改变元素样式，从而减少逻辑。</p>
<h2 id="DOM的增删改查"><a href="#DOM的增删改查" class="headerlink" title="DOM的增删改查"></a>DOM的增删改查</h2><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>zepto插入元素的方法有很多种，而且写法都很巧妙。我们先来看append、prepend、after和before这四种方法，其他都是衍生方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;div id=<span class="string">"beforeafter"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ js</span></span><br><span class="line"><span class="regexp">$("#beforeafter").append("append");</span></span><br><span class="line"><span class="regexp">$("#beforeafter").prepend("prepend");</span></span><br><span class="line"><span class="regexp">$("#beforeafter").before("before");</span></span><br><span class="line"><span class="regexp">$("#beforeafter").after("after");</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 最后输出 before&lt;div id="beforeafter"&gt;prependappend&lt;/</span>div&gt;after</span><br></pre></td></tr></table></figure>
<p>可以看到append插入到匹配元素的最后一个子节点的后面，prepend是插入到匹配元素的第一个子节点前面。after插入到匹配元素的后面，before插入到匹配元素前面。上下区别是一个在内部，一个在外部。</p>
<p>上面四种方法有两个相同点：</p>
<ol>
<li><p>传入参数是一样的：可以是html字符串，也可以是dom节点、Zepto内置的对象或者以上组成的数组。这个比较好解决，html字符串就调用核心方法<code>fragment</code>解析字符串；如果是数组就去遍历即可。</p>
</li>
<li><p>都是插入到某个元素的节点，最后都可以调用parent.appenchild(node, child)方法。具体可以这么看</p>
<p>|         | parent           | 被插入的元素           |<br>| ——- | —————- | ———————- |<br>| append  | 当前元素         | null                   |<br>| prepend | 当前元素         | 当前元素的firstChild   |<br>| after   | 当前元素的父节点 | 当前元素下一个兄弟节点 |<br>| before  | 当前元素的父节点 | 当前元素               |</p>
</li>
</ol>
<p>解决了这两个问题，就基本能看懂插入元素的函数了。还有两个细节值得关注：</p>
<ul>
<li>如果插入元素是数组且长度大于1，那么插入的元素需要克隆，否则如果元素处在文档中，就会不断从上个元素中删除再插入到下个元素，最后会被插入到zepto对象最后一个元素节点。</li>
<li>如果插入的元素在节点中，而且是内联的script标签节点，需要调用eval方法执行脚本。注意这里上下文的取值<code>var target = el.ownerDocument? el.ownerDocument.defaultView window;</code>。如果是iframe上下文是el.ownerDocument.defaultView，否则正常的窗口上下文是window。</li>
</ul>
<p>after、prepend、before和append衍生的方法分别是insertAfter、prependTo、insertBefore和appendTo，可以看作参数和调用上下文刚好相反即可。</p>
<h3 id="包裹元素"><a href="#包裹元素" class="headerlink" title="包裹元素"></a>包裹元素</h3><p>包裹元素的方法有三种，分别是wrap、wrapAll和wrapInner，文字描述功能有些晦涩，我们直接看demo：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = $(<span class="string">"&lt;b&gt;A&lt;/b&gt;&lt;b&gt;B&lt;/b&gt;"</span>);</span><br><span class="line">el.wrap(<span class="string">"&lt;a class=link&gt;&lt;/a&gt;"</span>);	<span class="comment">// &lt;a class=link&gt;&lt;b&gt;A&lt;/b&gt;&lt;/a&gt;&lt;a class=link&gt;&lt;b&gt;B&lt;/b&gt;&lt;/a&gt;</span></span><br><span class="line">el.wrapAll(<span class="string">"&lt;a class=link&gt;&lt;/a&gt;"</span>);	<span class="comment">// &lt;a class=link&gt;&lt;b&gt;A&lt;/b&gt;&lt;b&gt;B&lt;/b&gt;&lt;/a&gt;</span></span><br><span class="line">el.wrapInner(<span class="string">"&lt;a class=link&gt;&lt;/a&gt;"</span>);	<span class="comment">// &lt;b&gt;&lt;a class=link&gt;A&lt;/a&gt;&lt;/b&gt;&lt;b&gt;&lt;a class=link&gt;B&lt;/a&gt;&lt;/b&gt;&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>
<p>wrap就是包裹el的每个子节点，wrapAll直接包裹el，wrapInner是包裹el的每个子节点的内容。可以发现wrapAll是底层方法，其他两个方法都可以调用它来实现逻辑，所以先来看wrapAll方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wrapAll: <span class="function"><span class="keyword">function</span> (<span class="params">structure</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">    $(<span class="keyword">this</span>[<span class="number">0</span>]).before((structure = $(structure)));</span><br><span class="line">    <span class="keyword">var</span> children;</span><br><span class="line">    <span class="comment">// drill down to the inmost element</span></span><br><span class="line">    <span class="keyword">while</span> ((children = structure.children()).length)</span><br><span class="line">      structure = children.first();</span><br><span class="line">    $(structure).append(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>首先要把外包裹元素插入到文档中，因为structure参数可以是html字符串，如果不先插入文档中，就直接被外层包裹的元素带走无法在浏览器中显示。然后迭代查询外包裹元素的第一个子节点，注意children方法返回的element类型的节点，不会返回文本节点的。最后把被包裹元素插入到第一个子节点末尾。</p>
<p>另外我们来看这两个例子</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">$('.box').wrapAll('.wrap')</span><br><span class="line">// 结果</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时的ul结构仍然存在。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"here"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"here"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">// 结果</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"here"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"here"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时ul结构被移动到第一个div标签中。上述两个例子的结果不同是因为，第一个外包裹元素的第一个子节点就是两个div，而第二个的第一个字节点是第一个class为here的div节点。在append方法中我们提到过被插入的元素长度超过1时候，插入元素会克隆。</p>
<p>看完了wrapAll方法，再来看wrap就很简单，只要遍历每个子元素节点再调用wrapAll方法即可。而wrapInner方法，遍历子元素节点时候，子元素的子节点调用wrapAll方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wrapInner: <span class="function"><span class="keyword">function</span> (<span class="params">structure</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = $(<span class="keyword">this</span>),</span><br><span class="line">    contents = self.childrenNodes,</span><br><span class="line">    contents.length ? contents.wrapAll(structure) : self.append(structure);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="查询DOM内容"><a href="#查询DOM内容" class="headerlink" title="查询DOM内容"></a>查询DOM内容</h3><ol>
<li><p>children：只查询元素节点，即children属性，或者childNodes属性再过滤nodeType为1的节点。</p>
</li>
<li><p>text：text获取有两种方法：innerText和textContent。两者都可以拿到包括子节点的文本内容和设置值。</p>
<ul>
<li>空格等设置：textContent会直接获取所有空格或者换行符，innerText会根据元素是否是块级而合并空格。</li>
<li>子元素隐藏后文本内容显示：textContent仍然显示全部，innerText如果隐藏不再显示。</li>
<li>性能：可以看得出innerText会计算元素属性，性能较差。</li>
</ul>
</li>
<li><p>val：根据value属性取值，注意的是select表单控件的value是多项的，可以根据multiple属性判断。selectedOptions属性可以直接获取选中值，但是ie不支持该属性，所以还是要遍历option元素。</p>
</li>
<li><p>hmtl：根据innerHTML属性设置或者获取。</p>
</li>
<li><p>height和width：我们以width为例先，DOM的宽度有三类：</p>
<ul>
<li>clientWidth:：内容的width+padding</li>
<li>offsetWidth:：内容width+padding+border</li>
<li>scrollWidth：包括由于overflow溢出而在屏幕上不可见的内容宽度。如果没有出现水平滚动条，可以认为等于clientWidth。</li>
</ul>
<p>当然行内元素的宽度都是0。zepto返回的元素宽度用的是scrollWidth。</p>
<p>除此之外，也可以通过el.getBoundingClientRect方法获取，它计算出的width等于右border-左border，看起来和offsetWidth一样。但是这个width是实际渲染出来的宽度，比如说附加了<code>transform:scale(1.5)</code>样式，对于offsetWidth是不会变的，而getBoundingClientRect方法返回的宽度会乘以1.5倍，是实际呈现为准。同理getBoundingClientRect方法返回的top也是从窗口上方开始到元素的border（不包含）为止的高度。如果该元素是可滚动，那么top也是可变的。</p>
<p><img src="/2020/09/05/从zepto说起/zhaorenjie/Documents/blog/source/_posts/从zepto说起/图片尺寸.jpeg" alt="图片尺寸" style="zoom:67%;"></p>
<center>偷了别人的图</center>

<p>上述宽度都是针对元素节点，如果是window，我们一般用innerWidth获取宽度，因为outerHeight往往包括了浏览器的任务栏和窗口高度等。如果是document，我们返回内容宽度即offsetWidth。</p>
</li>
</ol>
<h2 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h2><h3 id="offsetParent"><a href="#offsetParent" class="headerlink" title="offsetParent"></a>offsetParent</h3><p>返回第一个定位过的祖先元素，即祖先元素的的position不是static。DOM原声就有offsetParent属性，但是如果当元素隐藏起来的时候，offsetParent返回null，zepto返回的是body对象。</p>
<h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><p>offset方法类似getBoundingClientRect方法，获取元素的渲染后的width、height、top和left。如果元素既不是html（根据document.documentElement判断）也不在文档中，则返回<code>{top: 0, left: 0}</code>。之前有说过getBoundingClientRect返回的top指的是从窗口上方开始到元素的border为止（不包含）的高度，如果当前文档已滚动，那么取得的top是不准的，所以还要加上window.pageYOffset。</p>
<p>设置值的时候，不能直接赋予元素偏移值。</p>
<p><img src="/2020/09/05/从zepto说起/zhaorenjie/Documents/blog/source/_posts/从zepto说起/offsetParent.jpg" alt="offsetParent" style="zoom:50%;"></p>
<p>如上图所示，元素的偏移量会根据第一个定位过的祖先元素而变化，假设祖先元素的top为100，元素需要设置的top为100，如果直接设置，会导致最后的top为200。所以最终的偏移量应该减去祖先元素的偏移量才是正确的。如果元素的定位属性是<code>static</code>，则会将其改为<code>relative</code>定位，再相对于其正常文档流来计算。</p>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>position方法返回相对于第一个定位过的祖先元素的位置，即<code>{top: xx,left: xx}</code>。如果元素是body或者html节点直接返回<code>{top: 0, left: 0}</code>。</p>
<p>整体思路还是用当前元素相对于文档的位置减去第一个定位祖先元素相对于文档的位置，需要注意的是top从祖先元素的padding（包含）开始直到当前元素的border（包含）。</p>
<h3 id="scrollLeft-amp-amp-scrollTop"><a href="#scrollLeft-amp-amp-scrollTop" class="headerlink" title="scrollLeft &amp;&amp; scrollTop"></a>scrollLeft &amp;&amp; scrollTop</h3><p>取值的话可以直接通过scrollLeft属性，设置值的时候使用scrollTo或者scrollIntoViewIfNeeded方法，传入的第二个参数是<code>{behavior: smooth}</code>，表示平滑滚动，此时会多次触发scroll事件。也可以直接设置scrollLeft值，进行跳转。</p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。网上有个例子很形象，我直接摘抄过来：</p>
<p>有几个同事预计在周一会收取到快递，为签收快递，有两种办法：一是三个人在门口等待快递；二是让快递放在前台由前台代替接受。在现实当中，我们一般会采用第二种方法，让前台帮忙签收。在这里有两层含义：</p>
<ol>
<li>当前同事快递可以由前台代收，即文档中的DOM节点事件能够触发。</li>
<li>新来的同事快递也可以由前台代收，即文档中新增的DOM节点事件也能够触发。</li>
</ol>
<p>可以看到好处是有很多的，最直观的就是提高了效率，不用每个同事去处理快递。类比DOM也是一样的，不用DOM节点自己去添加监听事件，只需要有一个守门人就能够处理所有的事件，能提高浏览器的性能。</p>
<p>而这个守门人是谁呢，就是需要监听事件的父节点，极端来说可以看作根节点。因为事件默认是冒泡的，当触发事件时候，会从触发的节点开始逐级往上最终到达根节点，event.target表示触发事件的节点，我们再根据这个属性判断进行相应的操作。当然，也没有人这么傻会把根节点当作守门人，中途很有可能再被某个处理停止了。往往在父节点附加即可。</p>
<p>一般讨论时候都会用ul做例子，我们也来看：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"add"</span>&gt;</span>添加li<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span>dabai<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"2"</span>&gt;</span>xiaobai<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"3"</span>&gt;</span>middlebai<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>bai<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们想给li标签添加点击后显示起id事件，再给按钮添加增加li节点的事件。一般会这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = <span class="built_in">document</span>.getElementById(<span class="string">"wrapper"</span>);</span><br><span class="line"><span class="keyword">const</span> children = wrapper.getElementsByTagName(<span class="string">"li"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">  children[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  	alert(event.target.id);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"add"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, () =&gt; &#123;</span><br><span class="line">  wrapper.append(<span class="string">`&lt;li id=<span class="subst">$&#123;children.length&#125;</span>&gt;xixixi&lt;/li&gt;`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里的两个问题也是很明显：一个是需要遍历所有的li标签，假设有一百个我们就需要遍历一百次，很消耗性能；再一个就是点击按钮后添加的li节点并没有附加事件监听。</p>
<p>我们利用ul父节点做事件委托，所有的事件处理都在ul监听的事件中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wrapper.addEventListener(<span class="string">"click"</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> target = event.target;</span><br><span class="line">  <span class="keyword">if</span> (target.tagName.toLowerCase() === <span class="string">"li"</span>) &#123;</span><br><span class="line">  	alert(target.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>对evnet.target的标签名是否是li，是的话再去操作，也可以判断是否是div，去做其他操作。点击按钮增加后，也是可以弹出提示的。</p>
<p>这就是简单的事件委托，只需要在父节点监听事件即可。缺陷就有两点：</p>
<ol>
<li>中途的事件可能会停止冒泡，拦截了事件。</li>
<li>有些事件并不支持冒泡，比如focus和blur，下面我们来看zepto是怎么处理的。</li>
</ol>
<p>focus和blur事件虽然不支持冒泡，但他们有个兄弟事件是focusin和focusout，他们的执行顺序是：focus &gt; focus in &gt; blur &gt; focus out。所以有了替代事件。</p>
<p>mouseenter和mouseover也不支持冒泡事件，但是也可以用mouseover和mouseout来模拟，他俩是支持冒泡的。mouseevent中有个属性relatedTarget，表示相关目标节点。mouseover指向从哪里移动到的目标节点，mouseout指向的是目标节点移动到哪里。mouseover在目标节点上移动时候，relatedTarget指向的都是目标节点。所以判断relatedTarget为空或者不为目标节点和其子节点时，可以当作mouseenter和mouseover事件。</p>
<p>zepto实现了从创建事件 -&gt; 绑定事件 -&gt; 触发事件 -&gt; 移除事件的所有流程。</p>
<p>但是我看的版本中创建事件使用了createEvent方法，这在标准中已经过时，推荐用Event的构造器实例化事件，可以传入bubbles等参数表明是否冒泡。</p>
<p>绑定事件中如果传入了选择器，表明使用事件代理，这也说明在传入addEventListener的监听函数中，是会在我们传入的函数上封装一层。为了解绑事件，需要保存初始的函数，除此之外还需要保存事件名称和命名空间、选择器。所以事件绑定时候封装的对象会有以下参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">handler = &#123;</span><br><span class="line">  e: 事件名</span><br><span class="line">  ns：命名空间</span><br><span class="line">  fn: 注册的事件回调</span><br><span class="line">  sel: 筛选的selector</span><br><span class="line">  proxy：真正执行的代理方法</span><br><span class="line">  i：注册后的索引，方便删除</span><br><span class="line">  del：事件代理，用来判断是否需要在冒泡阶段执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 而真正执行的proxy方法如下所示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">handler.proxy = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 给事件打补丁</span></span><br><span class="line">        e = compatible(e)</span><br><span class="line">        <span class="keyword">if</span> (e.isImmediatePropagationStopped()) <span class="keyword">return</span></span><br><span class="line">        e.data = data</span><br><span class="line">        <span class="keyword">var</span> result = callback.apply(element, e._args == <span class="literal">undefined</span> ? [e] : [e].concat(e._args));	<span class="comment">// 可在event.data里面获取一开始传入的参数</span></span><br><span class="line">        <span class="keyword">if</span> (result === <span class="literal">false</span>) e.preventDefault(), e.stopPropagation()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法封装了事件是否需要继续冒泡和停止默认行为以及传入更多参数。</p>
<p>而真正的事件委托代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delegator = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> evt, match = $(e.target).closest(selector, element).get(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">if</span> (match &amp;&amp; match !== element) &#123;</span><br><span class="line">    evt = $.extend(createProxy(e), &#123;<span class="attr">currentTarget</span>: match, <span class="attr">liveFired</span>: element&#125;)</span><br><span class="line">    <span class="keyword">return</span> callback.apply(match, [evt].concat(slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>closest方法为目标元素逐级向上找到和selector匹配的祖先元素，边界为element。如果找到了匹配的元素，扩展currentTarget属性并执行回调函数。</p>
<p>在文档中事件触发，可以调用dispatchEvent方法。不太懂为什么碰到foucus事件时候，直接调用元素的focus方法。因为zepto返回对象并不一定都是DOM节点，如果不是的话，直接拿到该对象绑定的方法即上述所说的handler，然后调用，这样也会导致事件没有冒泡，毕竟也不是DOM节点嘛。</p>
<p>移除事件得看zepto对于绑定的数据结构。对于每个目标元素都有自增ID，事件也是个列表，里面的对象就是上述的handler。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handlers = &#123;</span><br><span class="line">	0: [handler],</span><br><span class="line">	1: [handler]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以取值的时候根据元素的自增id拿到事件列表，再过滤出对应事件删除索引即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://github.com/qianlongo/zepto-analysis" target="_blank" rel="noopener">zepto-analysis</a></li>
<li><a href="[https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8BEvent%E6%A8%A1%E5%9D%97.md](https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/读Zepto源码之Event模块.md">读Zepto源码之Event模块</a>)</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/31/Angular组件样式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/31/Angular组件样式/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-31T16:22:12+08:00">
                2020-08-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Angular组件样式"><a href="#Angular组件样式" class="headerlink" title="Angular组件样式"></a>Angular组件样式</h1><p>最近遇到了在动态创建模板时候，样式无法附加上去的问题。研究了一下，发现和Angular视图封装模式有关，我们先来模拟一下这个情况：</p>
<!-- read more -->
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html模板</span></span><br><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">"container"</span>&gt;</span><br><span class="line">	&lt;ng-template #container&gt;&lt;<span class="regexp">/ng-template&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;ng-template #msgTpl&gt;</span><br><span class="line">	&lt;div <span class="keyword">class</span>=<span class="string">"msg"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>ng-template&gt;</span><br><span class="line"><span class="comment">// component</span></span><br><span class="line"><span class="meta">@ViewChild</span>(<span class="string">"msgTpl"</span>) <span class="keyword">private</span> msgTpl: TemplateRef&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"><span class="meta">@ViewChild</span>(<span class="string">"container"</span>, &#123; read: ViewContainerRef &#125;)</span><br><span class="line"><span class="keyword">private</span> container: ViewContainerRef;</span><br><span class="line"></span><br><span class="line">createMsg() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; container, msgTpl &#125; = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> view = container.createEmbeddedView(msgTpl);</span><br><span class="line">  view.rootNodes[<span class="number">0</span>].innerHTML = <span class="string">`&lt;span class="timestamp"&gt;&lt;b&gt;14:17:52&lt;/b&gt;123 `</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>container是放入模板的容器位置，msgTpl就是模板。创建模板时，我们直接对<code>div</code>节点赋予了html字符串，然而我在css里面定义了<code>timestamp</code>类的背景色，并未生效。具体代码可看<a href="https://stackblitz.com/edit/angular-version-79muv9" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="视图封装模式"><a href="#视图封装模式" class="headerlink" title="视图封装模式"></a>视图封装模式</h2><p>根据Angular文档，组件的样式封装一共有三种：</p>
<ol>
<li><code>Native</code>：使用浏览器原生的<code>Shadow DOM</code>，这种模式下，外界无法入侵组件，组件的样式也无法影响到外界。</li>
<li><code>None</code>：不再封装样式，就和原始开发模式一样，相同的选择器样式会互相覆盖。</li>
<li><code>Emulated</code>：这也是默认封装模式，组件样式无法影响到外界，但是外界样式可以入侵组件。</li>
</ol>
<p>可以在组件元数据中的<code>encapsulation</code> 属性来设置组件封装模式：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">encapsulation: ViewEncapsulation.Native</span><br></pre></td></tr></table></figure>
<p>我们以上述例子着重来分析第三种封装模式，可以看到<code>div</code>节点的选择器多了一些东西，而<code>timestamp</code>并无变化。</p>
<p><img src="/2020/08/31/Angular组件样式/zhaorenjie/Documents/blog/source/_posts/Angular组件样式/无法渲染msg.jpeg" alt="无法渲染msg" style="zoom: 50%;"></p>
<p>这说明仿真模式其实是对DOM节点设置了属性，属性名采用了自增ID以防止名字的冲突。那么为什么<code>timestamp</code>类并后面没有紧跟属性选择器呢？思考一下，Angular是需要经过编译的，样式代码应该在编译过程中会被替换成<code>_ngcontent-xxx</code>格式，而HTML模板编译出来的组件工厂 <code>xx.ngfactory.js</code>会在内部创建节点的过程中设置相同名称的属性。但是我们动态创建的模板直接对html属性赋值字符串的，并没有走Angular内部的创建节点过程，所以导致节点并没有设置属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 编译出来的css --&gt;</span></span><br><span class="line">.msg[_ngcontent-xx] &#123;</span><br><span class="line">	.timestamp &#123;</span><br><span class="line">		xxx</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">&lt;!-- html动态生成后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">_ngcontent-xxx</span> <span class="attr">class</span>=<span class="string">"msg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 赋值了html字符串后,没有设置上属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">_ngcontent-xxx</span> <span class="attr">class</span>=<span class="string">"msg"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"timestamp"</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">span</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么该如何解决这个问题呢？我们再来想平时使用的<code>:host</code>选择器和<code>::ng-deep</code>伪类的作用，当加上<code>:host ::ng-deep</code>选择器后，如果子组件也是仿真模式，那么父组件只要样式权重较大就可以覆盖子组件的样式。而如果直接以<code>::ng-deep</code> 伪类的选择器，按照Angular文档的解释，会完全禁止css样式的包装，从而变成全局样式。我们给msg类分别添加两种选择器看看。</p>
<p>可以看到组件标签会设置<code>_nghost-xxx</code>属性，而子节点都设置了<code>_ngcontent-xxx</code>属性。当带有<code>:host</code>样式时候，样式选择器也会添加属性前缀，而不再是<code>_ngcontent-xx</code>属性选择器，所以父组件才能入侵子组件的样式。而<code>:ng-deep</code>则完全没有变化，没有添加任何选择器，这样的缺点很明显，失去了封装意味着冲突，但是在弹层之类的组件却很有效。</p>
<p>回到之前的问题，<code>timestamp</code>类样式无法附加上，因为他没有<code>_ngcontent</code>前缀。但是刚刚分析<code>::ng-deep</code> 伪类不会对其包装，所以我们只需要在<code>timestamp</code>类添加<code>::ng-deep</code>前缀样式即可生效，验证后成功！</p>
<p>完整代码请看<a href="https://stackblitz.com/edit/angular-version-jfm2fw" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>下面我们来看下源码，首先搜索<code>ngcontent</code>关键词，发现了在<code>dom_renderer</code>文件中有<code>_ngcontent-${COMPONENT_VARIABLE}</code>的正则，并且代码也有和封装模式的枚举有关，看来要找的就是这个文件了。其次，我们对css文件编译，使用<code>.node_modules/.bin/ngc</code>就可以得到组件工厂文件了看一下不同的选择器产生的结果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 源代码																			// 编译结果</span><br><span class="line">.container &#123;																	.container[_ngcontent-%COMP%] &#123;&#125;</span><br><span class="line">	<span class="selector-tag">xx</span>											<span class="selector-tag">----</span>&gt;										<span class="selector-tag">xx</span></span><br><span class="line">&#125;																							&#125;</span><br><span class="line">:host ::ng-deep &#123;															.container [_ngcontent-%COMP%] &#123;</span><br><span class="line">	.container &#123;					  ----&gt;										.timestamp &#123;&#125;</span><br><span class="line">		<span class="selector-class">.timstamp</span> &#123;&#125;															&#125;		</span><br><span class="line">	&#125;											</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">:host</span> &#123;</span><br><span class="line">	.container &#123;						----&gt;								.container [_ngcontent-%COMP%] &#123;</span><br><span class="line">		<span class="selector-class">.timstamp</span> &#123;&#125;																	<span class="selector-class">.timestamp</span> <span class="selector-attr">[_ngcontent-%COMP%]</span> &#123;&#125;</span><br><span class="line">	&#125;																						&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::ng-deep</span> &#123;</span><br><span class="line">	.container &#123;&#125;					  ----&gt;								.container &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">:host-context(p) &#123;														p [_nghost-%COMP%] &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;&#125;						<span class="selector-tag">----</span>&gt;									<span class="selector-class">.container</span> &#123;&#125;</span><br><span class="line">  &#125;																						&#125;</span><br></pre></td></tr></table></figure>
<p>我们都知道Angular不提倡使用原生的方法去操作DOM节点（DOM节点也不建议操作），而是调用<code>renderer2</code>对象去操作，它里面的方法基本覆盖了常用操作，如设置属性、样式和类名等等。这是因为在不同的平台，DOM的操作的api并不是一样的，比如在浏览器端可以直接使用document，而在服务端渲染时并没有document，而是使用了<code>domino</code>库模拟了document。所以如果需要跨平台，最好是调用<code>renderer2</code>对象操作，同理还有<code>DOCUMENT</code>对象等。</p>
<p>不过我们今天的关注并不在此，因为我们只需要看浏览器端的调用即可。Renderer2只会在创建组件的时候才会调用，子节点的创建会调用内部的<code>createElement</code>方法。在<code>DomRendererFactory2</code>类中使用了策略模式根据不同的类型创建Renderer2。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ViewEncapsulation.Emulated: &#123;</span><br><span class="line">  <span class="keyword">let</span> renderer = <span class="keyword">this</span>.rendererByCompId.get(<span class="keyword">type</span>.id);</span><br><span class="line">  <span class="keyword">if</span> (!renderer) &#123;</span><br><span class="line">    renderer = <span class="keyword">new</span> EmulatedEncapsulationDomRenderer2(</span><br><span class="line">      <span class="keyword">this</span>.eventManager, <span class="keyword">this</span>.sharedStylesHost, <span class="keyword">type</span>, <span class="keyword">this</span>.appId);</span><br><span class="line">    <span class="keyword">this</span>.rendererByCompId.set(<span class="keyword">type</span>.id, renderer);</span><br><span class="line">  &#125;</span><br><span class="line">  (&lt;EmulatedEncapsulationDomRenderer2&gt;renderer).applyToHost(element);</span><br><span class="line">  <span class="keyword">return</span> renderer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> EmulatedEncapsulationDomRenderer2&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">      eventManager: EventManager, sharedStylesHost: DomSharedStylesHost,</span></span><br><span class="line"><span class="params">      <span class="keyword">private</span> component: RendererType2, appId: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(eventManager);</span><br><span class="line">    <span class="keyword">const</span> styles = flattenStyles(appId + <span class="string">'-'</span> + component.id, component.styles, []);</span><br><span class="line">    sharedStylesHost.addStyles(styles);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.contentAttr = shimContentAttribute(appId + <span class="string">'-'</span> + component.id);</span><br><span class="line">    <span class="keyword">this</span>.hostAttr = shimHostAttribute(appId + <span class="string">'-'</span> + component.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部有个缓存，键值是组件的id。编译器生成出工厂文件就会带有id，也可以理解为是自增ID。没有击中缓存的话，就会实例化<code>EmulatedEncapsulationDomRenderer2</code>对象，再放入缓存中。在构造器中，利用正则取得组件的<code>host</code>和<code>content</code>的名称，也就是之前所说nghost-xxx和ngcontent-xxx的后缀。有了host名称后，就可以设置组件属性。然后再用正则替换样式，并创建style标签，添加到head标签内。我们可以看到仿真对象的<code>createElement</code>方法，它会先创建DOM子节点，再对子节点设置content名称属性。这样就验证了我们之前的想法。</p>
<p>最后来看影子DOM的封装，就是调用了浏览器的<code>attachShadow</code>方法实现。它不缓存组件的rendere2对象，因为每次创建影子DOM，都会产生新的影子节点，如果缓存就会产生冲突。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上我们可以学习到Angular的视图封装模式：</p>
<ol>
<li>通过编译改变了带有特定选择器如:host的样式代码。</li>
<li>对组件标签设置nghost属性，对组件内部节点设置ngcontent属性。</li>
</ol>
<p>回到之前的问题，其实我们还有一种方法修正，可以创建动态组件，再在父组件中设置</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:host</span> <span class="selector-pseudo">::ng-deep</span> &#123;</span><br><span class="line">	.timestamp &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为只会改变最外层的样式代码，timestamp仍然会附加到子组件样式上。具体代码请看<a href="https://stackblitz.com/edit/angular-version-istypu" target="_blank" rel="noopener">这里</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="食饼筒">
            
              <p class="site-author-name" itemprop="name">食饼筒</p>
              <p class="site-description motion-element" itemprop="description">do better</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">食饼筒</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>


<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style="display:none">
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style="display:none">
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共60.9k字</span>
</div>
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
