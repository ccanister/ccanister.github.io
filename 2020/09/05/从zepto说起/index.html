<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="从zepto说起学完underscore源码，操作对象和常用的函数等应该都是手到擒来了。接下来来看DOM操作，毕竟是前端，更多还是为浏览器服务的。jquery源码点进去一看几千行吧，吓得退了出来，后来发现还有zepto也是针对浏览器的js库，而且更为轻量，没有较多的兼容低版本代码，所以选择看zepto源码。 zepto的测试用例比较恶心，框架好像是自己搭的，测试用例出错的时候也不会说明是哪个出错，">
<meta property="og:type" content="article">
<meta property="og:title" content="稠鱼烧才好吃">
<meta property="og:url" content="http://yoursite.com/2020/09/05/从zepto说起/index.html">
<meta property="og:site_name" content="稠鱼烧才好吃">
<meta property="og:description" content="从zepto说起学完underscore源码，操作对象和常用的函数等应该都是手到擒来了。接下来来看DOM操作，毕竟是前端，更多还是为浏览器服务的。jquery源码点进去一看几千行吧，吓得退了出来，后来发现还有zepto也是针对浏览器的js库，而且更为轻量，没有较多的兼容低版本代码，所以选择看zepto源码。 zepto的测试用例比较恶心，框架好像是自己搭的，测试用例出错的时候也不会说明是哪个出错，">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2020/09/05/从zepto说起/zhaorenjie/Documents/blog/source/_posts/从zepto说起/图片尺寸.jpeg">
<meta property="og:image" content="http://yoursite.com/2020/09/05/从zepto说起/zhaorenjie/Documents/blog/source/_posts/从zepto说起/offsetParent.jpg">
<meta property="og:updated_time" content="2020-10-02T03:49:03.456Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="稠鱼烧才好吃">
<meta name="twitter:description" content="从zepto说起学完underscore源码，操作对象和常用的函数等应该都是手到擒来了。接下来来看DOM操作，毕竟是前端，更多还是为浏览器服务的。jquery源码点进去一看几千行吧，吓得退了出来，后来发现还有zepto也是针对浏览器的js库，而且更为轻量，没有较多的兼容低版本代码，所以选择看zepto源码。 zepto的测试用例比较恶心，框架好像是自己搭的，测试用例出错的时候也不会说明是哪个出错，">
<meta name="twitter:image" content="http://yoursite.com/2020/09/05/从zepto说起/zhaorenjie/Documents/blog/source/_posts/从zepto说起/图片尺寸.jpeg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/09/05/从zepto说起/">





  <title> | 稠鱼烧才好吃</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">稠鱼烧才好吃</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/05/从zepto说起/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="食饼筒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="稠鱼烧才好吃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-05T17:12:47+08:00">
                2020-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="从zepto说起"><a href="#从zepto说起" class="headerlink" title="从zepto说起"></a>从zepto说起</h1><p>学完underscore源码，操作对象和常用的函数等应该都是手到擒来了。接下来来看DOM操作，毕竟是前端，更多还是为浏览器服务的。jquery源码点进去一看几千行吧，吓得退了出来，后来发现还有zepto也是针对浏览器的js库，而且更为轻量，没有较多的兼容低版本代码，所以选择看zepto源码。</p>
<p>zepto的测试用例比较恶心，框架好像是自己搭的，测试用例出错的时候也不会说明是哪个出错，只有统计结果xxx运行成功，xxx运行失败，相对而言还是qunit框架的测试反馈直观。</p>
<!-- readMore -->
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>zepto核心方法就是<code>$</code>方法，他可以传入css选择器查询DOM节点，也可以传入字符串创建新的DOM节点，最终返回的是类数组，即带有索引的zepto对象。还可以传入函数，可以在页面加载完毕后执行。</p>
<p>当传入的第一个参数是字符串时候，先删除首尾的空白字符。如果首字符是<code>&lt;</code>，说明是解析字符串创建DOM节点，否则就是查询。</p>
<h3 id="查询DOM节点"><a href="#查询DOM节点" class="headerlink" title="查询DOM节点"></a>查询DOM节点</h3><p>查询接口分成两种：<code>getElementsBy</code>系列和<code>querySelectorAll</code>，浏览器基本能够兼容这两种方法。但是zepto会根据类型判断，依次是id、class和tag，都有对应的<code>getElementsBy</code>方法查询，最后才降低到querySelectorAll函数，采用这种方法的目的肯定是尽可能地提高选择器性能。除了这点，两者其他区别：</p>
<ol>
<li><p>传入参数不同：getElementsBy只能传入单一的id、className和tagName，而<code>querySelectorAll</code>可以接受css选择器。所以zepto中有个正则<code>/^[\w-]*$/</code>判断是否是单一的选择符，防止有空格符隔开，而用了错误的查询。</p>
</li>
<li><p>返回值：这点比较重要，getElementsBy返回的是动态的HTMLCollection，而querySelectorAll返回的是静态的NodeList。可以看这个经典的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// querySelectorAll</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelectorAll(<span class="string">'ul'</span>)[<span class="number">0</span>],</span><br><span class="line">    lis = ul.querySelectorAll(<span class="string">"li"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length ; i++)&#123;</span><br><span class="line">    ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"li"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getElementsBy</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>], </span><br><span class="line">    lis = ul.getElementsByTagName(<span class="string">"li"</span>); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length ; i++)&#123;</span><br><span class="line">    ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"li"</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为getElementsBy返回的是动态节点集合，当该查询有变化时候，返回的集合也会有之变化，所以会导致无限循环。</p>
<p>而querySelectorAll返回的集合就是个快照，不会有什么影响。</p>
<p>当然在zepto中，对两个选择器返回的结果重新塞入新对象中，所以也是个静态集合。</p>
<p>除了这点，HTMLCollection只包含元素节点，即nodeType为1的节点，节点的children属性可以返回这类集合，而NodeList是包含所有类型的节点，可以通过节点的childNodes属性返回。所以有时候前者返回的集合是空的，但后者长度不为空，一般可能返回了文本节点。</p>
</li>
</ol>
<h3 id="解析字符串"><a href="#解析字符串" class="headerlink" title="解析字符串"></a>解析字符串</h3><p>因为浏览器本身就是支持innerHTML属性的，所以第一想法就是利用该属性。但是这里有个坑就是利用innerHTML属性，就要有个父节点，那么父节点的标签名往往会用<code>div</code>，但div父标签并不能创建所有的子节点，比如表格的标签tr、tbody等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">div.innerHTML = <span class="string">"&lt;td&gt;123&lt;/td&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div.childNodes) <span class="comment">// [text]</span></span><br></pre></td></tr></table></figure>
<p>会忽略掉td节点，只有123文本节点。所以父标签需要有个映射表。</p>
<p>另外一点，为了提高性能，当传入单标签的字符串即<code>&lt;div&gt;&lt;/div&gt;</code>，里面没有包裹任何元素时候，会直接使用createElement方法，而不是采用上述方法。</p>
<h2 id="元素属性"><a href="#元素属性" class="headerlink" title="元素属性"></a>元素属性</h2><p>这里的属性指的不是properity，而是我们平常打交道的css、class、prop和attribute等。通常操作就是增删改查，需要关注的一个点是键值有中划线和驼峰两种格式，两者在不同的操作下有时候可取有时候不可取。</p>
<h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><p>想要取得节点的样式，不能直接通过style属性。因为style属性只存储了内联样式，但是节点最终的样式是综合规则计算出来的，单单读取内联样式是不够的。所以正确的做法是通过getComputedStyle(el, [pseudoElt])方法取值，该方法返回了动态的CSSStyleDeclaration对象，第二个参数传入元素的伪类，如<code>:before</code>。当元素的样式更改时，它会自动更新本身。注意，style属性返回的也是CSSStyleDeclaration对象。取值的时候，CSSStyleDeclaration对象同时存储了中划线和驼峰两种键值，比如<code>margin-top</code>就会同时存储<code>margin-top</code>和<code>marginTop</code>两个键值，所以不用在乎键值格式。</p>
<p>删除和设置元素的时候有两种方法：</p>
<ol>
<li>调用style属性的CSSStyleDeclaration对象，它暴露两个方法removeProperty和setProperty。</li>
<li>调用style属性的cssText，它返回了内联样式上所有css字符串，相邻样式用;隔开。设置值的时候可以直接在后面附加属性，如<code>el.style.cssText += &quot;;width:10px&quot;</code>，如果有重名样式，直接覆盖，所以删除样式，可以这样<code>el.style.cssText += &quot;width:null&quot;</code>。</li>
</ol>
<p>以上两种方法的操作都是基于元素的内联样式，而且键值都要改成中划线格式。在zepto中删除操作采用了第一种方法，设置操作采用了第二种方法。第二种方式可以批处理操作，减少浏览器的重排和回流。</p>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>操作class也是有两种方案，而且不区分名字格式，即<code>className</code>和<code>classList</code>，后者也是类数组，有add、remove等方法，可以传入多个参数，可谓是非常的方便。但是IE10以下不兼容，所以又退化回className字符串的操作。</p>
<p>对于字符串的增删改查，往往使用正则匹配是最为方便的。className是是由空格分隔的多个class属性值。所以匹配的字符串应该为<code>/(^|\s)[classname](\s|$)/</code> 形式，有可能会出现在开头或者结尾处。删除时候，直接将其替换成空字符串即可。还有一个点，对于svg类型的标签需要特别的注意，其className得到的是一个对象,类似这样<code>SVGAnimatedString {baseVal: &quot;box hallo&quot;, animVal: &quot;box hallo&quot;}</code>，所以取className的时候，还得看是否有baseVal属性。</p>
<h3 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a>attribute</h3><p>对于元素属性的操作比较简单，分别调用<code>setAttribute</code>、<code>getAttribute</code>和<code>removeAttribute</code>方法。其中属性值都是小写的，即使传入大写字符，也会被小写化。需要注意的是对于不存在的属性，getAttribute方法会返回null，但不代表着删除值的时候，调用setAttribute就可以传入null参数。因为布尔属性无论设置了任何值都会呗认为是true，比如<code>el.setAttribute(disable, null)</code>，此时按钮也会设置禁用状态。所以删除值时候还是用removeAttribute方法替代。</p>
<h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><p>在Angular中有专门一节对比了attribute和property，它认为attribute是HTML属性，而property是DOM节点属性。两者即可以1:1映射，比如<code>id</code>属性，有可能存在attribute没有对应的property，比如<code>aria-*</code>属性，也有可能存在property没有对应的attribute，比如<code>textContent</code>。但是即使有相同的名字，两者意义也是不一样的。所以在Angular中，attribute的作用是初始化元素和指令的状态。而在标准的差异如下：</p>
<ol>
<li><p>取值方法不同：property通过el[name]获取，attribute通过el.getAttribute(name)获取。</p>
</li>
<li><p>同步：property会从attribute中同步属性，意味着改变了attribute也会改变property属性，反之则不会。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el.setAttribute(<span class="string">"disabled"</span>, <span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(el.disbaled)	<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>键值格式：attribute会忽略大小写，property不会忽略，但是有些保留字比如class，不能通过el.class获取，而是el.className</p>
</li>
</ol>
<h3 id="data"><a href="#data" class="headerlink" title="data-*"></a>data-*</h3><p>Data-*是h5具有扩展型的设计，允许在HTML元素中存储额外的信息，js和css都能访问到该属性。在元素上设置值的时候，会忽略大小写，大写字符也会被转成小写的字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  article[data-columns=<span class="string">"3"</span>] &#123;</span><br><span class="line">  	background: orange;</span><br><span class="line">  &#125;</span><br><span class="line">  article::before &#123;</span><br><span class="line">    content: attr(data-columns);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;article id="article" data-columns=3&gt;</span></span><br><span class="line"><span class="regexp">	dabai</span></span><br><span class="line"><span class="regexp">&lt;/</span>article&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> article = <span class="built_in">document</span>.querySelector(<span class="string">"#article"</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(article.dataset.columns);	<span class="comment">// 3</span></span><br><span class="line">	<span class="built_in">console</span>.log(article.getAttribute(<span class="string">"data-columns"</span>));	<span class="comment">// 3</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到对于js而言，有两种操作方法，一个是通过dataset属性，不需要添加data-前缀，但是要把中划线格式转换成驼峰，另外一个是通过attributes属性，需要加上data-的前缀。对于css而言，同样可以直接调用attr方法当作样式值，或者当作属性选择器来改变样式，但都要加上data-的前缀。</p>
<p>这样js通过设置data-*共享变量就能改变元素样式，从而减少逻辑。</p>
<h2 id="DOM的增删改查"><a href="#DOM的增删改查" class="headerlink" title="DOM的增删改查"></a>DOM的增删改查</h2><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>zepto插入元素的方法有很多种，而且写法都很巧妙。我们先来看append、prepend、after和before这四种方法，其他都是衍生方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;div id=<span class="string">"beforeafter"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ js</span></span><br><span class="line"><span class="regexp">$("#beforeafter").append("append");</span></span><br><span class="line"><span class="regexp">$("#beforeafter").prepend("prepend");</span></span><br><span class="line"><span class="regexp">$("#beforeafter").before("before");</span></span><br><span class="line"><span class="regexp">$("#beforeafter").after("after");</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 最后输出 before&lt;div id="beforeafter"&gt;prependappend&lt;/</span>div&gt;after</span><br></pre></td></tr></table></figure>
<p>可以看到append插入到匹配元素的最后一个子节点的后面，prepend是插入到匹配元素的第一个子节点前面。after插入到匹配元素的后面，before插入到匹配元素前面。上下区别是一个在内部，一个在外部。</p>
<p>上面四种方法有两个相同点：</p>
<ol>
<li><p>传入参数是一样的：可以是html字符串，也可以是dom节点、Zepto内置的对象或者以上组成的数组。这个比较好解决，html字符串就调用核心方法<code>fragment</code>解析字符串；如果是数组就去遍历即可。</p>
</li>
<li><p>都是插入到某个元素的节点，最后都可以调用parent.appenchild(node, child)方法。具体可以这么看</p>
<p>|         | parent           | 被插入的元素           |<br>| ——- | —————- | ———————- |<br>| append  | 当前元素         | null                   |<br>| prepend | 当前元素         | 当前元素的firstChild   |<br>| after   | 当前元素的父节点 | 当前元素下一个兄弟节点 |<br>| before  | 当前元素的父节点 | 当前元素               |</p>
</li>
</ol>
<p>解决了这两个问题，就基本能看懂插入元素的函数了。还有两个细节值得关注：</p>
<ul>
<li>如果插入元素是数组且长度大于1，那么插入的元素需要克隆，否则如果元素处在文档中，就会不断从上个元素中删除再插入到下个元素，最后会被插入到zepto对象最后一个元素节点。</li>
<li>如果插入的元素在节点中，而且是内联的script标签节点，需要调用eval方法执行脚本。注意这里上下文的取值<code>var target = el.ownerDocument? el.ownerDocument.defaultView window;</code>。如果是iframe上下文是el.ownerDocument.defaultView，否则正常的窗口上下文是window。</li>
</ul>
<p>after、prepend、before和append衍生的方法分别是insertAfter、prependTo、insertBefore和appendTo，可以看作参数和调用上下文刚好相反即可。</p>
<h3 id="包裹元素"><a href="#包裹元素" class="headerlink" title="包裹元素"></a>包裹元素</h3><p>包裹元素的方法有三种，分别是wrap、wrapAll和wrapInner，文字描述功能有些晦涩，我们直接看demo：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = $(<span class="string">"&lt;b&gt;A&lt;/b&gt;&lt;b&gt;B&lt;/b&gt;"</span>);</span><br><span class="line">el.wrap(<span class="string">"&lt;a class=link&gt;&lt;/a&gt;"</span>);	<span class="comment">// &lt;a class=link&gt;&lt;b&gt;A&lt;/b&gt;&lt;/a&gt;&lt;a class=link&gt;&lt;b&gt;B&lt;/b&gt;&lt;/a&gt;</span></span><br><span class="line">el.wrapAll(<span class="string">"&lt;a class=link&gt;&lt;/a&gt;"</span>);	<span class="comment">// &lt;a class=link&gt;&lt;b&gt;A&lt;/b&gt;&lt;b&gt;B&lt;/b&gt;&lt;/a&gt;</span></span><br><span class="line">el.wrapInner(<span class="string">"&lt;a class=link&gt;&lt;/a&gt;"</span>);	<span class="comment">// &lt;b&gt;&lt;a class=link&gt;A&lt;/a&gt;&lt;/b&gt;&lt;b&gt;&lt;a class=link&gt;B&lt;/a&gt;&lt;/b&gt;&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>
<p>wrap就是包裹el的每个子节点，wrapAll直接包裹el，wrapInner是包裹el的每个子节点的内容。可以发现wrapAll是底层方法，其他两个方法都可以调用它来实现逻辑，所以先来看wrapAll方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wrapAll: <span class="function"><span class="keyword">function</span> (<span class="params">structure</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">    $(<span class="keyword">this</span>[<span class="number">0</span>]).before((structure = $(structure)));</span><br><span class="line">    <span class="keyword">var</span> children;</span><br><span class="line">    <span class="comment">// drill down to the inmost element</span></span><br><span class="line">    <span class="keyword">while</span> ((children = structure.children()).length)</span><br><span class="line">      structure = children.first();</span><br><span class="line">    $(structure).append(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>首先要把外包裹元素插入到文档中，因为structure参数可以是html字符串，如果不先插入文档中，就直接被外层包裹的元素带走无法在浏览器中显示。然后迭代查询外包裹元素的第一个子节点，注意children方法返回的element类型的节点，不会返回文本节点的。最后把被包裹元素插入到第一个子节点末尾。</p>
<p>另外我们来看这两个例子</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">$('.box').wrapAll('.wrap')</span><br><span class="line">// 结果</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时的ul结构仍然存在。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"here"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"here"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">// 结果</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"here"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"here"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时ul结构被移动到第一个div标签中。上述两个例子的结果不同是因为，第一个外包裹元素的第一个子节点就是两个div，而第二个的第一个字节点是第一个class为here的div节点。在append方法中我们提到过被插入的元素长度超过1时候，插入元素会克隆。</p>
<p>看完了wrapAll方法，再来看wrap就很简单，只要遍历每个子元素节点再调用wrapAll方法即可。而wrapInner方法，遍历子元素节点时候，子元素的子节点调用wrapAll方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wrapInner: <span class="function"><span class="keyword">function</span> (<span class="params">structure</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = $(<span class="keyword">this</span>),</span><br><span class="line">    contents = self.childrenNodes,</span><br><span class="line">    contents.length ? contents.wrapAll(structure) : self.append(structure);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="查询DOM内容"><a href="#查询DOM内容" class="headerlink" title="查询DOM内容"></a>查询DOM内容</h3><ol>
<li><p>children：只查询元素节点，即children属性，或者childNodes属性再过滤nodeType为1的节点。</p>
</li>
<li><p>text：text获取有两种方法：innerText和textContent。两者都可以拿到包括子节点的文本内容和设置值。</p>
<ul>
<li>空格等设置：textContent会直接获取所有空格或者换行符，innerText会根据元素是否是块级而合并空格。</li>
<li>子元素隐藏后文本内容显示：textContent仍然显示全部，innerText如果隐藏不再显示。</li>
<li>性能：可以看得出innerText会计算元素属性，性能较差。</li>
</ul>
</li>
<li><p>val：根据value属性取值，注意的是select表单控件的value是多项的，可以根据multiple属性判断。selectedOptions属性可以直接获取选中值，但是ie不支持该属性，所以还是要遍历option元素。</p>
</li>
<li><p>hmtl：根据innerHTML属性设置或者获取。</p>
</li>
<li><p>height和width：我们以width为例先，DOM的宽度有三类：</p>
<ul>
<li>clientWidth:：内容的width+padding</li>
<li>offsetWidth:：内容width+padding+border</li>
<li>scrollWidth：包括由于overflow溢出而在屏幕上不可见的内容宽度。如果没有出现水平滚动条，可以认为等于clientWidth。</li>
</ul>
<p>当然行内元素的宽度都是0。zepto返回的元素宽度用的是scrollWidth。</p>
<p>除此之外，也可以通过el.getBoundingClientRect方法获取，它计算出的width等于右border-左border，看起来和offsetWidth一样。但是这个width是实际渲染出来的宽度，比如说附加了<code>transform:scale(1.5)</code>样式，对于offsetWidth是不会变的，而getBoundingClientRect方法返回的宽度会乘以1.5倍，是实际呈现为准。同理getBoundingClientRect方法返回的top也是从窗口上方开始到元素的border（不包含）为止的高度。如果该元素是可滚动，那么top也是可变的。</p>
<p><img src="/2020/09/05/从zepto说起/zhaorenjie/Documents/blog/source/_posts/从zepto说起/图片尺寸.jpeg" alt="图片尺寸" style="zoom:67%;"></p>
<center>偷了别人的图</center>

<p>上述宽度都是针对元素节点，如果是window，我们一般用innerWidth获取宽度，因为outerHeight往往包括了浏览器的任务栏和窗口高度等。如果是document，我们返回内容宽度即offsetWidth。</p>
</li>
</ol>
<h2 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h2><h3 id="offsetParent"><a href="#offsetParent" class="headerlink" title="offsetParent"></a>offsetParent</h3><p>返回第一个定位过的祖先元素，即祖先元素的的position不是static。DOM原声就有offsetParent属性，但是如果当元素隐藏起来的时候，offsetParent返回null，zepto返回的是body对象。</p>
<h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><p>offset方法类似getBoundingClientRect方法，获取元素的渲染后的width、height、top和left。如果元素既不是html（根据document.documentElement判断）也不在文档中，则返回<code>{top: 0, left: 0}</code>。之前有说过getBoundingClientRect返回的top指的是从窗口上方开始到元素的border为止（不包含）的高度，如果当前文档已滚动，那么取得的top是不准的，所以还要加上window.pageYOffset。</p>
<p>设置值的时候，不能直接赋予元素偏移值。</p>
<p><img src="/2020/09/05/从zepto说起/zhaorenjie/Documents/blog/source/_posts/从zepto说起/offsetParent.jpg" alt="offsetParent" style="zoom:50%;"></p>
<p>如上图所示，元素的偏移量会根据第一个定位过的祖先元素而变化，假设祖先元素的top为100，元素需要设置的top为100，如果直接设置，会导致最后的top为200。所以最终的偏移量应该减去祖先元素的偏移量才是正确的。如果元素的定位属性是<code>static</code>，则会将其改为<code>relative</code>定位，再相对于其正常文档流来计算。</p>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>position方法返回相对于第一个定位过的祖先元素的位置，即<code>{top: xx,left: xx}</code>。如果元素是body或者html节点直接返回<code>{top: 0, left: 0}</code>。</p>
<p>整体思路还是用当前元素相对于文档的位置减去第一个定位祖先元素相对于文档的位置，需要注意的是top从祖先元素的padding（包含）开始直到当前元素的border（包含）。</p>
<h3 id="scrollLeft-amp-amp-scrollTop"><a href="#scrollLeft-amp-amp-scrollTop" class="headerlink" title="scrollLeft &amp;&amp; scrollTop"></a>scrollLeft &amp;&amp; scrollTop</h3><p>取值的话可以直接通过scrollLeft属性，设置值的时候使用scrollTo或者scrollIntoViewIfNeeded方法，传入的第二个参数是<code>{behavior: smooth}</code>，表示平滑滚动，此时会多次触发scroll事件。也可以直接设置scrollLeft值，进行跳转。</p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。网上有个例子很形象，我直接摘抄过来：</p>
<p>有几个同事预计在周一会收取到快递，为签收快递，有两种办法：一是三个人在门口等待快递；二是让快递放在前台由前台代替接受。在现实当中，我们一般会采用第二种方法，让前台帮忙签收。在这里有两层含义：</p>
<ol>
<li>当前同事快递可以由前台代收，即文档中的DOM节点事件能够触发。</li>
<li>新来的同事快递也可以由前台代收，即文档中新增的DOM节点事件也能够触发。</li>
</ol>
<p>可以看到好处是有很多的，最直观的就是提高了效率，不用每个同事去处理快递。类比DOM也是一样的，不用DOM节点自己去添加监听事件，只需要有一个守门人就能够处理所有的事件，能提高浏览器的性能。</p>
<p>而这个守门人是谁呢，就是需要监听事件的父节点，极端来说可以看作根节点。因为事件默认是冒泡的，当触发事件时候，会从触发的节点开始逐级往上最终到达根节点，event.target表示触发事件的节点，我们再根据这个属性判断进行相应的操作。当然，也没有人这么傻会把根节点当作守门人，中途很有可能再被某个处理停止了。往往在父节点附加即可。</p>
<p>一般讨论时候都会用ul做例子，我们也来看：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"add"</span>&gt;</span>添加li<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span>dabai<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"2"</span>&gt;</span>xiaobai<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"3"</span>&gt;</span>middlebai<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>bai<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们想给li标签添加点击后显示起id事件，再给按钮添加增加li节点的事件。一般会这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = <span class="built_in">document</span>.getElementById(<span class="string">"wrapper"</span>);</span><br><span class="line"><span class="keyword">const</span> children = wrapper.getElementsByTagName(<span class="string">"li"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">  children[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  	alert(event.target.id);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"add"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, () =&gt; &#123;</span><br><span class="line">  wrapper.append(<span class="string">`&lt;li id=<span class="subst">$&#123;children.length&#125;</span>&gt;xixixi&lt;/li&gt;`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里的两个问题也是很明显：一个是需要遍历所有的li标签，假设有一百个我们就需要遍历一百次，很消耗性能；再一个就是点击按钮后添加的li节点并没有附加事件监听。</p>
<p>我们利用ul父节点做事件委托，所有的事件处理都在ul监听的事件中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wrapper.addEventListener(<span class="string">"click"</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> target = event.target;</span><br><span class="line">  <span class="keyword">if</span> (target.tagName.toLowerCase() === <span class="string">"li"</span>) &#123;</span><br><span class="line">  	alert(target.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>对evnet.target的标签名是否是li，是的话再去操作，也可以判断是否是div，去做其他操作。点击按钮增加后，也是可以弹出提示的。</p>
<p>这就是简单的事件委托，只需要在父节点监听事件即可。缺陷就有两点：</p>
<ol>
<li>中途的事件可能会停止冒泡，拦截了事件。</li>
<li>有些事件并不支持冒泡，比如focus和blur，下面我们来看zepto是怎么处理的。</li>
</ol>
<p>focus和blur事件虽然不支持冒泡，但他们有个兄弟事件是focusin和focusout，他们的执行顺序是：focus &gt; focus in &gt; blur &gt; focus out。所以有了替代事件。</p>
<p>mouseenter和mouseover也不支持冒泡事件，但是也可以用mouseover和mouseout来模拟，他俩是支持冒泡的。mouseevent中有个属性relatedTarget，表示相关目标节点。mouseover指向从哪里移动到的目标节点，mouseout指向的是目标节点移动到哪里。mouseover在目标节点上移动时候，relatedTarget指向的都是目标节点。所以判断relatedTarget为空或者不为目标节点和其子节点时，可以当作mouseenter和mouseover事件。</p>
<p>zepto实现了从创建事件 -&gt; 绑定事件 -&gt; 触发事件 -&gt; 移除事件的所有流程。</p>
<p>但是我看的版本中创建事件使用了createEvent方法，这在标准中已经过时，推荐用Event的构造器实例化事件，可以传入bubbles等参数表明是否冒泡。</p>
<p>绑定事件中如果传入了选择器，表明使用事件代理，这也说明在传入addEventListener的监听函数中，是会在我们传入的函数上封装一层。为了解绑事件，需要保存初始的函数，除此之外还需要保存事件名称和命名空间、选择器。所以事件绑定时候封装的对象会有以下参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">handler = &#123;</span><br><span class="line">  e: 事件名</span><br><span class="line">  ns：命名空间</span><br><span class="line">  fn: 注册的事件回调</span><br><span class="line">  sel: 筛选的selector</span><br><span class="line">  proxy：真正执行的代理方法</span><br><span class="line">  i：注册后的索引，方便删除</span><br><span class="line">  del：事件代理，用来判断是否需要在冒泡阶段执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 而真正执行的proxy方法如下所示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">handler.proxy = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 给事件打补丁</span></span><br><span class="line">        e = compatible(e)</span><br><span class="line">        <span class="keyword">if</span> (e.isImmediatePropagationStopped()) <span class="keyword">return</span></span><br><span class="line">        e.data = data</span><br><span class="line">        <span class="keyword">var</span> result = callback.apply(element, e._args == <span class="literal">undefined</span> ? [e] : [e].concat(e._args));	<span class="comment">// 可在event.data里面获取一开始传入的参数</span></span><br><span class="line">        <span class="keyword">if</span> (result === <span class="literal">false</span>) e.preventDefault(), e.stopPropagation()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法封装了事件是否需要继续冒泡和停止默认行为以及传入更多参数。</p>
<p>而真正的事件委托代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delegator = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> evt, match = $(e.target).closest(selector, element).get(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">if</span> (match &amp;&amp; match !== element) &#123;</span><br><span class="line">    evt = $.extend(createProxy(e), &#123;<span class="attr">currentTarget</span>: match, <span class="attr">liveFired</span>: element&#125;)</span><br><span class="line">    <span class="keyword">return</span> callback.apply(match, [evt].concat(slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>closest方法为目标元素逐级向上找到和selector匹配的祖先元素，边界为element。如果找到了匹配的元素，扩展currentTarget属性并执行回调函数。</p>
<p>在文档中事件触发，可以调用dispatchEvent方法。不太懂为什么碰到foucus事件时候，直接调用元素的focus方法。因为zepto返回对象并不一定都是DOM节点，如果不是的话，直接拿到该对象绑定的方法即上述所说的handler，然后调用，这样也会导致事件没有冒泡，毕竟也不是DOM节点嘛。</p>
<p>移除事件得看zepto对于绑定的数据结构。对于每个目标元素都有自增ID，事件也是个列表，里面的对象就是上述的handler。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handlers = &#123;</span><br><span class="line">	0: [handler],</span><br><span class="line">	1: [handler]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以取值的时候根据元素的自增id拿到事件列表，再过滤出对应事件删除索引即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://github.com/qianlongo/zepto-analysis" target="_blank" rel="noopener">zepto-analysis</a></li>
<li><a href="[https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8BEvent%E6%A8%A1%E5%9D%97.md](https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/读Zepto源码之Event模块.md">读Zepto源码之Event模块</a>)</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/08/31/Angular组件样式/" rel="next" title>
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/09/16/动手写webpack：loader机制/" rel="prev" title>
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="食饼筒">
            
              <p class="site-author-name" itemprop="name">食饼筒</p>
              <p class="site-description motion-element" itemprop="description">do better</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#从zepto说起"><span class="nav-number">1.</span> <span class="nav-text">从zepto说起</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#核心方法"><span class="nav-number">1.1.</span> <span class="nav-text">核心方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查询DOM节点"><span class="nav-number">1.1.1.</span> <span class="nav-text">查询DOM节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析字符串"><span class="nav-number">1.1.2.</span> <span class="nav-text">解析字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元素属性"><span class="nav-number">1.2.</span> <span class="nav-text">元素属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#css"><span class="nav-number">1.2.1.</span> <span class="nav-text">css</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class"><span class="nav-number">1.2.2.</span> <span class="nav-text">class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attribute"><span class="nav-number">1.2.3.</span> <span class="nav-text">attribute</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#property"><span class="nav-number">1.2.4.</span> <span class="nav-text">property</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#data"><span class="nav-number">1.2.5.</span> <span class="nav-text">data-*</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM的增删改查"><span class="nav-number">1.3.</span> <span class="nav-text">DOM的增删改查</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#插入元素"><span class="nav-number">1.3.1.</span> <span class="nav-text">插入元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包裹元素"><span class="nav-number">1.3.2.</span> <span class="nav-text">包裹元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查询DOM内容"><span class="nav-number">1.3.3.</span> <span class="nav-text">查询DOM内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#偏移"><span class="nav-number">1.4.</span> <span class="nav-text">偏移</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#offsetParent"><span class="nav-number">1.4.1.</span> <span class="nav-text">offsetParent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#offset"><span class="nav-number">1.4.2.</span> <span class="nav-text">offset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#position"><span class="nav-number">1.4.3.</span> <span class="nav-text">position</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scrollLeft-amp-amp-scrollTop"><span class="nav-number">1.4.4.</span> <span class="nav-text">scrollLeft &amp;&amp; scrollTop</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件委托"><span class="nav-number">1.5.</span> <span class="nav-text">事件委托</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">1.6.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">食饼筒</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>


<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style="display:none">
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style="display:none">
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共60.9k字</span>
</div>
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
